{
  "hash": "456c56de326865cc7a2e31176fdccceb",
  "result": {
    "markdown": "---\ntitle: \"Julia basic concepts\"\nauthor: \n    - name: \"Alejandro Morales Sierra\"\n      affiliation: \"Centre for Crop Systems Analysis - Wageningen University\"\ndate: last-modified\nexecute:\n  error: true\n---\n\n# Introduction\n\nThis is not a tutorial or introduction to Julia, but a collection of basic \nconcepts about Julia that are particularly useful to understand VPL.  It is \nassumed that the reader has some  experience with programming in other languages, \nsuch as Matlab, R or Python. These concepts should be complemented with general \nintroductory material about Julia, which can be found at the official \n[Julia website](https://julialang.org/).\n\nJulia is a dynamic, interactive programming language, like Matlab, R or Python. \nThus, it is very easy to use and learn incrementally. The language is young and\nwell designed, with an emphasis on numerical/scientific computation although it \nis starting to occupy some space in areas such as data science and machine \nlearning. It has a clear syntax and better consistency than older programming\nlanguages. \n\nUnlike Matlab, R or Python, Julia was designed from the beginning to be fast (as\nfast as statically compiled languages like C, C++ or Fortran). However, achieving \nthis goal does require paying attention to certain aspects of the language, such \nas *type stability* and *dynamic memory allocation*, which are not always obvious \nto the user coming from other scientific dynamic languages. In the different \nsections below, a few basic Julia concepts are presented, first by ignoring \nperformance considerations and focusing on syntax, and then by showing how to \nimprove the performance of the code. Some concepts are ignored as they are not\ndeemed relevant for the use of VPL.\n\n# Running Julia\n\nThere are different ways of executing Julia code (most popular ones are VS Code \nand Jupyter notebook):\n\n* Interactive Julia console from terminal/console (REPL)\n* Plugins for code editors\n    * Visual Studio Code (most popular)\n    * Atom/Juno (less popular now)\n    * vim, Emacs and others (less popular)\n* Code cells inside a Jupyter notebook\n* Code cells inside Pluto notebook (a Julia implementation of a reactive notebook)\n\nThe first time in a Julia session that a method is called it will take extra \ntime as the method will have to be compiled (i.e. Julia uses a Just-in-Time \ncompiler as opposed to an interpreter). Also, the first time you load a package \nafter installation/update it will take extra time to load due to precompilation \n(this reduces JIT compilation times somewhat). Also, code editors and notebooks\nmay need to run additional code to achieve their full functionality, which may\nadd some delays in executing the code.\n\n# Basic concepts\n\n## Functions\n\nA function is defined with the following syntax. \n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nfunction foo(x)\n    x^2\nend\nfoo(2.0)\n```\n\n::: {.cell-output .cell-output-display execution_count=2}\n```\n4.0\n```\n:::\n:::\n\n\nVery short functions can also be defined in one line\n\n::: {.cell execution_count=2}\n``` {.julia .cell-code}\nfoo2(x) = x^2\n```\n\n::: {.cell-output .cell-output-display execution_count=3}\n```\nfoo2 (generic function with 1 method)\n```\n:::\n:::\n\n\n::: {.cell execution_count=3}\n``` {.julia .cell-code}\nfoo2(2.0)\n```\n\n::: {.cell-output .cell-output-display execution_count=4}\n```\n4.0\n```\n:::\n:::\n\n\nFunctions can also be defined with the \"$\\to$\" syntax. The result can be assigned to any variable.\n\n::: {.cell execution_count=4}\n``` {.julia .cell-code}\nfoo3 = x -> x^2\n```\n\n::: {.cell-output .cell-output-display execution_count=5}\n```\n#11 (generic function with 1 method)\n```\n:::\n:::\n\n\n::: {.cell execution_count=5}\n``` {.julia .cell-code}\nfoo3(2.0)\n```\n\n::: {.cell-output .cell-output-display execution_count=6}\n```\n4.0\n```\n:::\n:::\n\n\nA `begin` - `end` block can be used to store a sequence of statements in multiple lines and assign them to \"short function or a \"$\\to$ function.\n\n::: {.cell execution_count=6}\n``` {.julia .cell-code}\nfoo4 = begin\n    x -> x^2\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=7}\n```\n#13 (generic function with 1 method)\n```\n:::\n:::\n\n\n::: {.cell execution_count=7}\n``` {.julia .cell-code}\nfoo4(2.0)\n```\n\n::: {.cell-output .cell-output-display execution_count=8}\n```\n4.0\n```\n:::\n:::\n\n\nOnce created, there is no difference among `foo`, `foo2`, `foo3` and `foo4`.\n\nAnonymous functions are useful when passing a function to another function as argument. For example, the function `bar` below allows applying any function `f` to an argument `x`. In this case we could pass any of the variables defined above, or just create an anonymous funcion in-place.\n\n::: {.cell execution_count=8}\n``` {.julia .cell-code}\nfunction bar(x, f)\n    f(x)\nend\nbar(2.0, x -> x^2)\n```\n\n::: {.cell-output .cell-output-display execution_count=9}\n```\n4.0\n```\n:::\n:::\n\n\n## Types\n\nA Type in Julia is a data structure that can contain one or more fields. Types are used to keep related data together, and to select the right method implementation of a function (see below). It shares some of the properties of Classes in Object-Oriented Programming but there are also important differences.\n\nJulia types can be immutable or mutable.\n\nImmutable means that, once created, the fields of an object cannot be changed. They are defined with the following syntax:\n\n::: {.cell execution_count=9}\n``` {.julia .cell-code}\nstruct Point\n  x\n  y\n  z\nend\n```\n:::\n\n\n::: {.cell execution_count=10}\n``` {.julia .cell-code}\np = Point(0.0, 0.0, 0.0)\n```\n\n::: {.cell-output .cell-output-display execution_count=11}\n```\nPoint(0.0, 0.0, 0.0)\n```\n:::\n:::\n\n\n::: {.cell execution_count=11}\n``` {.julia .cell-code}\np.x = 1.0\n```\n\n::: {.cell-output .cell-output-error}\n```\nLoadError: setfield!: immutable struct of type Point cannot be changed\n```\n:::\n:::\n\n\nMutable means that the fields of an object can be modified after creation. The definition is similar, just needs to add the keyword `mutable`\n\n::: {.cell execution_count=12}\n``` {.julia .cell-code}\nmutable struct mPoint\n  x\n  y\n  z\nend\n```\n:::\n\n\n::: {.cell execution_count=13}\n``` {.julia .cell-code}\nmp = mPoint(0.0, 0.0, 0.0)\n```\n\n::: {.cell-output .cell-output-display execution_count=14}\n```\nmPoint(0.0, 0.0, 0.0)\n```\n:::\n:::\n\n\n::: {.cell execution_count=14}\n``` {.julia .cell-code}\nmp.x = 1.0\nmp\n```\n\n::: {.cell-output .cell-output-display execution_count=15}\n```\nmPoint(1.0, 0.0, 0.0)\n```\n:::\n:::\n\n\nWe can always check the type of an object with the function `typeof`\n\n::: {.cell execution_count=15}\n``` {.julia .cell-code}\ntypeof(p)\n```\n\n::: {.cell-output .cell-output-display execution_count=16}\n```\nPoint\n```\n:::\n:::\n\n\nIf you forget the fields of a type, try to using `fieldnames` in the type (not the object). It will return the name of all the fields it contains (the \":\" in front of each name can be ignored)\n\n::: {.cell execution_count=16}\n``` {.julia .cell-code}\nfieldnames(Point)\n```\n\n::: {.cell-output .cell-output-display execution_count=17}\n```\n(:x, :y, :z)\n```\n:::\n:::\n\n\nNote that, for performance reasons, the type of each field should be annotated in the type definition as in:\n\n::: {.cell execution_count=17}\n``` {.julia .cell-code}\nstruct pPoint\n  x::Float64\n  y::Float64\n  z::Float64\nend\npPoint(1.0, 2.0, 3.0)\n```\n\n::: {.cell-output .cell-output-display execution_count=18}\n```\npPoint(1.0, 2.0, 3.0)\n```\n:::\n:::\n\n\nAlso, note that there are no private fields in a Julia type (like Python, unlike C++ or Java).\n\n## Methods\n\nMethods are functions with the same name but specialized for different types. \n\nMethods are automatically created by specifying the type of (some of) the arguments of a function, like in the following example\n\n::: {.cell execution_count=18}\n``` {.julia .cell-code}\nfunction dist(p1::pPoint, p2::pPoint)\n    dx = p1.x - p2.x\n    dy = p1.y - p2.y\n    dz = p1.z - p2.z\n    sqrt(dx^2 + dy^2 + dz^2)\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=19}\n```\ndist (generic function with 1 method)\n```\n:::\n:::\n\n\n::: {.cell execution_count=19}\n``` {.julia .cell-code}\np1 = pPoint(1.0, 0.0, 0.0)\np2 = pPoint(0.0, 1.0, 0.0)\ndist(p1, p2)\n```\n\n::: {.cell-output .cell-output-display execution_count=20}\n```\n1.4142135623730951\n```\n:::\n:::\n\n\nNote that this function will not work for `mPoint`s\n\n::: {.cell execution_count=20}\n``` {.julia .cell-code}\nmp1 = mPoint(1.0, 0.0, 0.0)\nmp2 = mPoint(0.0, 1.0, 0.0)\ndist(mp1, mp2)\n```\n\n::: {.cell-output .cell-output-error}\n```\nLoadError: MethodError: no method matching dist(::mPoint, ::mPoint)\n```\n:::\n:::\n\n\nSo we need to define `dist` for `mPoint` as arguments, or use inheritance (see below).\n\n## Abstract types\n\nTypes cannot inherit from other types.\n\nHowever, when multiple types share analogus functionality, it is possible to group them by \"abstract types\" from which they can inherit. Note that abstract types do not contain any fields, so inheritance only works for methods. \"abstract types are defined by how they act\" (C. Rackauckas)\n\nFor example, we may define an abstract type `Vec3` defined as any type for which a distance (`dist`) can be calculated. The default implementation assumes that the type contains fields `x`, `y` and `z`, though inherited methods can always be overriden.\n\nInheritance is indicated by the \"<:\" syntax after the name of the type in its declaration.\n\n::: {.cell execution_count=21}\n``` {.julia .cell-code}\n# Vec3 contains no data, but dist actually assumes that x, y and z are fields of any type inheriting from Vec3\nabstract type Vec3 end\nfunction dist(p1::Vec3, p2::Vec3)\n    dx = p1.x - p2.x\n    dy = p1.y - p2.y\n    dz = p1.z - p2.z\n    sqrt(dx^2 + dy^2 + dz^2)\nend\n# Like before, but inhering from Vec3\nstruct Point2 <: Vec3\n  x::Float64\n  y::Float64\n  z::Float64\nend\nmutable struct mPoint2 <: Vec3\n  x::Float64\n  y::Float64\n  z::Float64\nend\nstruct Point3 <: Vec3\n  x::Float64\n  y::Float64\nend\n```\n:::\n\n\nThe method now works with `Point2` and `mPoint2`\n\n::: {.cell execution_count=22}\n``` {.julia .cell-code}\np1 = Point2(1.0, 0.0, 0.0)\np2 = Point2(0.0, 1.0, 0.0)\ndist(p1, p2)\nmp1 = mPoint2(1.0, 0.0, 0.0)\nmp2 = mPoint2(0.0, 1.0, 0.0)\ndist(mp1, mp2)\n```\n\n::: {.cell-output .cell-output-display execution_count=23}\n```\n1.4142135623730951\n```\n:::\n:::\n\n\nThe method will try to run with `Point3` but it will raise an error because \n`Point3` does not have the field `z`. \n\n::: {.cell execution_count=23}\n``` {.julia .cell-code}\np3 = Point3(1.0, 0.0)\ndist(p1, p3)\n```\n\n::: {.cell-output .cell-output-error}\n```\nLoadError: type Point3 has no field z\n```\n:::\n:::\n\n\n### Optional and keyword arguments\n\nFunctions can have optional arguments (i.e. arguments with default values) as well as keyword arguments, which are like optional arguments but you need to use their name (rather than position) to assign a value.\n\nAn example of a function with optional arguments:\n\n::: {.cell execution_count=24}\n``` {.julia .cell-code}\nopfoo(a, b::Int = 0) = a + b\nopfoo(1)\n```\n\n::: {.cell-output .cell-output-display execution_count=25}\n```\n1\n```\n:::\n:::\n\n\n::: {.cell execution_count=25}\n``` {.julia .cell-code}\nopfoo(1,1)\n```\n\n::: {.cell-output .cell-output-display execution_count=26}\n```\n2\n```\n:::\n:::\n\n\nAn example of a function with keyword arguments\n\n::: {.cell execution_count=26}\n``` {.julia .cell-code}\nkwfoo(a; b::Int = 0) = a + b\nkwfoo(1)\n```\n\n::: {.cell-output .cell-output-display execution_count=27}\n```\n1\n```\n:::\n:::\n\n\n::: {.cell execution_count=27}\n``` {.julia .cell-code}\nkwfoo(1, b = 1)\n```\n\n::: {.cell-output .cell-output-display execution_count=28}\n```\n2\n```\n:::\n:::\n\n\n## Modules\n\nWithin a Julia session you cannot redefine Types. Also, if you assign different data to the same name, it will simply overwrite the previous data (note: these statements are simplifications of what it actually happens, but it suffices for now).\n\nTo avoid name clashes, Julia allows collecting functions, methods, types and abstract types into Modules. Every Julia package includes at least one module.\n\nA module allows exporting a subset of the the names defined inside of it:\n\n::: {.cell execution_count=28}\n``` {.julia .cell-code}\nmodule Mod\n\nexport fooz\n\nfooz(x) = abs(x)\n\nstruct bar\n   data\nend\n\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=29}\n```\nMain.Mod\n```\n:::\n:::\n\n\nIn order to use a module the `using` command must be used (the `.` is required and\nindicates that the module was defined in the current scoppe, as modules can be\nnested).\n\n::: {.cell execution_count=29}\n``` {.julia .cell-code}\nusing .Mod\n```\n:::\n\n\nExportednames can be used directly\n\n::: {.cell execution_count=30}\n``` {.julia .cell-code}\nfooz(-1)\n```\n\n::: {.cell-output .cell-output-display execution_count=31}\n```\n1\n```\n:::\n:::\n\n\nUnexported names can still be retrieved, but must be qualified by the module name.\n\n::: {.cell execution_count=31}\n``` {.julia .cell-code}\nb = Mod.fooz(-1.0)\n```\n\n::: {.cell-output .cell-output-display execution_count=32}\n```\n1.0\n```\n:::\n:::\n\n\n## Adding methods to existing functions\n\nIf a function is defined inside a module (e.g., a Julia package) we can add\nmethods to that function by accessing it through the module name. Let's define a\nfunction `abs_dist` that calculates the Manhattan (as opposed to Euclidean) \ndistance between two points. We will put it inside a module called `Funs` to \nemulate a Julia package.\n\n::: {.cell execution_count=32}\n``` {.julia .cell-code}\nmodule Funs\n  export manhattan\n  function manhattan(p1, p2)\n      dx = p1.x - p2.x\n      dy = p1.y - p2.y\n      dz = p1.z - p2.z\n      abs(dx + dy + dz)\n  end\nend\nusing .Funs\nmanhattan(p1, p2)\nmanhattan(p1, p3)\n```\n\n::: {.cell-output .cell-output-error}\n```\nLoadError: type Point3 has no field z\n```\n:::\n:::\n\n\nWe see that we have the same error as before when using `p3`. Let's add methods\nfor when one the first or second argument is a `Point3` that ignores the `z`:\n\n::: {.cell execution_count=33}\n``` {.julia .cell-code}\nFuns.manhattan(p1::Point3, p2) = abs(p1.x - p2.x + p1.y - p2.y)\nFuns.manhattan(p1, p2::Point3) = abs(p1.x - p2.x + p1.y - p2.y)\nmanhattan(p1, p3)\nmanhattan(p3, p1)\n```\n\n::: {.cell-output .cell-output-display execution_count=34}\n```\n0.0\n```\n:::\n:::\n\n\nYou can find all the methods of a function by using `methods()` on the function\nname:\n\n::: {.cell execution_count=34}\n``` {.julia .cell-code}\nmethods(manhattan)\n```\n\n::: {.cell-output .cell-output-display execution_count=35}\n```{=html}\n# 3 methods for generic function <b>manhattan</b>:<ul><li> manhattan(p1::<b>Point3</b>, p2) in Main at In[34]:1</li> <li> manhattan(p1, p2::<b>Point3</b>) in Main at In[34]:2</li> <li> manhattan(p1, p2) in Main.Funs at In[33]:3</li> </ul>\n```\n:::\n:::\n\n\n## Macros\n\nA macro is a function or statement that starts with `@`. The details of macros are not explained here, but it is important to know that they work by **modifying the code** that you write inside the macro, usually to provided specific features or to achieve higher performance. That is, a macro will take the code that you write and substitute it by some new code that then gets executed.\n\nAn useful macro is `@kwdef` provided by the module `Base`, which allows assigning default values to the fields of a type and use the fields as keyword arguments in the constructors. This macro needs to be written before the type definition. For example, a point constructed in this manner would be:\n\n::: {.cell execution_count=35}\n``` {.julia .cell-code}\nBase.@kwdef struct kwPoint\n    x::Float64 = 0.0\n    y::Float64 = 0.0\n    z::Float64 = 0.0\nend\nkwPoint()\nkwPoint(1,1,1)\nkwPoint(y = 1)\n```\n\n::: {.cell-output .cell-output-display execution_count=36}\n```\nkwPoint(0.0, 1.0, 0.0)\n```\n:::\n:::\n\n\n## Dot notation\n\nDot notation is a very useful feature of Julia that allows you to apply a function \nto each element of a vector. For example, if you want to calculate the square of \neach element of a vector you can do:\n\n::: {.cell execution_count=36}\n``` {.julia .cell-code}\nx = [1,2,3]\ny = x.^2\n```\n\n::: {.cell-output .cell-output-display execution_count=37}\n```\n3-element Vector{Int64}:\n 1\n 4\n 9\n```\n:::\n:::\n\n\nThe dot notation can be used with any function, not just mathematical functions. \nFor example, if you want to calculate the absolute value of each element of a \nvector you can do:\n\n::: {.cell execution_count=37}\n``` {.julia .cell-code}\nabs.(y)\n```\n\n::: {.cell-output .cell-output-display execution_count=38}\n```\n3-element Vector{Int64}:\n 1\n 4\n 9\n```\n:::\n:::\n\n\nIf the operation is more complex, the '.' should be used in all the steps or, \nalternatively, use the macro `@.` that does the same:\n\n::: {.cell execution_count=38}\n``` {.julia .cell-code}\nabs.(y) .+ x.^3\n@. abs(y) + x^3\n```\n\n::: {.cell-output .cell-output-display execution_count=39}\n```\n3-element Vector{Int64}:\n  2\n 12\n 36\n```\n:::\n:::\n\n\nThe dot notation can also be used with functions that take more than one argument,\nbut make sure that all the arguments have the same length\n\n::: {.cell execution_count=39}\n``` {.julia .cell-code}\nmin.(x, y)\nmax.(x, y)\n```\n\n::: {.cell-output .cell-output-display execution_count=40}\n```\n3-element Vector{Int64}:\n 1\n 4\n 9\n```\n:::\n:::\n\n\n# Improving performance\n\n## Type instability\n\nAs indicated above, annotating the fields of a data type (`struct` or `mutable struct`) is\nrequired for achieve good performance. However, neither arguments of functions nor variables\ncreated through assignment require type annotation. This is because Julia uses\ntype inference (i.e. it tries to infer the type of data to be stored in each newly\ncreated varaible) and compiles the code to machine level based on this inference.\nThis leads to the concept of *type instability*: if the type of data stored in a variable\nchanges over time, the compiler will need to accomodate for this, which results\n(for technical reasons beyond the scope of this document) in a loss of performance.\n\nHere is a classic example of type instability. The following function will add\nup the squares of all the values in a vector:\n\n::: {.cell execution_count=40}\n``` {.julia .cell-code}\nfunction add_squares(x)\n  out = 0\n  for i in eachindex(x)\n    out += x[i]^2\n  end\n  return out\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=41}\n```\nadd_squares (generic function with 1 method)\n```\n:::\n:::\n\n\nIt looks innocent enough. The issue here is that `out` is initialized as an integer\n(`0`), but then it is assigned the result of `sqrt(x)`, which may be a real value (e.g. `1.0`),\nwhich would have to be stored as a floating point number. Because `out` has different\ntypes at different points in the code, the resulting code will be slower than it could be,\nbut still correct (this is why Julia is useful for rapid code development compared\nto static languages like C++ or Java).\n\n::: {.cell execution_count=41}\n``` {.julia .cell-code}\nadd_squares(collect(1:1000)) # type stable\nadd_squares(collect(1:1000.0)) # not type stable\n```\n\n::: {.cell-output .cell-output-display execution_count=42}\n```\n3.338335e8\n```\n:::\n:::\n\n\nHow do we measure performance then? The `@time` macro is useful for this if \ndealing with a slow function. Otherwise it is better to use `@btime` from the\n*BenchmarkTools* package (see documentation of the package to understand why\nwe use `$`).\n\n::: {.cell execution_count=42}\n``` {.julia .cell-code}\nusing BenchmarkTools\nv1 = collect(1:1000)\nv2 = collect(1:1000.0)\n@btime add_squares($v1)\n@btime add_squares($v2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  136.448 ns (0 allocations: 0 bytes)\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n  1.650 μs (0 allocations: 0 bytes)\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=43}\n```\n3.338335e8\n```\n:::\n:::\n\n\nThe second code is 12 times slower than the first one. We can detect type instability\nby using the `@code_warntype` macro. This macro will print a internal representation\nof the code before it is compiled. The details are complex, but you just need to \nlook for things in red (which indicate type instability).\n\n::: {.cell execution_count=43}\n``` {.julia .cell-code}\n@code_warntype add_squares(v1)\n@code_warntype add_squares(v2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nMethodInstance for add_squares(::\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nVector{Int64})\n  from add_squares(x) in Main at In[41]:1\nArguments\n  #self#::Core.Const(add_squares)\n  x::Vector{Int64}\nLocals\n  @_3::Union{Nothing, Tuple{Int64, Int64}}\n  out::Int64\n  i::Int64\nBody::Int64\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n\n1 ─ \n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n      (out = 0)\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n\n│   %2  = Main.eachindex(x)::Base.OneTo{Int64}\n│         (@_3 = Base.iterate(%2))\n│   %4  = (@_3 === nothing)::Bool\n│   %5  = Base.not_int(%4)::Bool\n└──       goto #4 if not %5\n2 ┄ %7  = @_3::Tuple{Int64, Int64}\n│         (i = Core.getfield(%7, 1))\n│   %9  = Core.getfield(%7, 2)::Int64\n│   %10 = out::Int64\n│   %11 = Base.getindex(x, i)::Int64\n│   %12 = Core.apply_type(Base.Val, 2)::Core.Const(Val{2})\n│   %13 = (%12)()::Core.Const(Val{2}())\n│   %14 = Base.literal_pow(Main.:^, %11, %13)::Int64\n│         (out = %10 + %14)\n│         (@_3 = Base.iterate(%2, %9))\n│   %17 = (@_3 === nothing)::Bool\n│   %18 = Base.not_int(%17)::Bool\n└──       goto #4 if not %18\n3 ─       \n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\ngoto #2\n4 ┄       return out\n\nMethodInstance for add_squares(::Vector{Float64})\n  from add_squares(x) in Main at In[41]:1\nArguments\n  #self#::Core.Const(add_squares)\n  x::Vector{Float64}\nLocals\n  @_3::Union{Nothing, Tuple{Int64, Int64}}\n  out::Union{Float64, Int64}\n  i::Int64\nBody::Union{Float64, Int64}\n1 ─       (out = 0)\n│   %2  = Main.eachindex(x)::Base.OneTo{Int64}\n│         (@_3 = Base.iterate(%2))\n│   %4  = (@_3 === nothing)::Bool\n│   %5  = Base.not_int(%4)::Bool\n└──       goto #4 if not %5\n2 ┄ %7  = @_3::Tuple{Int64, Int64}\n│         (i = Core.getfield(%7, 1))\n│   %9  = Core.getfield(%7, 2)::Int64\n│   %10 = out::Union{Float64, Int64}\n│   %11 = Base.getindex(x, i)::Float64\n│   %12 = Core.apply_type(Base.Val, 2)::Core.Const(Val{2})\n│   %13 = (%12)()::Core.Const(Val{2}())\n│   %14 = Base.literal_pow(Main.:^, %11, %13)::Float64\n│         (out = %10 + %14)\n│         (@_3 = Base.iterate(%2, %9))\n│   %17 = (@_3 === \n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nnothing)::Bool\n│   %18 = Base.not_int(%17)::Bool\n└──       goto #4 if not %18\n3 ─       goto #2\n4 ┄       return out\n\n```\n:::\n:::\n\n\nHow do we fix this? We could write different methods for different types of x,\nbut this is not very practical. Instead, we can use the `zero()` function combined\nwith `eltype()` to initialize `out` with the correct type.\n\n::: {.cell execution_count=44}\n``` {.julia .cell-code}\nfunction add_squares(x)\n  out = zero(eltype(x)) # Initialize out with the correct type with value of zero\n  for i in eachindex(x)\n    out += x[i]^2\n  end\n  return out\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=45}\n```\nadd_squares (generic function with 1 method)\n```\n:::\n:::\n\n\nYou could also initialize out to the first element of x and iterate over the rest\nof the elements, but this may not always possible (e.g. if `x` is empty or has \none value only), so the logic will get more complex.\n\nNow the code is type stable:\n\n::: {.cell execution_count=45}\n``` {.julia .cell-code}\n@code_warntype add_squares(v1)\n@code_warntype add_squares(v2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nMethodInstance for add_squares(::Vector{Int64})\n  from add_squares(x) in Main at In[45]:1\nArguments\n  #self#::Core.Const(add_squares)\n  x::Vector{Int64}\nLocals\n  @_3::Union{Nothing, Tuple{Int64, Int64}}\n  out::Int64\n  i::Int64\nBody::Int64\n1 ─ %1  = Main.eltype(x)::Core.Const(Int64)\n│         (out = Main.zero(%1))\n│   %3  = Main.eachindex(x)::Base.OneTo{Int64}\n│         (@_3 = Base.iterate(%3))\n│   %5  = (@_3 === nothing)::Bool\n│   %6  = Base.not_int(%5)::Bool\n└──       goto #4 if not %6\n2 ┄ %8  = @_3::Tuple{Int64, Int64}\n│         (i = Core.getfield(%8, 1))\n│   %10 = Core.getfield(%8, 2)::Int64\n│   %11 = out::Int64\n│   %12 = Base.getindex(x, i)::Int64\n│   %13 = Core.apply_type(Base.Val, 2)::Core.Const(Val{2})\n│   %14 = (%13)()::Core.Const(Val{2}())\n│   %15 = Base.literal_pow(Main.:^, %12, %14)::Int64\n│         (out = %11 + %15)\n│         (@_3 = Base.iterate(%3, %10))\n│   %18 = (@_3 === nothing)::Bool\n│   %19 = Base.not_int(%18)::Bool\n└──       goto #4 if not %19\n3 ─       goto #2\n4 ┄       return out\n\nMethodInstance for add_squares(::Vector{Float64})\n  from add_squares(x) in Main at In[45]:1\nArguments\n  #self#::Core.Const(add_squares)\n  x::Vector{Float64}\nLocals\n  @_3::Union{Nothing, Tuple{Int64, Int64}}\n  out::Float64\n  i::Int64\nBody::Float64\n1 ─ %1  = Main.eltype(x)::Core.Const(Float64)\n│         (out = Main.zero(%1))\n│   %3  = Main.eachindex(x)::Base.OneTo{Int64}\n│         (@_3 = Base.iterate(%3))\n│   %5  = (@_3 === nothing)::Bool\n│   %6  = Base.not_int(%5)::Bool\n└──       goto #4 if not %6\n2 ┄ %8  = @_3::Tuple{Int64, Int64}\n│         (i = Core.getfield(%8, 1))\n│   %10 = Core.getfield(%8, 2)::Int64\n│   %11 = out::Float64\n│   %12 = Base.getindex(x, i)::Float64\n│   %13 = Core.apply_type(Base.Val, 2)::Core.Const(Val{2})\n│   %14 = (%13)()::Core.Const(Val{2}())\n│   %15 = Base.literal_pow(Main.:^, %12, %14)::Float64\n│         (out = %11 + %15)\n│         (@_3 = Base.iterate(%3, %10))\n│   %18 = (@_3 === nothing)::Bool\n│   %19 = Base.not_int(%18)::Bool\n└──       goto #4 if not %19\n3 ─       goto #2\n4 ┄       return out\n\n```\n:::\n:::\n\n\nAnd the performance is more similar:\n\n::: {.cell execution_count=46}\n``` {.julia .cell-code}\n@btime add_squares($v1)\n@btime add_squares($v2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  136.541 ns (0 allocations: 0 bytes)\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n  812.644 ns (0 allocations: 0 bytes)\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=47}\n```\n3.338335e8\n```\n:::\n:::\n\n\n## Performance annotations\n\nSometimes code can be annotated to improve performance. For example, the `@simd`\ncan be used in simple loops to indicate that the loop can be vectorized inside \nthe CPU (it allows to run simple CPU instructions on small sets of data simultaneously). The\n`@inbounds` macro can be used to indicate that the code will not access elements\noutside the bounds of an array.\n\n::: {.cell execution_count=47}\n``` {.julia .cell-code}\nfunction add_squares(x)\n  out = zero(eltype(x)) # Initialize out with the correct type with value of zero\n  @simd for i in eachindex(x)\n    @inbounds out += x[i]^2\n  end\n  return out\nend\n@btime add_squares($v1)\n@btime add_squares($v2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  135.771 ns (0 allocations: 0 bytes)\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n  54.619 ns (0 allocations: 0 bytes)\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=48}\n```\n3.338335e8\n```\n:::\n:::\n\n\nNow we actually get faster performance for floating point number, which is related\nto the fact that the CPU can vectorize floating point operations more efficiently\nthan integer operations (at least in this example). You can see the actual assembly\ncode being generated (or an approximation of it) by using the `@code_native` macro.\nAny instruction that starts with `v` is a vectorized instruction. Note that\nsometimes Julia will automatically vectorize code without the need for the `@simd`\nbut this is not always the case.\n\n::: {.cell execution_count=48}\n``` {.julia .cell-code}\n@code_native add_squares(v2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\t.text\n\t.file\t\"add_squares\"\n\t\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n.globl\tjulia_add_squares_3992          # -- Begin function julia_add_squares_3992\n\t.p2align\t4, 0x90\n\t.type\tjulia_add_squares_3992,@function\njulia_add_squares_3992:                 # @julia_add_squares_3992\n; ┌ @ In[48]:1 within `add_squares`\n\t.cfi_startproc\n# %bb.0:                                # %top\n\tpushq\t%rbp\n\t.cfi_def_cfa_offset 16\n\t\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n.cfi_offset %rbp, -16\n\tmovq\t%rsp, %rbp\n\t.cfi_def_cfa_register %rbp\n\tsubq\t$32, %rsp\n\tvmovapd\t%xmm7, -16(%rbp)                # 16-byte Spill\n\tvmovapd\t%xmm6, -32(%rbp)                # 16-byte Spill\n; │ @ In[48]:3 within `add_squares`\n; │┌ @ simdloop.jl:69 within `macro expansion`\n; ││┌ @ abstractarray.jl:285 within `eachindex`\n; │││┌ @ abstractarray.jl:116 within `axes1`\n; ││││┌ @ abstractarray.jl:95 within `axes`\n; │││││┌ @ array.jl:151 within `size`\n\tmovq\t8(%rcx), %r8\n; ││└└└└\n; ││ @ simdloop.jl:72 within `macro expansion`\n; ││┌ @ int.jl:83 within `<`\n\ttestq\t%r8, %r8\n; ││└\n\tje\t.LBB0_1\n# %bb.2:                                # %L14.lr.ph\n\tmovq\t(%rcx), %rcx\n; ││ @ simdloop.jl:75 within `macro expansion`\n\tcmpq\t$16, %r8\n\tjae\t.LBB0_4\n# %bb.3:\n\t\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nvxorpd\t%xmm0, %xmm0, %xmm0\n\txorl\t%edx, %edx\n\tjmp\t.LBB0_7\n.LBB0_1:\n\tvxorpd\t%xmm0, %xmm0, %xmm0\n\tjmp\t.LBB0_8\n.LBB0_4:                                # %vector.ph\n\tmovq\t%r8, %rdx\n\tandq\t$-16, %rdx\n\t\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nvxorpd\t%xmm0, %xmm0, %xmm0\n\txorl\t%eax, %eax\n\tvxorpd\t%xmm1, %xmm1, %xmm1\n\tvxorpd\t%xmm2, %xmm2, %xmm2\n\tvxorpd\t%xmm3, %xmm3, %xmm3\n\t.p2align\t4, 0x90\n.LBB0_5:                                # %vector.body\n                                        # =>This Inner Loop Header: Depth=1\n; ││ @ simdloop.jl:77 within `macro expansion` @ In[48]:4\n; ││┌ @ array.jl:924 within `getindex`\n\tvmovupd\t(%rcx,%rax,8), %ymm4\n\tvmovupd\t32(%rcx,%rax,8), %ymm5\n\tvmovupd\t64(%rcx,%rax,8), %ymm6\n\tvmovupd\t96(%rcx,%rax,8), %ymm7\n; ││└\n; ││┌ @ float.jl:383 within `+`\n\tvfmadd231pd\t%ymm4, %ymm4, %ymm0     # ymm0 = (ymm4 * ymm4) + ymm0\n\tvfmadd231pd\t%ymm5, %ymm5, %ymm1     # ymm1 = (ymm5 * ymm5) + ymm1\n\tvfmadd231pd\t%ymm6, %ymm6, %ymm2     # ymm2 = (ymm6 * ymm6) + ymm2\n\tvfmadd231pd\t%ymm7, %ymm7, %ymm3     # ymm3 = (ymm7 * ymm7) + ymm3\n; ││└\n; ││ @ simdloop.jl:78 within `macro expansion`\n; ││┌ @ int.jl:87 within `+`\n\t\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\naddq\t$16, %rax\n\tcmpq\t%rax, %rdx\n\tjne\t.LBB0_5\n# %bb.6:                                # %middle.block\n; ││└\n; ││ @ simdloop.jl:75 within `macro expansion`\n\tvaddpd\t%ymm0, %ymm1, %ymm0\n\tvaddpd\t%ymm0, %ymm2, %ymm0\n\tvaddpd\t%ymm0, %ymm3, %ymm0\n\tvextractf128\t$1, %ymm0, %xmm1\n\tvaddpd\t%xmm1, %xmm0, %xmm0\n\tvpermilpd\t$1, %xmm0, %xmm1        # xmm1 = xmm0[1,0]\n\tvaddsd\t%xmm1, %xmm0, %xmm0\n\tcmpq\t%rdx, %r8\n\tje\t.LBB0_8\n\t.p2align\t4, 0x90\n.LBB0_7:                                # %L14\n                                        # =>This Inner Loop Header: Depth=1\n; ││ @ simdloop.jl:77 within `macro expansion` @ In[48]:4\n; ││┌ @ array.jl:924 within `getindex`\n\tvmovsd\t(%rcx,%rdx,8), %xmm1            # xmm1 = mem[0],zero\n; ││└\n; ││┌ @ float.jl:383 within `+`\n\tvfmadd231sd\t%xmm1, %xmm1, %xmm0     # xmm0 = (xmm1 * xmm1) + xmm0\n; ││└\n; ││ @ simdloop.jl:78 within `macro expansion`\n; ││┌ @ int.jl:87 within `+`\n\t\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nincq\t%rdx\n; ││└\n; ││ @ simdloop.jl:75 within `macro expansion`\n; ││┌ @ int.jl:83 within `<`\n\tcmpq\t%rdx, %r8\n; ││└\n\tjne\t.LBB0_7\n.LBB0_8:                                # %L32\n\tvmovaps\t-32(%rbp), %xmm6                # 16-byte Reload\n\tvmovaps\t-16(%rbp), %xmm7                # 16-byte Reload\n; │└\n; │ @ In[48]:6 within `add_squares`\n\taddq\t$32, %rsp\n\tpopq\t%rbp\n\tvzeroupper\n\tretq\n.Lfunc_end0:\n\t.size\tjulia_add_squares_3992\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n, .Lfunc_end0-julia_add_squares_3992\n\t.cfi_endproc\n; └\n                                        # -- End function\n\t.section\t\".note.GNU-stack\",\"\",@progbits\n```\n:::\n:::\n\n\nNotice how with some simple annotations and reorganizing the code to deal with\ntype instability we were able to get a 30x speedup. Obviously this was a simple\nfunction with minimal runtime, so the speedup is not particularly useful, but\nthis type of small functions are often the ones that are called many times in\ncomplex computations (e.g., ray tracing), so the speedup can be significant in\nactual applications. Whether you need to worry about performance depends on \nwhere the bottleneck is in your code.\n\nFor more details, see the sections of the manual on [profiling](https://docs.julialang.org/en/v1/manual/profile/) \nand [performance tips](https://docs.julialang.org/en/v1/manual/performance-tips/).\n\n## Global variables and type instability\n\nGlobal variables are any variable defined in a module outside of a function that is\naccessed from within a function. Global variables are not recommended in general\nas they can easily introduce bugs in your code by making the logic of the program\nmuch harder to reason about. However, they can also introduce performance issues \nas any global variable that is not annotated with its type will lead to type instability.\n\nFor example, let's say we modify the `add_squares` function to use a global variable\n(a bit odd, but it is just to illustrate the point) to enable differen options in\nthe code.\n\n::: {.cell execution_count=49}\n``` {.julia .cell-code}\nfunction add_squares(x)\n  out = zero(eltype(x))\n  if criterion > 0\n    @simd for i in eachindex(x)\n      @inbounds out += x[i]^2\n    end\n  else\n    @simd for i in eachindex(x)\n      @inbounds out -= x[i]^2\n    end\n  end\n  return out\nend\ncriterion = 1\n@code_warntype add_squares(v2)\n@btime add_squares(v2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nMethodInstance for add_squares(::Vector{Float64})\n  from add_squares(x) in Main at In[50]:1\nArguments\n  #self#::Core.Const(add_squares)\n  x::Vector{Float64}\nLocals\n  out::Float64\n  @_4::Union{Nothing, Tuple{Int64, Int64}}\n  r#370::Base.OneTo{Int64}\n  i#371::Int64\n  n#372::Int64\n  i#373::Int64\n  val@_9::Float64\n  i@_10::Int64\n  @_11::Union{Nothing, Tuple{Int64, Int64}}\n  r#374::Base.OneTo{Int64}\n  i#375::Int64\n  n#376::Int64\n  i#377::Int64\n  val@_16::Float64\n  i@_17::Int64\nBody::Float64\n1 ── %1  = Main.eltype(x)::Core.Const(Float64)\n│          (out = Main.zero(%1))\n│    %3  = (Main.criterion > 0)::Any\n└───       goto #10 if not %3\n2 ── %5  = Main.eachindex(x)::Base.OneTo{Int64}\n│          (r#370 = %5)\n│    %7  = Base.simd_outer_range::Core.Const(Base.SimdLoop.simd_outer_range)\n│    %8  = (%7)(r#370)::Core.Const(0:0)\n│          (@_4 = Base.iterate(%8))\n│    %10 = (\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n@_4\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n::Core.Const((0, 0)) === nothing)::Core.Const(false)\n│    %11 = Base.not_int(%10)::Core.Const(true)\n└───       goto #9 if not %11\n3 ── %13 = @_4::Core.Const((0, 0))\n│          (i#371 = Core.getfield(%13, 1))\n│    %15 = Core.getfield(%13, 2)::Core.Const(0)\n│    %16 = Base.simd_inner_length::Core.Const(Base.SimdLoop.simd_inner_length)\n│    %17 = r#370::Base.OneTo{Int64}\n│    %18 = (%16)(%17, i#371::Core.Const(0))::Int64\n│          (n#372 = %18)\n│    %20 = Main.zero(n#372)::Core.Const(0)\n│    %21 = (%20 < n#372)::Bool\n└───       goto #7 if not %21\n4 ── %23 = Main.zero(n#372)::Core.Const(0)\n└───       (i#373 = %23)\n5 ┄─ %25 = (i#373 < n#372)::Bool\n└───       goto #7 if not %25\n6 ── %27 = Base.simd_index::Core.Const(Base.SimdLoop.simd_index)\n│    %28 = r#370::Base.OneTo{Int64}\n│    %29 = i#371::Core.Const(0)\n│          (i@_10 = (%27)(%28, %29, i#373))\n│          nothing\n│    %32 = out::Float64\n│    %33 = Base.getindex(x, i@_10)::Float64\n│    %34 = Core.apply_type(Base.Val, 2)::Core.Const(Val{2})\n│    %35 = (%34)()::Core.Const(Val{2}())\n│    %36 = Base.literal_pow(Main.:^, %33, %35)::Float64\n│    %37 = (%32 + %36)::Float64\n│          (out = %37)\n│          (val@_9 = %37)\n│          nothing\n│          val@_9\n│          (i#373 = i#373 + 1)\n│          $(Expr(:loopinfo, Symbol(\"julia.simdloop\"), nothing))\n└───       goto #5\n7 ┄─       (@_4 = Base.iterate(%8, %15))\n│    %46 = (@_4::Core.Const(nothing) === nothing)::Core.Const(true)\n│    %47 = Base.not_int(%46)::Core.Const(false)\n└───       goto #9 if not %47\n8 ──       Core.Const(:(goto %13))\n9 ┄─       Main.nothing\n└───       goto #18\n10 ─ %\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n52 = Main.eachindex(x)::Base.OneTo{Int64}\n│          (r#374 = %52)\n│    %54 = Base.simd_outer_range::Core.Const(Base.SimdLoop.simd_outer_range)\n│    %55 = (%54)(r#374)::Core.Const(0:0)\n│          (@_11 = Base.iterate(%55))\n│    %57 = (@_11::Core.Const((0, 0)) === nothing)::Core.Const(false)\n│    %58 = Base.not_int(%57)::Core.Const(true)\n└───       goto #17 if not %58\n11 ─ %60 = @_11::Core.Const((0, 0))\n│          (i#375 = Core.getfield(%60, 1))\n│    %62 = Core.getfield(%60, 2)::Core.Const(0)\n│    %63 = Base.simd_inner_length::Core.Const(Base.SimdLoop.simd_inner_length)\n│    %64 = r#374::Base.OneTo{Int64}\n│    %65 = (%63)(%64, i#375::Core.Const(0))::Int64\n│          (n#376 = %65)\n│    %67 = Main.zero(n#376)::Core.Const(0)\n│    %68 = (%67 < n#376)::Bool\n└───       goto #15 if not %68\n12 ─ %70 = Main.zero(n#376)::Core.Const(0)\n└───       (i#377 = %70)\n13 ┄ %72 = (i#377 < n#376)::Bool\n└───       goto #15 if not %72\n14 ─ %74 = Base.simd_index::Core.Const(Base.SimdLoop.simd_index)\n│    %75 = r#374::Base.OneTo{Int64}\n│    %76 = i#375::Core.Const(0)\n│          (i@_17 = (%74)(%75, %76, i#377))\n│          nothing\n│    %79 = out::Float64\n│    %80 = Base.getindex(x, i@_17)::Float64\n│    %81 = Core.apply_type(Base.Val, 2)::Core.Const(Val{2})\n│    %82 = (%81)()::Core.Const(Val{2}())\n│    %83 = Base.literal_pow(Main.:^, %80, %82)::Float64\n│    %84 = (%79 - %83)::Float64\n│          (out = %84)\n│          (val@_16 = %84)\n│          nothing\n│          val@_16\n│          (i#377 = i#377 + 1)\n│          $(Expr(:loopinfo, Symbol(\"julia.simdloop\"), nothing))\n└───       goto #13\n15 ┄       (@_11 = Base.iterate(%55, %62))\n│    %93 = (@_11::Core.Const(nothing) === nothing)::Core.Const(true)\n│    %94 = Base.not_int(%93)::Core.Const(false)\n└───       goto #17 if not %94\n16 ─       Core.Const(:(goto %60))\n17 ┄       Main.nothing\n18 ┄       return out\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n\n  94.864 ns (1 allocation: 16 bytes)\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=50}\n```\n3.338335e8\n```\n:::\n:::\n\n\nIt is not a major hit in performance as `criterion` is only accessed once, but\nthis can be a problem if the global variable is accessed many times in the code.\nThe short term solution is to annotate the type of the global variable (but really\nwe should be writing code without global variables). This can be frustating as\nonce a global variable is created, you cannot annotate its type (even if it does\nnot change!) without restarting the Julia session (unless it is inside a module).\n\n::: {.cell execution_count=50}\n``` {.julia .cell-code}\nfunction add_squares(x)\n  out = zero(eltype(x))\n  if criterion2 > 0\n    @simd for i in eachindex(x)\n      @inbounds out += x[i]^2\n    end\n  else\n    @simd for i in eachindex(x)\n      @inbounds out -= x[i]^2\n    end\n  end\n  return out\nend\ncriterion2::Int64 = 1\n@code_warntype add_squares(v2)\n@btime add_squares(v2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nMethodInstance for add_squares(::Vector{Float64})\n  from add_squares(x) in Main at In[51]:1\nArguments\n  #self#::Core.Const(add_squares)\n  x::Vector{Float64}\nLocals\n  out::Float64\n  @_4::Union{Nothing, Tuple{Int64, Int64}}\n  r#385::Base.OneTo{Int64}\n  i#386::Int64\n  n#387::Int64\n  i#388::Int64\n  val@_9::Float64\n  i@_10::Int64\n  @_11::Union{Nothing, Tuple{Int64, Int64}}\n  r#389::Base.OneTo{Int64}\n  i#390::Int64\n  n#391::Int64\n  i#392::Int64\n  val@_16::Float64\n  i@_17::Int64\nBody::Float64\n1 ── %1  = Main.eltype(x)::Core.Const(Float64)\n│          (out = Main.zero(%1))\n│    %3  = (Main.criterion2 > 0)::Bool\n└───       goto #10 if not %3\n2 ── %5  = Main.eachindex(x)::Base.OneTo{Int64}\n│          (r#385 = %5)\n│    %7  = Base.simd_outer_range::Core.Const(Base.SimdLoop.simd_outer_range)\n│    %8  = (%7)(r#385)::Core.Const(0:0)\n│          (@_4 = Base.iterate(%8))\n│    %10 = (@_4::Core.Const((0, 0)) === nothing)::Core.Const(false)\n│    %11 = Base.not_int(%10)::Core.Const(true)\n└───       goto #9 if not %11\n3 ── %13 = @_4::Core.Const((0, 0))\n│          (i#386 = Core.getfield(%13, 1))\n│    %15 = Core.getfield(%13, 2)::Core.Const(0)\n│    %16 = Base.simd_inner_length::Core.Const(Base.SimdLoop.simd_inner_length)\n│    %17 = r#385::Base.OneTo{Int64}\n│    %18 = (%16)(%17, i#386::Core.Const(0))::Int64\n│          (n#387 = %18)\n│    %20 = Main.zero(n#387)::Core.Const(0)\n│    %21 = (%20 < n#387)::Bool\n└───       goto #7 if not %21\n4 ── %23 = Main.zero(n#387)::Core.Const(0)\n└───       (i#388 = %23)\n5 ┄─ %25 = (i#388 < n#387)::Bool\n└───       goto #7 if not %25\n6 ── %27 = Base.simd_index::Core.Const(Base.SimdLoop.simd_index)\n│    %28 = r#385::Base.OneTo{Int64}\n│    %29 = i#386::Core.Const(0)\n│          (i@_10 = (%27)(%28, %29, i#388))\n│          nothing\n│    %32 = out::Float64\n│    %33 = Base.getindex(x, i@_10)::Float64\n│    %34 = Core.apply_type(Base.Val, 2)::Core.Const(Val{2})\n│    %35 = (%34)()::Core.Const(Val{2}())\n│    %36 = Base.literal_pow(Main.:^, %33, %35)::Float64\n│    %37 = (%32 + %36)::Float64\n│          (out = %37)\n│          (val@_9 = %37)\n│          nothing\n│          val@_9\n│          (i#388 = i#388 + 1)\n│          $(Expr(:loopinfo, Symbol(\"julia.simdloop\"), nothing))\n└───       goto #5\n7 ┄─       (@_4 = Base.iterate(%8, %15))\n│    %46 = (@_4::Core.Const(nothing) === nothing)::Core.Const(true)\n│    %47 = Base.not_int(%46)::Core.Const(false)\n└───       goto #9 if not %47\n8 ──       Core.Const(:(goto %13))\n9 ┄─       Main.nothing\n└───       goto #18\n10 ─ %52 = Main.eachindex(x)::Base.OneTo{Int64}\n│          (r#389 = %52)\n│    %54 = Base.simd_outer_range::Core.Const(Base.SimdLoop.simd_outer_range)\n│    %55 = (%54)(r#389)::Core.Const(0:0)\n│          (@_11 = Base.iterate(%55))\n│    %57 = (@_11::Core.Const((0, 0)) === nothing)::Core.Const(false)\n│    %58 = Base.not_int(%57)::Core.Const(true)\n└───       goto #17 if not %58\n11 ─ %60 = @_11::Core.Const((0, 0))\n│          (i#390 = Core.getfield(%60, 1))\n│    %62 = Core.getfield(%60, 2)::Core.Const(0)\n│    %63 = Base.simd_inner_length::Core.Const(Base.SimdLoop.simd_inner_length)\n│    %64 = r#389::Base.OneTo{Int64}\n│    %65 = (%63)(%64, i#390::Core.Const(0))::Int64\n│          (n#391 = %65)\n│    %67 = Main.zero(n#391)::Core.Const(0)\n│    %68 = (%67 < n#391)::Bool\n└───       goto #15 if not %68\n12 ─ %70 = Main.zero(n#391)::Core.Const(0)\n└───       (i#392 = %70)\n13 ┄ %72 = (i#392 < n#391)::Bool\n└───       goto #15 if not %72\n14 ─ %74 = Base.simd_index::Core.Const(Base.SimdLoop.simd_index)\n│    %75 = r#389::Base.OneTo{Int64}\n│    %76 = i#390::Core.Const(0)\n│          (i@_17 = (%74)(%75, %76, i#392))\n│          nothing\n│    %79 = out::Float64\n│    %80 = Base.getindex(x, i@_17)::Float64\n│    %81 = Core.apply_type(Base.Val, 2)::Core.Const(Val{2})\n│    %82 = (%81)()::Core.Const(Val{2}())\n│    %83 = Base.literal_pow(Main.:^, %80, %82)::Float64\n│    %84 = (%79 - %83)::Float64\n│          (out = %84)\n│          (val@_16 = %84)\n│          nothing\n│          val@_16\n│          (i#392 = i#392 + 1)\n│          $(Expr(:loopinfo, Symbol(\"julia.simdloop\"), nothing))\n└───       goto #13\n15 ┄       (@_11 = Base.iterate(%55, %62))\n│    %93 = (@_11::Core.Const(nothing) === nothing)::Core.Const(true)\n│    %94 = Base.not_int(%93)::Core.Const(false)\n└───       goto #17 if not %94\n16 ─       Core.Const(:(goto %60))\n17 ┄       Main.nothing\n18 ┄       return out\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n\n  79.072 ns (1 allocation: 16 bytes)\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=51}\n```\n3.338335e8\n```\n:::\n:::\n\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {
      "include-in-header": [
        "<script src=\"https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js\" integrity=\"sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==\" crossorigin=\"anonymous\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js\" integrity=\"sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==\" crossorigin=\"anonymous\"></script>\n<script type=\"application/javascript\">define('jquery', [],function() {return window.jQuery;})</script>\n"
      ]
    }
  }
}