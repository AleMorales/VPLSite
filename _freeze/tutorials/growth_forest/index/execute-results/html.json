{
  "hash": "8fff7642b730c4524a95a9d2a0fc8ad6",
  "result": {
    "markdown": "---\ntitle: \"Growth forest\"\nauthor: \n    - name: \"Alejandro Morales Sierra\"\n      affiliation: \"Centre for Crop Systems Analysis - Wageningen University\"\ndate: last-modified\nexecute: \n  cache: true\n---\n\nIn this example we extend the forest example to have more complex, time-\ndepedent development and growth based on carbon allocation. For simplicity, the\nmodel assumes a constant relative growth rate at the plant level to compute the\nbiomass increment. In the next example this assumption is relaxed by a model of\nradiation use efficiency. When modelling growth from carbon allocation, the \nbiomass of each organ is then translated in to an area or volume and the\ndimensions of the organs are updated accordingly (assuming a particular shape). \n\nThe following packages are needed:\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nusing VPL\nusing Base.Threads: @threads\nusing Plots\nimport Random\nusing FastGaussQuadrature\nusing Distributions\nRandom.seed!(123456789)\n```\n\n::: {.cell-output .cell-output-display execution_count=2}\n```\nRandom.TaskLocalRNG()\n```\n:::\n:::\n\n\n## Model definition\n\n### Node types\n\nThe data types needed to simulate the trees are given in the following\nmodule. The differences with respect to the previous example are:\n\n    - Meristems do not produce phytomers every day\n    - A relative sink strength approach is used to allocate biomass to organs\n    - The geometry of the organs is updated based on the new biomass\n    - Bud break probability is a function of distance to apical meristem\n\n::: {.cell execution_count=2}\n``` {.julia .cell-code}\n# Data types\nmodule TreeTypes\n    using VPL\n    using Distributions\n    # Meristem\n    Base.@kwdef mutable struct Meristem <: VPL.Node \n        age::Int64 = 0   # Age of the meristem\n    end\n    # Bud\n    struct Bud <: VPL.Node end\n    # Node\n    struct Node <: VPL.Node end\n    # BudNode\n    struct BudNode <: VPL.Node end\n    # Internode (needs to be mutable to allow for changes over time)\n    Base.@kwdef mutable struct Internode <: VPL.Node\n        age::Int64 = 0         # Age of the internode\n        biomass::Float64 = 0.0 # Initial biomass\n        length::Float64 = 0.0  # Internodes\n        width::Float64  = 0.0  # Internodes\n        sink::Exponential{Float64} = Exponential(5)\n    end\n    # Leaf\n    Base.@kwdef mutable struct Leaf <: VPL.Node\n        age::Int64 = 0         # Age of the leaf\n        biomass::Float64 = 0.0 # Initial biomass\n        length::Float64 = 0.0  # Leaves\n        width::Float64 = 0.0   # Leaves\n        sink::Beta{Float64} = Beta(2,5)\n    end    \n    # Graph-level variables -> mutable because we need to modify them during growth\n    Base.@kwdef mutable struct treeparams\n        # Variables\n        biomass::Float64 = 2e-3 # Current total biomass (g)\n        # Parameters\n        RGR::Float64 = 1.0   # Relative growth rate (1/d)\n        IB0::Float64 = 1e-3  # Initial biomass of an internode (g)\n        SIW::Float64 = 0.1e6   # Specific internode weight (g/m3)\n        IS::Float64  = 15.0  # Internode shape parameter (length/width)\n        LB0::Float64 = 1e-3  # Initial biomass of a leaf\n        SLW::Float64 = 100.0 # Specific leaf weight (g/m2)\n        LS::Float64  = 3.0   # Leaf shape parameter (length/width)\n        budbreak::Float64 = 1/0.5 # Bud break probability coefficient (in 1/m) \n        plastochron::Int64 = 5 # Number of days between phytomer production \n        leaf_expansion::Float64 = 15.0 # Number of days that a leaf expands\n        phyllotaxis::Float64 = 140.0\n        leaf_angle::Float64 = 30.0\n        branch_angle::Float64 = 45.0\n    end\nend\n\nimport .TreeTypes\n```\n:::\n\n\n### Geometry\n\nThe methods for creating the geometry and color of the tree are the same as in\nthe previous example.\n\n::: {.cell execution_count=3}\n``` {.julia .cell-code}\n# Create geometry + color for the internodes\nfunction VPL.feed!(turtle::Turtle, i::TreeTypes.Internode, vars)\n    # Rotate turtle around the head to implement elliptical phyllotaxis\n    rh!(turtle, vars.phyllotaxis) \n    HollowCylinder!(turtle, length = i.length, height = i.width, width = i.width, \n                move = true, color = RGB(0.5,0.4,0.0))\n    return nothing\nend\n\n# Create geometry + color for the leaves\nfunction VPL.feed!(turtle::Turtle, l::TreeTypes.Leaf, vars)\n    # Rotate turtle around the arm for insertion angle\n    ra!(turtle, -vars.leaf_angle)\n    # Generate the leaf \n    Ellipse!(turtle, length = l.length, width = l.width, move = false, \n             color = RGB(0.2,0.6,0.2))\n    # Rotate turtle back to original direction\n    ra!(turtle, vars.leaf_angle)\n    return nothing\nend\n\n# Insertion angle for the bud nodes\nfunction VPL.feed!(turtle::Turtle, b::TreeTypes.BudNode, vars)\n    # Rotate turtle around the arm for insertion angle\n    ra!(turtle, -vars.branch_angle)\nend\n```\n:::\n\n\n### Development\n\nThe meristem rule is now parameterized by the initial states of the leaves and\ninternodes and will only be triggered every X days where X is the plastochron.\n\n::: {.cell execution_count=4}\n``` {.julia .cell-code}\n# Create right side of the growth rule (parameterized by the initial states\n# of the leaves and internodes)\nfunction create_meristem_rule(vleaf, vint)\n    meristem_rule = Rule(TreeTypes.Meristem, \n                        lhs = mer -> mod(data(mer).age, vars(mer).plastochron) == 0,\n                        rhs = mer -> TreeTypes.Node() + \n                                     (TreeTypes.Bud(), \n                                     TreeTypes.Leaf(biomass = vleaf.biomass, \n                                                    length  = vleaf.length,\n                                                    width   = vleaf.width)) +\n                                     TreeTypes.Internode(biomass = vint.biomass, \n                                                         length  = vint.length,\n                                                         width   = vint.width) + \n                                     TreeTypes.Meristem())\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=5}\n```\ncreate_meristem_rule (generic function with 1 method)\n```\n:::\n:::\n\n\nThe bud break probability is now a function of distance to the apical meristem\nrather than the number of internodes. An adhoc traversal is used to compute this\nlength of the main branch a bud belongs to (ignoring the lateral branches).\n\n::: {.cell execution_count=5}\n``` {.julia .cell-code}\n# Compute the probability that a bud breaks as function of distance to the meristem\nfunction prob_break(bud)\n    # We move to parent node in the branch where the bud was created\n    node =  parent(bud)\n    # Extract the first internode\n    child = filter(x -> data(x) isa TreeTypes.Internode, children(node))[1]\n    data_child = data(child)\n    # We measure the length of the branch until we find the meristem\n    distance = 0.0\n    while !isa(data_child, TreeTypes.Meristem)\n        # If we encounter an internode, store the length and move to the next node\n        if data_child isa TreeTypes.Internode\n            distance += data_child.length\n            child = children(child)[1]\n            data_child = data(child)\n        # If we encounter a node, extract the next internode    \n        elseif data_child isa TreeTypes.Node\n                child = filter(x -> data(x) isa TreeTypes.Internode, children(child))[1]\n                data_child = data(child)\n        else\n            error(\"Should be Internode, Node or Meristem\")\n        end\n    end\n    # Compute the probability of bud break as function of distance and \n    # make stochastic decision\n    prob =  min(1.0, distance*vars(bud).budbreak)\n    return rand() < prob\nend\n\n# Branch rule parameterized by initial states of internodes\nfunction create_branch_rule(vint)\n    branch_rule = Rule(TreeTypes.Bud, \n            lhs = prob_break, \n            rhs = bud -> TreeTypes.BudNode() + \n                         TreeTypes.Internode(biomass = vint.biomass, \n                                             length  = vint.length,\n                                             width   = vint.width) +\n                         TreeTypes.Meristem())\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=6}\n```\ncreate_branch_rule (generic function with 1 method)\n```\n:::\n:::\n\n\n### Growth\n\nWe need some functions to compute the length and width of a leaf or internode \nfrom its biomass\n\n::: {.cell execution_count=6}\n``` {.julia .cell-code}\nfunction leaf_dims(biomass, vars)\n    leaf_biomass = biomass\n    leaf_area    = biomass/vars.SLW\n    leaf_length  = sqrt(leaf_area*4*vars.LS/pi)\n    leaf_width   = leaf_length/vars.LS\n    return leaf_length, leaf_width\nend\n\nfunction int_dims(biomass, vars)\n    int_biomass = biomass\n    int_volume  = biomass/vars.SIW\n    int_length  = cbrt(int_volume*4*vars.IS^2/pi)\n    int_width   = int_length/vars.IS\n    return int_length, int_width\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=7}\n```\nint_dims (generic function with 1 method)\n```\n:::\n:::\n\n\nEach day, the total biomass of the tree is updated using a simple RGR formula\nand the increment of biomass is distributed across the organs proportionally to\ntheir relative sink strength (of leaves or internodes).\n\nThe sink strength of leaves is modelled with a beta distribution scaled to the\n`leaf_expansion` argument that determines the duration of leaf growth, whereas\nfor the internodes it follows a negative exponential distribution. The `pdf` \nfunction computes the probability density of each distribution which is taken as \nproportional to the sink strength (the model is actually source-limited since we \nimposed a particular growth rate).\n\n::: {.cell execution_count=7}\n``` {.julia .cell-code}\nsink_strength(leaf, vars) = leaf.age > vars.leaf_expansion ? 0.0 :  \n                            pdf(leaf.sink, leaf.age/vars.leaf_expansion)/100.0\nplot(0:1:50, x -> sink_strength(TreeTypes.Leaf(age = x), TreeTypes.treeparams()), \n     xlabel = \"Age\", ylabel = \"Sink strength\", label = \"Leaf\")\n```\n\n::: {.cell-output .cell-output-display execution_count=8}\n![](index_files/figure-html/cell-8-output-1.svg){}\n:::\n:::\n\n\n::: {.cell execution_count=8}\n``` {.julia .cell-code}\nsink_strength(int) = pdf(int.sink, int.age)\nplot!(0:1:50, x -> sink_strength(TreeTypes.Internode(age = x)), label = \"Internode\")\n```\n\n::: {.cell-output .cell-output-display execution_count=9}\n![](index_files/figure-html/cell-9-output-1.svg){}\n:::\n:::\n\n\nNow we need a function that updates the biomass of the tree, allocates it to the\ndifferent organs and updates the dimensions of said organs. For simplicity,\nwe create the functions `leaves()` and `internodes()` that will apply the queries\nto the tree required to extract said nodes:\n\n::: {.cell execution_count=9}\n``` {.julia .cell-code}\nget_leaves(tree) = apply(tree, Query(TreeTypes.Leaf))\nget_internodes(tree) = apply(tree, Query(TreeTypes.Internode))\n```\n\n::: {.cell-output .cell-output-display execution_count=10}\n```\nget_internodes (generic function with 1 method)\n```\n:::\n:::\n\n\nThe age of the different organs is updated every time step:\n\n::: {.cell execution_count=10}\n``` {.julia .cell-code}\nfunction age!(all_leaves, all_internodes, all_meristems)\n    for leaf in all_leaves\n        leaf.age += 1\n    end\n    for int in all_internodes\n        int.age += 1\n    end\n    for mer in all_meristems\n        mer.age += 1\n    end\n    return nothing\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=11}\n```\nage! (generic function with 1 method)\n```\n:::\n:::\n\n\nThe daily growth is allocated to different organs proportional to their sink\nstrength.\n\n::: {.cell execution_count=11}\n``` {.julia .cell-code}\nfunction grow!(tree, all_leaves, all_internodes)\n    # Compute total biomass increment\n    tvars = vars(tree)\n    ΔB    = tvars.RGR*tvars.biomass\n    tvars.biomass += ΔB\n    # Total sink strength\n    total_sink = 0.0\n    for leaf in all_leaves\n        total_sink += sink_strength(leaf, tvars)\n    end\n    for int in all_internodes\n        total_sink += sink_strength(int)\n    end\n    # Allocate biomass to leaves and internodes\n    for leaf in all_leaves\n        leaf.biomass += ΔB*sink_strength(leaf, tvars)/total_sink\n    end\n    for int in all_internodes\n        int.biomass += ΔB*sink_strength(int)/total_sink\n    end\n    return nothing\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=12}\n```\ngrow! (generic function with 1 method)\n```\n:::\n:::\n\n\nFinally, we need to update the dimensions of the organs. The leaf dimensions are\n\n::: {.cell execution_count=12}\n``` {.julia .cell-code}\nfunction size_leaves!(all_leaves, tvars)\n    for leaf in all_leaves\n        leaf.length, leaf.width = leaf_dims(leaf.biomass, tvars)\n    end\n    return nothing\nend\nfunction size_internodes!(all_internodes, tvars)\n    for int in all_internodes\n        int.length, int.width = int_dims(int.biomass, tvars)\n    end\n    return nothing\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=13}\n```\nsize_internodes! (generic function with 1 method)\n```\n:::\n:::\n\n\n### Daily step\n\nAll the growth and developmental functions are combined together into a daily\nstep function that updates the forest by iterating over the different trees in\nparallel.\n\n::: {.cell execution_count=13}\n``` {.julia .cell-code}\nget_meristems(tree) = apply(tree, Query(TreeTypes.Meristem))\nfunction daily_step!(forest)\n    @threads for tree in forest\n        # Retrieve all the relevant organs\n        all_leaves = get_leaves(tree)\n        all_internodes = get_internodes(tree)\n        all_meristems = get_meristems(tree)\n        # Update the age of the organs\n        age!(all_leaves, all_internodes, all_meristems)\n        # Grow the tree\n        grow!(tree, all_leaves, all_internodes)\n        tvars = vars(tree)\n        size_leaves!(all_leaves, tvars)\n        size_internodes!(all_internodes, tvars)\n        # Developmental rules\n        rewrite!(tree)\n    end\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=14}\n```\ndaily_step! (generic function with 1 method)\n```\n:::\n:::\n\n\n### Initialization\n\nThe trees are initialized in a regular grid with random values for the initial\norientation and RGR:\n\n::: {.cell execution_count=14}\n``` {.julia .cell-code}\nRGRs = rand(Normal(0.3,0.01), 10, 10)\nhistogram(vec(RGRs))\n```\n\n::: {.cell-output .cell-output-display execution_count=15}\n![](index_files/figure-html/cell-15-output-1.svg){}\n:::\n:::\n\n\n::: {.cell execution_count=15}\n``` {.julia .cell-code}\norientations = [rand()*360.0 for i = 1:2.0:20.0, j = 1:2.0:20.0]\nhistogram(vec(orientations))\n```\n\n::: {.cell-output .cell-output-display execution_count=16}\n![](index_files/figure-html/cell-16-output-1.svg){}\n:::\n:::\n\n\n::: {.cell execution_count=16}\n``` {.julia .cell-code}\norigins = [Vec(i,j,0) for i = 1:2.0:20.0, j = 1:2.0:20.0];\n```\n:::\n\n\nThe following initalizes a tree based on the origin, orientation and RGR:\n\n::: {.cell execution_count=17}\n``` {.julia .cell-code}\nfunction create_tree(origin, orientation, RGR)\n    # Initial state and parameters of the tree\n    vars = TreeTypes.treeparams(RGR = RGR)\n    # Initial states of the leaves\n    leaf_length, leaf_width = leaf_dims(vars.LB0, vars)\n    vleaf = (biomass = vars.LB0, length = leaf_length, width = leaf_width)\n    # Initial states of the internodes\n    int_length, int_width = int_dims(vars.LB0, vars)\n    vint = (biomass = vars.IB0, length = int_length, width = int_width)\n    # Growth rules\n    meristem_rule = create_meristem_rule(vleaf, vint)\n    branch_rule   = create_branch_rule(vint)\n    axiom = T(origin) + RH(orientation) +\n            TreeTypes.Internode(biomass = vint.biomass,\n                             length  = vint.length,\n                             width   = vint.width) +\n            TreeTypes.Meristem()\n    tree = Graph(axiom = axiom, rules = (meristem_rule, branch_rule), \n                 vars = vars)\n    return tree\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=18}\n```\ncreate_tree (generic function with 1 method)\n```\n:::\n:::\n\n\n## Visualization\n\nAs in the previous example, it makes sense to visualize the forest with a soil\ntile beneath it. Unlike in the previous example, we will construct the soil tile\nusing a dedicated graph and generate a `Scene` object which can later be \nmerged with the rest of scene generated in daily step:\n\n::: {.cell execution_count=18}\n``` {.julia .cell-code}\nBase.@kwdef struct Soil <: VPL.Node\n    length::Float64 \n    width::Float64\nend\nfunction VPL.feed!(turtle::Turtle, s::Soil, vars)\n    Rectangle!(turtle, length = s.length, width = s.width, color = RGB(255/255, 236/255, 179/255))\nend\nsoil_graph = RA(-90.0) + T(Vec(0.0, 10.0, 0.0)) + # Moves into position\n             Soil(length = 20.0, width = 20.0) # Draws the soil tile\nsoil = Scene(Graph(axiom = soil_graph));\nrender(soil, axes = false)\n```\n\n::: {.cell-output .cell-output-display execution_count=19}\n![](index_files/figure-html/cell-19-output-1.png){}\n:::\n:::\n\n\nAnd the following function renders the entire scene (notice that we need to\nuse `display()` to force the rendering of the scene when called within a loop\nor a function):\n\n::: {.cell execution_count=19}\n``` {.julia .cell-code}\nfunction render_forest(forest, soil)\n    scene = Scene(vec(forest)) # create scene from forest\n    scene = Scene([scene, soil]) # merges the two scenes\n    render(scene)\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=20}\n```\nrender_forest (generic function with 1 method)\n```\n:::\n:::\n\n\n## Retrieving canopy-level data\n\nWe may want to extract some information at the canopy level such as LAI. This is\nbest achieved with a query:\n\n::: {.cell execution_count=20}\n``` {.julia .cell-code}\nfunction get_LAI(forest)\n    LAI = 0.0\n    @threads for tree in forest\n        for leaf in get_leaves(tree)\n            LAI += leaf.length*leaf.width*pi/4.0\n        end\n    end\n    return LAI/400.0\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=21}\n```\nget_LAI (generic function with 1 method)\n```\n:::\n:::\n\n\n## Simulation\n\nWe can now create a forest of trees on a regular grid:\n\n::: {.cell execution_count=21}\n``` {.julia .cell-code}\nforest = create_tree.(origins, orientations, RGRs);\nrender_forest(forest, soil)\nfor i in 1:50\n    daily_step!(forest)\nend\nrender_forest(forest, soil)\n```\n\n::: {.cell-output .cell-output-display execution_count=22}\n![](index_files/figure-html/cell-22-output-1.png){}\n:::\n:::\n\n\nAnd compute the leaf area index:\n\n::: {.cell execution_count=22}\n``` {.julia .cell-code}\nget_LAI(forest)\n```\n\n::: {.cell-output .cell-output-display execution_count=23}\n```\n0.24217455687553385\n```\n:::\n:::\n\n\n",
    "supporting": [
      "index_files\\figure-html"
    ],
    "filters": [],
    "includes": {}
  }
}