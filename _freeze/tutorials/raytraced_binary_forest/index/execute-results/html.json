{
  "hash": "c17cd38dc1eaea1c2f2da7b1faf05766",
  "result": {
    "markdown": "---\ntitle: \"Ray-traced forest of binary trees\"\nauthor: \n    - name: \"Alejandro Morales Sierra\"\n      affiliation: \"Centre for Crop Systems Analysis - Wageningen University\"\ndate: last-modified\nexecute: \n  cache: true\n---\n\nIn this example we extend the binary forest example to couple growth to light\ninterception, using a simple light model, where each tree is described by a \nseparate graph object and parameters driving the growth of these trees vary \nacross individuals following a predefined distribution. This is not intended\nan optimal implementation of such a model but rather a demonstration of how to\nuse the ray tracer within VPL in combination with Sky package to simulate light\ndistribution within a scene and retrieved the resulting values on an organ basis.\n\nThe following packages are needed:\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nusing VPL\nusing Base.Threads: @threads\nusing Plots\nimport Random\nusing Sky\nusing FastGaussQuadrature\n```\n:::\n\n\nThe data types needed to simulate the binary trees are given in the following\nmodule. The main difference with respect to the previous example is that more\ninformation is being stored in the Internode object, including the optical\nproperties as well as biomass. The `treeparams` object stores the total PAR\nabsorbed each day, the total biomass of the tree, the specific internode weight\nand the radiation use efficiency (RUE).\n\n::: {.cell execution_count=2}\n``` {.julia .cell-code}\nmodule rbtree\n    using VPL\n    # Meristem\n    struct Meristem <: VPL.Node end\n    # Node\n    struct Node <: VPL.Node end\n    # Internode\n    mutable struct Internode <: VPL.Node\n        biomass::Float64\n        length::Float64\n        width::Float64\n        material::Lambertian{3} # Optical properties for 3 wavebands\n    end\n    # Tree-level variables\n    mutable struct treeparams\n        PAR::Float64     # Total PAR intercepted by the tree in a day\n        RUE::Float64     # Convert absorbed PAR to biomass growth\n        SIW::Float64     # Specific internode weight\n        Biomass::Float64 # Current total biomass\n    end\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=3}\n```\nMain.rbtree\n```\n:::\n:::\n\n\nThe methods for creating the geometry and color of the tree are the same as in\nthe previous example with the addition that we also assign a `Material` object\nto the argument `material` (which is a `Lambertian` object in this case).\n\n::: {.cell execution_count=3}\n``` {.julia .cell-code}\n# Turtle methods\nfunction VPL.feedgeom!(turtle::Turtle, i::rbtree.Internode, vars)\n    HollowCube!(turtle, length = i.length, height =  i.width, width =  i.width, \n                move = true, color = RGB(0,0.35,0), matertial = i.material)\n    return nothing\nend\n```\n:::\n\n\nThe growth rule is also the same as in the previous example, but now the Internode\ntakes initial biomass and optical properties. The optical properties are stored\nin a `Lambertian` object, which is a `Material` object that defines the transmittance\nand reflectance of the material for each waveband to be simulated (in this case three).\n\n::: {.cell execution_count=4}\n``` {.julia .cell-code}\n# Create a new material object with the optical properties\nmat() = Lambertian(τ = (0.0, 0.0, 0.0), # transmittance for blue, green, red\n                   ρ = (0.05, 0.2, 0.1)) # reflectance for blue, green, red\n\n# Create right side of the growth rule (parameterized by initial values of the organ)\nfunction create_branching_rule(biomass, length, width)\n    mer -> begin\n        # New branches\n        branch1 = RU(-60.0) + rbtree.Internode(biomass, length, width, mat()) + RH(90.0) + rbtree.Meristem()\n        branch2 = RU(60.0)  + rbtree.Internode(biomass, length, width, mat()) + RH(90.0) + rbtree.Meristem()\n        # Sub-graph to be added to the tree\n        rbtree.Node() + (branch1, branch2)\n    end\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=5}\n```\ncreate_branching_rule (generic function with 1 method)\n```\n:::\n:::\n\n\nThe creation of each individual tree also resembles the previous example\n\n::: {.cell execution_count=5}\n``` {.julia .cell-code}\n# Create a tree given the origin and RUE\nfunction create_tree(origin, RUE)\n    SIW    = 1e6 # g/m3 (typical wood density for a hardwood)\n    length = 0.5 # m\n    width  = 0.05 # m\n    biomass = length*width^2*SIW # g\n    # Growth rule\n    rule = Rule(rbtree.Meristem, rhs = create_branching_rule(biomass, length, width))\n    axiom = T(origin) + rbtree.Internode(biomass, length, width, mat()) + rbtree.Meristem()\n    tree = Graph(axiom = axiom, rules = Tuple(rule), \n                 vars = rbtree.treeparams(0.0, RUE, SIW, biomass))\n    return tree\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=6}\n```\ncreate_tree (generic function with 1 method)\n```\n:::\n:::\n\n\nWe can now create a forest of trees on a regular grid with random RUE values:\n\n::: {.cell execution_count=6}\n``` {.julia .cell-code}\n# Regular grid of trees 2 meters apart\norigins = [Vec(i,j,0) for i = 1:2.0:20.0, j = 1:2.0:20.0];\nRandom.seed!(123456789)\n# Assume RUE follows a log-normal distribution wth low standard deviation\nRUE_distr(n) = exp.(randn(n)) .+ 15.0 # Unrealistic value to speed up simulation! \nRUEs = RUE_distr(length(origins))\nhistogram(RUEs)\n# Create the forest\nforest = [create_tree(origins[i], RUEs[i]) for i in 1:100];\n```\n:::\n\n\nAs growth is now dependent on intercepted PAR via RUE, we now need to simulate\nlight interception by the trees. We will use a ray-tracing approach to do so.\nThe first step is to create a scene with the trees and the light sources. As for\nrendering, the scene can be created from the `forest` object by simply calling \n`Scene(forest)` that will generate the 3D meshes and connect them to their \noptical properties.\n\nHowever, we also want to add a soil surface as this will affect the light \ndistribution within the scene due to reflection from the soil surface. This is\nsimilar to the customized scene that we created in the previous example. Note\nthat the `soil_material` created below is stored in the scene but nowhere else.\nIf we wanted to recover the irradiance absorbed by the soil tile later on, we \nwould need to store this information somewhere else.\n\n::: {.cell execution_count=7}\n``` {.julia .cell-code}\nfunction create_soil()\n    soil = Rectangle(length = 21.0, width = 21.0)\n    rotatey!(soil, π/2) # To put it in the XY plane\n    VPL.translate!(soil, Vec(0.0, 10.5, 0.0)) # Corner at (0,0,0)\n    return soil\nend\nfunction create_scene(forest)\n    # These are the trees\n    scene = Scene(forest)\n    # Add a soil surface\n    soil = create_soil()\n    soil_material = Lambertian(τ = (0.0, 0.0, 0.0),\n                               ρ = (0.21, 0.21, 0.21))\n    add!(scene, mesh = soil, material = soil_material)\n    # Return the scene\n    return scene\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=8}\n```\ncreate_scene (generic function with 1 method)\n```\n:::\n:::\n\n\nGiven the scene, we can create the light sources that can approximate the solar\nirradiance on a given day, location and time of the day using the functions from\nthe Sky package (see package documentation for details). Given the latitude,\nday of year and fraction of the day (`f = 0` being sunrise and `f = 1` being sunset),\nthe function `clear_sky()` computes the direct and diffuse solar radiation assuming\na clear sky. These values may be converted to different wavebands and units using\n`waveband_conversion()`. Finally, the collection of light sources approximating\nthe solar irradiance distribution over the sky hemisphere is constructed with the\nfunction `sky()` (this last step requires the 3D scene as input in order to place\nthe light sources adequately).\n\n::: {.cell execution_count=8}\n``` {.julia .cell-code}\nfunction create_sky(;scene, f, lat = 52.0*π/180.0, DOY = 182)\n    # Compute solar irradiance\n    Ig, Idir, Idif = clear_sky(lat = lat, DOY = DOY, f = f) # W/m2\n    # Conversion factors to red, green and blue for direct and diffuse irradiance\n    wavebands = (:blue, :green, :red)\n    f_dir = Tuple(waveband_conversion(Itype = :direct,  waveband = x, mode = :power) for x in wavebands)\n    f_dif = Tuple(waveband_conversion(Itype = :diffuse, waveband = x, mode = :power) for x in wavebands)\n    # Actual irradiance per waveband\n    Idir_color = Tuple(f_dir[i]*Idir for i in 1:3)\n    Idif_color = Tuple(f_dif[i]*Idif for i in 1:3)\n    # Create the light sources and assign number of rays\n    sources = sky(scene, \n                  Idir = Idir_color, # Direct solar radiation from above\n                  nrays_dir = 1_000_000, # Number of rays for direct solar radiation\n                  Idif = Idif_color, # Diffuse solar radiation from above\n                  nrays_dif = 10_000_000, # Total number of rays for diffuse solar radiation\n                  sky_model = StandardSky, # Angular distribution of solar radiation\n                  dome_method = equal_solid_angles, # Discretization of the sky dome\n                  ntheta = 9, # Number of discretization steps in the zenith angle \n                  nphi = 12) # Number of discretization steps in the azimuth angle\n    return sources\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=9}\n```\ncreate_sky (generic function with 1 method)\n```\n:::\n:::\n\n\nThe 3D scene and the light sources are then combined into a `RayTracer` object,\ntogether with general settings for the ray tracing simulation chosen via `RTSettings()`.\nThe most important settings refer to the Russian roulette system and the grid \ncloner (see section on Ray Tracing for details). The settings for the Russian\nroulette system include the number of times a ray will be traced\ndeterministically (`maxiter`) and the probability that a ray that exceeds `maxiter`\nis terminated (`pkill`). The grid cloner is used to approximate an infinite canopy\nby replicating the scene in the different directions (`nx` and `ny` being the\nnumber of replicates in each direction along the x and y axes, respectively). It\nis also possible to turn on parallelization of the ray tracing simulation by\nsetting `parallel = true` (currently this uses Julia's builtin multithreading\ncapabilities). \n\nIn addition `RTSettings()`, an acceleration structure and a splitting rule can\nbe defined when creating the `RayTracer` object (see ray tracing documentation \nfor details). The acceleration structure allows speeding up the ray tracing\nby avoiding testing all rays against all objects in the scene.\n\n::: {.cell execution_count=9}\n``` {.julia .cell-code}\nfunction create_raytracer(scene, sources)\n    settings = RTSettings(pkill = 0.9, maxiter = 4, nx = 5, ny = 5, parallel = true)\n    RayTracer(scene, sources, settings = settings, acceleration = BVH,\n                     rule = SAH{6}(5, 10));\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=10}\n```\ncreate_raytracer (generic function with 1 method)\n```\n:::\n:::\n\n\nThe actual ray tracing simulation is performed by calling the `trace!()` method\non the ray tracing object. This will trace all rays from all light sources and\nupdate the radiant power absorbed by the different surfaces in the scene inside\nthe `Material` objects (see `feedmaterial!()` above):\n\n::: {.cell execution_count=10}\n``` {.julia .cell-code}\nfunction run_raytracer!(forest; f = 0.5, DOY = 182)\n    scene   = create_scene(forest)\n    sources = create_sky(scene = scene, f = f, DOY = DOY)\n    rtobj   = create_raytracer(scene, sources)\n    trace!(rtobj)\n    return nothing\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=11}\n```\nrun_raytracer! (generic function with 1 method)\n```\n:::\n:::\n\n\nThe total PAR absorbed for each tree is calculated from the material objects of\nthe different internodes (using `power()` on the `Material` object). Note that\nthe `power()` function returns three different values, one for each waveband,\nbut they are added together as RUE is defined for total PAR.\n\nIn most cases the relationship between absorbed PAR and growth is not linear and\nthus the process needs to be integrated over the day. That is not case here since\nwe use an RUE constant, however the general scenario is shown for generality. For\nmore complex models (e.g., where photosynthesis is computed for each organ) the\n`calculate_PAR!` function below would be replaced by a function that computes\nphotosynthesis for each organ and then adds up to the tree level.\n\n::: {.cell execution_count=11}\n``` {.julia .cell-code}\ngetInternode = Query(rbtree.Internode)\n# Run the ray tracer, calculate PAR absorbed per tree and add it to the daily\n# total using general weighted quadrature formula\nfunction calculate_PAR!(forest; f = 0.5, w = 1.0, dt = 1.0, DOY = 182)\n    # Run the ray tracer\n    run_raytracer!(forest, f = f, DOY = DOY)\n    # Add up PAR absorbed by each tree and add to the tree variables\n    @threads for tree in forest\n        PAR = 0.0\n        for i in apply(tree, getInternode)\n            PAR += sum(power(i.material))\n        end\n        tree.vars.PAR += w*PAR*dt\n    end\n    return nothing\nend\n\n# Gaussian-Legendre integration of PAR absorbed over the day\nfunction daily_PAR!(forest; nsteps = 5, DOY = 182, lat = 52.0*π/180.0)\n    # Compute length of the day\n    dec = declination(DOY)\n    dl = day_length(lat, dec)\n    dt = dl/nsteps\n    # Generate nodes and weights for Gaussian-Legendre integration\n    nodes, weights = gausslegendre(nsteps)\n    ws   = weights./2 # Scale weights to add up to 1\n    fs   = 0.5 .+ nodes./2 # Scale nodes to [0,1]\n    # Integrate over the day\n    for i in 1:nsteps\n        calculate_PAR!(forest, f = fs[i], w = ws[i], dt = dt, DOY = DOY)\n    end\n    return nothing\nend\n\n# Reset PAR absorbed by the tree (at the start of a new day)\nfunction reset_PAR!(forest)\n    for tree in forest\n        tree.vars.PAR = 0.0\n    end\n    return nothing\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=12}\n```\nreset_PAR! (generic function with 1 method)\n```\n:::\n:::\n\n\nGiven the total daily PAR absorbed by each tree, it may be converted to biomass\nusing the RUE. The growth function below is called at the end of each day and\nupdates the dimensions of each internode inside a tree based on the new biomass,\nas well as add new organs to the tree by applying the graph rewriting rule.\n\n::: {.cell execution_count=12}\n``` {.julia .cell-code}\n# Growth function\nfunction growth!(tree)\n    # Total growth based on RUE\n    growth = tree.vars.RUE*tree.vars.PAR/1e6\n    # Allocate growth to each organ and compute new dimensions\n    for i in apply(tree, getInternode)\n        biomass    = i.length*i.width^2*tree.vars.SIW\n        i.biomass += growth*i.biomass/tree.vars.Biomass # Simple allocation rule\n        volume     = i.biomass/tree.vars.SIW\n        i.length   = cbrt(100volume) # Assume width = length/10\n        i.width    = i.length/10\n    end\n    # Update total tree biomass\n    tree.vars.Biomass += growth\n    # Create new organs with the growth rule\n    rewrite!(tree)\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=13}\n```\ngrowth! (generic function with 1 method)\n```\n:::\n:::\n\n\nFinally, all the pieces may be combined into a single function that simulates\nthe daily steps of the model:\n\n::: {.cell execution_count=13}\n``` {.julia .cell-code}\nfunction daily_step!(forest, DOY)\n    # Reset PAR absorbed by the tree\n    reset_PAR!(forest)\n    # Integrate PAR absorbed over the day\n    daily_PAR!(forest, DOY = DOY)\n    # Update tree dimensions and add new organs\n    @threads for tree in forest\n        growth!(tree)\n    end\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=14}\n```\ndaily_step! (generic function with 1 method)\n```\n:::\n:::\n\n\nWe can create a function for rendering the forest in combination with the soil:\n\n::: {.cell execution_count=14}\n``` {.julia .cell-code}\nfunction render_forest(forest)\n    # Plot the forest\n    display(render(forest, axes = false))\n    # Generate the soil and add it\n    soil = create_soil()\n    render!(soil, color = RGB(1.0,1.0,0.5))\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=15}\n```\nrender_forest (generic function with 1 method)\n```\n:::\n:::\n\n\nWe can now simulate and visualize the growth of the forest by calling the \n`daily_step!` function iteratively:\n\n::: {.cell execution_count=15}\n``` {.julia .cell-code}\nnewforest = deepcopy(forest)\nstart = 182\nrender_forest(forest)\nfor i in 1:3\n    println(\"Day $i\")\n    daily_step!(newforest, start + i)\n    render_forest(newforest)\nend\n```\n:::\n\n\n",
    "supporting": [
      "index_files\\figure-html"
    ],
    "filters": [],
    "includes": {}
  }
}