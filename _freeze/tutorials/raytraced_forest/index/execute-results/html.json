{
  "hash": "9da935c68cd53f0e9cb0db271c3a03b2",
  "result": {
    "markdown": "---\ntitle: \"RUE-driven forest\"\nauthor: \n    - name: \"Alejandro Morales Sierra\"\n      affiliation: \"Centre for Crop Systems Analysis - Wageningen University\"\ndate: last-modified\nexecute: \n  eval: false\n---\n\nIn this example we extend the forest growth model to include PAR interception and a\nradiation use efficiency to compute the daily growth rate.\n\nThe initial setup is as follows:\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nusing VPL\nusing Sky\nusing Plots\nusing Distributions\nimport Random\nRandom.seed!(123456789)\nusing Base.Threads: @threads\n```\n:::\n\n\n## Model definition\n\n### Node types\n\nThe data types needed to simulate the trees are given in the following\nmodule. The difference with respec to the previous model is that Internodes and \nLeaves have optical properties needed for ray tracing (they are defined as \nLambertian surfaces).\n\n::: {.cell execution_count=2}\n``` {.julia .cell-code}\n# Data types\nmodule TreeTypes\n    using VPL\n    using Distributions\n    # Meristem\n    Base.@kwdef mutable struct Meristem <: VPL.Node \n        age::Int64 = 0   # Age of the meristem\n    end\n    # Bud\n    struct Bud <: VPL.Node end\n    # Node\n    struct Node <: VPL.Node end\n    # BudNode\n    struct BudNode <: VPL.Node end\n    # Internode (needs to be mutable to allow for changes over time)\n    Base.@kwdef mutable struct Internode <: VPL.Node\n        age::Int64 = 0         # Age of the internode\n        biomass::Float64 = 0.0 # Initial biomass\n        length::Float64 = 0.0  # Internodes\n        width::Float64  = 0.0  # Internodes\n        sink::Exponential{Float64} = Exponential(5)\n        material::Lambertian{1} = Lambertian(τ = 0.1, ρ = 0.05) # Leaf material\n    end\n    # Leaf\n    Base.@kwdef mutable struct Leaf <: VPL.Node\n        age::Int64 = 0         # Age of the leaf\n        biomass::Float64 = 0.0 # Initial biomass\n        length::Float64 = 0.0  # Leaves\n        width::Float64 = 0.0   # Leaves\n        sink::Beta{Float64} = Beta(2,5)\n        material::Lambertian{1} = Lambertian(τ = 0.1, ρ = 0.05) # Leaf material\n    end    \n    # Graph-level variables -> mutable because we need to modify them during growth\n    Base.@kwdef mutable struct treeparams\n        # Variables\n        PAR::Float64 = 0.0   # Total PAR absorbed by the leaves on the tree (MJ)\n        biomass::Float64 = 2e-3 # Current total biomass (g)\n        # Parameters\n        RUE::Float64 = 5.0   # Radiation use efficiency (g/MJ) -> unrealistic to speed up sim\n        IB0::Float64 = 1e-3  # Initial biomass of an internode (g)\n        SIW::Float64 = 0.1e6   # Specific internode weight (g/m3)\n        IS::Float64  = 15.0  # Internode shape parameter (length/width)\n        LB0::Float64 = 1e-3  # Initial biomass of a leaf\n        SLW::Float64 = 100.0 # Specific leaf weight (g/m2)\n        LS::Float64  = 3.0   # Leaf shape parameter (length/width)\n        budbreak::Float64 = 1/0.5 # Bud break probability coefficient (in 1/m) \n        plastochron::Int64 = 5 # Number of days between phytomer production \n        leaf_expansion::Float64 = 15.0 # Number of days that a leaf expands\n        phyllotaxis::Float64 = 140.0\n        leaf_angle::Float64 = 30.0\n        branch_angle::Float64 = 45.0\n    end\nend\n\nimport .TreeTypes\n```\n:::\n\n\n### Geometry\n\nThe methods for creating the geometry and color of the tree are the same as in\nthe previous example but include the materials for the ray tracer.\n\n::: {.cell execution_count=3}\n``` {.julia .cell-code}\n# Create geometry + color for the internodes\nfunction VPL.feed!(turtle::Turtle, i::TreeTypes.Internode, vars)\n    # Rotate turtle around the head to implement elliptical phyllotaxis\n    rh!(turtle, vars.phyllotaxis) \n    HollowCylinder!(turtle, length = i.length, height = i.width, width = i.width, \n                move = true, color = RGB(0.5,0.4,0.0), material = i.material)\n    return nothing\nend\n\n# Create geometry + color for the leaves\nfunction VPL.feed!(turtle::Turtle, l::TreeTypes.Leaf, vars)\n    # Rotate turtle around the arm for insertion angle\n    ra!(turtle, -vars.leaf_angle)\n    # Generate the leaf \n    Ellipse!(turtle, length = l.length, width = l.width, move = false, \n             color = RGB(0.2,0.6,0.2), material = l.material)\n    # Rotate turtle back to original direction\n    ra!(turtle, vars.leaf_angle)\n    return nothing\nend\n\n# Insertion angle for the bud nodes\nfunction VPL.feed!(turtle::Turtle, b::TreeTypes.BudNode, vars)\n    # Rotate turtle around the arm for insertion angle\n    ra!(turtle, -vars.branch_angle)\nend\n```\n:::\n\n\n### Development\n\nThe meristem rule is now parameterized by the initial states of the leaves and\ninternodes and will only be triggered every X days where X is the plastochron.\n\n::: {.cell execution_count=4}\n``` {.julia .cell-code}\n# Create right side of the growth rule (parameterized by the initial states\n# of the leaves and internodes)\nfunction create_meristem_rule(vleaf, vint)\n    meristem_rule = Rule(TreeTypes.Meristem, \n                        lhs = mer -> mod(data(mer).age, vars(mer).plastochron) == 0,\n                        rhs = mer -> TreeTypes.Node() + \n                                     (TreeTypes.Bud(), \n                                     TreeTypes.Leaf(biomass = vleaf.biomass, \n                                                    length  = vleaf.length,\n                                                    width   = vleaf.width)) +\n                                     TreeTypes.Internode(biomass = vint.biomass, \n                                                         length  = vint.length,\n                                                         width   = vint.width) + \n                                     TreeTypes.Meristem())\nend\n```\n:::\n\n\nThe bud break probability is now a function of distance to the apical meristem\nrather than the number of internodes. An adhoc traversal is used to compute this\nlength of the main branch a bud belongs to (ignoring the lateral branches).\n\n::: {.cell execution_count=5}\n``` {.julia .cell-code}\n# Compute the probability that a bud breaks as function of distance to the meristem\nfunction prob_break(bud)\n    # We move to parent node in the branch where the bud was created\n    node =  parent(bud)\n    # Extract the first internode\n    child = filter(x -> data(x) isa TreeTypes.Internode, children(node))[1]\n    data_child = data(child)\n    # We measure the length of the branch until we find the meristem\n    distance = 0.0\n    while !isa(data_child, TreeTypes.Meristem)\n        # If we encounter an internode, store the length and move to the next node\n        if data_child isa TreeTypes.Internode\n            distance += data_child.length\n            child = children(child)[1]\n            data_child = data(child)\n        # If we encounter a node, extract the next internode    \n        elseif data_child isa TreeTypes.Node\n                child = filter(x -> data(x) isa TreeTypes.Internode, children(child))[1]\n                data_child = data(child)\n        else\n            error(\"Should be Internode, Node or Meristem\")\n        end\n    end\n    # Compute the probability of bud break as function of distance and \n    # make stochastic decision\n    prob =  min(1.0, distance*vars(bud).budbreak)\n    return rand() < prob\nend\n\n# Branch rule parameterized by initial states of internodes\nfunction create_branch_rule(vint)\n    branch_rule = Rule(TreeTypes.Bud, \n            lhs = prob_break, \n            rhs = bud -> TreeTypes.BudNode() + \n                         TreeTypes.Internode(biomass = vint.biomass, \n                                             length  = vint.length,\n                                             width   = vint.width) +\n                         TreeTypes.Meristem())\nend\n```\n:::\n\n\n### Light interception\n\nAs growth is now dependent on intercepted PAR via RUE, we now need to simulate\nlight interception by the trees. We will use a ray-tracing approach to do so.\nThe first step is to create a scene with the trees and the light sources. As for\nrendering, the scene can be created from the `forest` object by simply calling \n`Scene(forest)` that will generate the 3D meshes and connect them to their \noptical properties.\n\nHowever, we also want to add the soil surface as this will affect the light \ndistribution within the scene due to reflection from the soil surface. This is\nsimilar to the customized scene that we created before for rendering, but now\nfor the light simulation.\n\n::: {.cell execution_count=6}\n``` {.julia .cell-code}\nfunction create_soil()\n    soil = Rectangle(length = 21.0, width = 21.0)\n    rotatey!(soil, π/2) # To put it in the XY plane\n    VPL.translate!(soil, Vec(0.0, 10.5, 0.0)) # Corner at (0,0,0)\n    return soil\nend\nfunction create_scene(forest)\n    # These are the trees\n    scene = Scene(vec(forest))\n    # Add a soil surface\n    soil = create_soil()\n    soil_material = Lambertian(τ = 0.0, ρ = 0.21)\n    add!(scene, mesh = soil, material = soil_material)\n    # Return the scene\n    return scene\nend\n```\n:::\n\n\nGiven the scene, we can create the light sources that can approximate the solar\nirradiance on a given day, location and time of the day using the functions from\nthe Sky package (see package documentation for details). Given the latitude,\nday of year and fraction of the day (`f = 0` being sunrise and `f = 1` being sunset),\nthe function `clear_sky()` computes the direct and diffuse solar radiation assuming\na clear sky. These values may be converted to different wavebands and units using\n`waveband_conversion()`. Finally, the collection of light sources approximating\nthe solar irradiance distribution over the sky hemisphere is constructed with the\nfunction `sky()` (this last step requires the 3D scene as input in order to place\nthe light sources adequately).\n\n::: {.cell execution_count=7}\n``` {.julia .cell-code}\nfunction create_sky(;scene, lat = 52.0*π/180.0, DOY = 182)\n    # Fraction of the day and day length\n    fs = collect(0.1:0.1:0.9)\n    dec = declination(DOY)\n    DL = day_length(lat, dec)*3600\n    # Compute solar irradiance\n    temp = [clear_sky(lat = lat, DOY = DOY, f = f) for f in fs] # W/m2\n    Ig   = getindex.(temp, 1)\n    Idir = getindex.(temp, 2)\n    Idif = getindex.(temp, 3)\n    # Conversion factors to PAR for direct and diffuse irradiance\n    f_dir = waveband_conversion(Itype = :direct,  waveband = :PAR, mode = :power)\n    f_dif = waveband_conversion(Itype = :diffuse, waveband = :PAR, mode = :power)\n    # Actual irradiance per waveband\n    Idir_PAR = f_dir.*Idir\n    Idif_PAR = f_dif.*Idif\n    # Create the dome of diffuse light\n    dome = sky(scene, \n                  Idir = 0.0, # No direct solar radiation\n                  Idif = sum(Idir_PAR)/10*DL, # Daily Diffuse solar radiation\n                  nrays_dif = 1_000_000, # Total number of rays for diffuse solar radiation\n                  sky_model = StandardSky, # Angular distribution of solar radiation\n                  dome_method = equal_solid_angles, # Discretization of the sky dome\n                  ntheta = 9, # Number of discretization steps in the zenith angle \n                  nphi = 12) # Number of discretization steps in the azimuth angle\n    # Add direct sources for different times of the day\n    for I in Idir_PAR\n        push!(dome, sky(scene, Idir = I/10*DL, nrays_dir = 100_000, Idif = 0.0)[1])\n    end \n    return dome\nend\n```\n:::\n\n\nThe 3D scene and the light sources are then combined into a `RayTracer` object,\ntogether with general settings for the ray tracing simulation chosen via `RTSettings()`.\nThe most important settings refer to the Russian roulette system and the grid \ncloner (see section on Ray Tracing for details). The settings for the Russian\nroulette system include the number of times a ray will be traced\ndeterministically (`maxiter`) and the probability that a ray that exceeds `maxiter`\nis terminated (`pkill`). The grid cloner is used to approximate an infinite canopy\nby replicating the scene in the different directions (`nx` and `ny` being the\nnumber of replicates in each direction along the x and y axes, respectively). It\nis also possible to turn on parallelization of the ray tracing simulation by\nsetting `parallel = true` (currently this uses Julia's builtin multithreading\ncapabilities). \n\nIn addition `RTSettings()`, an acceleration structure and a splitting rule can\nbe defined when creating the `RayTracer` object (see ray tracing documentation \nfor details). The acceleration structure allows speeding up the ray tracing\nby avoiding testing all rays against all objects in the scene.\n\n::: {.cell execution_count=8}\n``` {.julia .cell-code}\nfunction create_raytracer(scene, sources)\n    settings = RTSettings(pkill = 0.9, maxiter = 4, nx = 5, ny = 5, dx = 20.0,\n                          dy = 20.0, parallel = true)\n    RayTracer(scene, sources, settings = settings, acceleration = BVH,\n                     rule = SAH{3}(5, 10));\nend\n```\n:::\n\n\nThe actual ray tracing simulation is performed by calling the `trace!()` method\non the ray tracing object. This will trace all rays from all light sources and\nupdate the radiant power absorbed by the different surfaces in the scene inside\nthe `Material` objects (see `feed!()` above):\n\n::: {.cell execution_count=9}\n``` {.julia .cell-code}\nfunction run_raytracer!(forest; DOY = 182)\n    scene   = create_scene(forest)\n    sources = create_sky(scene = scene, DOY = DOY)\n    rtobj   = create_raytracer(scene, sources)\n    trace!(rtobj)\n    return nothing\nend\n```\n:::\n\n\nThe total PAR absorbed for each tree is calculated from the material objects of\nthe different internodes (using `power()` on the `Material` object). Note that\nthe `power()` function returns three different values, one for each waveband,\nbut they are added together as RUE is defined for total PAR.\n\n::: {.cell execution_count=10}\n``` {.julia .cell-code}\n# Run the ray tracer, calculate PAR absorbed per tree and add it to the daily\n# total using general weighted quadrature formula\nfunction calculate_PAR!(forest;  DOY = 182)\n    # Reset PAR absorbed by the tree (at the start of a new day)\n    reset_PAR!(forest)\n    # Run the ray tracer to compute daily PAR absorption\n    run_raytracer!(forest, DOY = DOY)\n    # Add up PAR absorbed by each leaf within each tree\n    @threads for tree in forest\n        for l in get_leaves(tree)\n            vars(tree).PAR += power(l.material)[1]\n        end\n    end\n    return nothing\nend\n\n# Reset PAR absorbed by the tree (at the start of a new day)\nfunction reset_PAR!(forest)\n    for tree in forest\n        vars(tree).PAR = 0.0\n    end\n    return nothing\nend\n```\n:::\n\n\n### Growth\n\nWe need some functions to compute the length and width of a leaf or internode \nfrom its biomass\n\n::: {.cell execution_count=11}\n``` {.julia .cell-code}\nfunction leaf_dims(biomass, vars)\n    leaf_biomass = biomass\n    leaf_area    = biomass/vars.SLW\n    leaf_length  = sqrt(leaf_area*4*vars.LS/pi)\n    leaf_width   = leaf_length/vars.LS\n    return leaf_length, leaf_width\nend\n\nfunction int_dims(biomass, vars)\n    int_biomass = biomass\n    int_volume  = biomass/vars.SIW\n    int_length  = cbrt(int_volume*4*vars.IS^2/pi)\n    int_width   = int_length/vars.IS\n    return int_length, int_width\nend\n```\n:::\n\n\nEach day, the total biomass of the tree is updated using a simple RUE formula\nand the increment of biomass is distributed across the organs proportionally to\ntheir relative sink strength (of leaves or internodes).\n\nThe sink strength of leaves is modelled with a beta distribution scaled to the\n`leaf_expansion` argument that determines the duration of leaf growth, whereas\nfor the internodes it follows a negative exponential distribution. The `pdf` \nfunction computes the probability density of each distribution which is taken as \nproportional to the sink strength (the model is actually source-limited since we \nimposed a particular growth rate).\n\n::: {.cell execution_count=12}\n``` {.julia .cell-code}\nsink_strength(leaf, vars) = leaf.age > vars.leaf_expansion ? 0.0 :  \n                            pdf(leaf.sink, leaf.age/vars.leaf_expansion)/100.0\nplot(0:1:50, x -> sink_strength(TreeTypes.Leaf(age = x), TreeTypes.treeparams()), \n     xlabel = \"Age\", ylabel = \"Sink strength\", label = \"Leaf\")\n```\n:::\n\n\n::: {.cell execution_count=13}\n``` {.julia .cell-code}\nsink_strength(int) = pdf(int.sink, int.age)\nplot!(0:1:50, x -> sink_strength(TreeTypes.Internode(age = x)), label = \"Internode\")\n```\n:::\n\n\nNow we need a function that updates the biomass of the tree, allocates it to the\ndifferent organs and updates the dimensions of said organs. For simplicity,\nwe create the functions `leaves()` and `internodes()` that will apply the queries\nto the tree required to extract said nodes:\n\n::: {.cell execution_count=14}\n``` {.julia .cell-code}\nget_leaves(tree) = apply(tree, Query(TreeTypes.Leaf))\nget_internodes(tree) = apply(tree, Query(TreeTypes.Internode))\n```\n:::\n\n\nThe age of the different organs is updated every time step:\n\n::: {.cell execution_count=15}\n``` {.julia .cell-code}\nfunction age!(all_leaves, all_internodes, all_meristems)\n    for leaf in all_leaves\n        leaf.age += 1\n    end\n    for int in all_internodes\n        int.age += 1\n    end\n    for mer in all_meristems\n        mer.age += 1\n    end\n    return nothing\nend\n```\n:::\n\n\nThe daily growth is allocated to different organs proportional to their sink\nstrength.\n\n::: {.cell execution_count=16}\n``` {.julia .cell-code}\nfunction grow!(tree, all_leaves, all_internodes)\n    # Compute total biomass increment\n    tvars = vars(tree)\n    ΔB    = max(0.5, tvars.RUE*tvars.PAR/1e6) # Trick to emulate reserves in seedling\n    tvars.biomass += ΔB\n    # Total sink strength\n    total_sink = 0.0\n    for leaf in all_leaves\n        total_sink += sink_strength(leaf, tvars)\n    end\n    for int in all_internodes\n        total_sink += sink_strength(int)\n    end\n    # Allocate biomass to leaves and internodes\n    for leaf in all_leaves\n        leaf.biomass += ΔB*sink_strength(leaf, tvars)/total_sink\n    end\n    for int in all_internodes\n        int.biomass += ΔB*sink_strength(int)/total_sink\n    end\n    return nothing\nend\n```\n:::\n\n\nFinally, we need to update the dimensions of the organs. The leaf dimensions are\n\n::: {.cell execution_count=17}\n``` {.julia .cell-code}\nfunction size_leaves!(all_leaves, tvars)\n    for leaf in all_leaves\n        leaf.length, leaf.width = leaf_dims(leaf.biomass, tvars)\n    end\n    return nothing\nend\nfunction size_internodes!(all_internodes, tvars)\n    for int in all_internodes\n        int.length, int.width = int_dims(int.biomass, tvars)\n    end\n    return nothing\nend\n```\n:::\n\n\n### Daily step\n\nAll the growth and developmental functions are combined together into a daily\nstep function that updates the forest by iterating over the different trees in\nparallel.\n\n::: {.cell execution_count=18}\n``` {.julia .cell-code}\nget_meristems(tree) = apply(tree, Query(TreeTypes.Meristem))\nfunction daily_step!(forest, DOY)\n    # Compute PAR absorbed by each tree\n    calculate_PAR!(forest, DOY = DOY)\n    # Grow the trees\n    @threads for tree in forest\n        # Retrieve all the relevant organs\n        all_leaves = get_leaves(tree)\n        all_internodes = get_internodes(tree)\n        all_meristems = get_meristems(tree)\n        # Update the age of the organs\n        age!(all_leaves, all_internodes, all_meristems)\n        # Grow the tree\n        grow!(tree, all_leaves, all_internodes)\n        tvars = vars(tree)\n        size_leaves!(all_leaves, tvars)\n        size_internodes!(all_internodes, tvars)\n        # Developmental rules\n        rewrite!(tree)\n    end\nend\n```\n:::\n\n\n### Initialization\n\nThe trees are initialized on a regular grid with random values for the initial\norientation and RUE:\n\n::: {.cell execution_count=19}\n``` {.julia .cell-code}\nRUEs = rand(Normal(1.5,0.2), 10, 10)\nhistogram(vec(RUEs))\n```\n:::\n\n\n::: {.cell execution_count=20}\n``` {.julia .cell-code}\norientations = [rand()*360.0 for i = 1:2.0:20.0, j = 1:2.0:20.0]\nhistogram(vec(orientations))\n```\n:::\n\n\n::: {.cell execution_count=21}\n``` {.julia .cell-code}\norigins = [Vec(i,j,0) for i = 1:2.0:20.0, j = 1:2.0:20.0];\n```\n:::\n\n\nThe following initalizes a tree based on the origin, orientation and RUE:\n\n::: {.cell execution_count=22}\n``` {.julia .cell-code}\nfunction create_tree(origin, orientation, RUE)\n    # Initial state and parameters of the tree\n    vars = TreeTypes.treeparams(RUE = RUE)\n    # Initial states of the leaves\n    leaf_length, leaf_width = leaf_dims(vars.LB0, vars)\n    vleaf = (biomass = vars.LB0, length = leaf_length, width = leaf_width)\n    # Initial states of the internodes\n    int_length, int_width = int_dims(vars.LB0, vars)\n    vint = (biomass = vars.IB0, length = int_length, width = int_width)\n    # Growth rules\n    meristem_rule = create_meristem_rule(vleaf, vint)\n    branch_rule   = create_branch_rule(vint)\n    axiom = T(origin) + RH(orientation) +\n            TreeTypes.Internode(biomass = vint.biomass,\n                                length  = vint.length,\n                                width   = vint.width) +\n            TreeTypes.Meristem()\n    tree = Graph(axiom = axiom, rules = (meristem_rule, branch_rule), \n                 vars = vars)\n    return tree\nend\n```\n:::\n\n\n## Visualization\n\nAs in the previous example, it makes sense to visualize the forest with a soil\ntile beneath it. Unlike in the previous example, we will construct the soil tile\nusing a dedicated graph and generate a `Scene` object which can later be \nmerged with the rest of scene generated in daily step:\n\n::: {.cell execution_count=23}\n``` {.julia .cell-code}\nBase.@kwdef struct Soil <: VPL.Node\n    length::Float64 \n    width::Float64\nend\nfunction VPL.feed!(turtle::Turtle, s::Soil, vars)\n    Rectangle!(turtle, length = s.length, width = s.width, color = RGB(255/255, 236/255, 179/255))\nend\nsoil_graph = RA(-90.0) + T(Vec(0.0, 10.0, 0.0)) + # Moves into position\n             Soil(length = 20.0, width = 20.0) # Draws the soil tile\nsoil = Scene(Graph(axiom = soil_graph));\nrender(soil, axes = false)\n```\n:::\n\n\nAnd the following function renders the entire scene (notice that we need to\nuse `display()` to force the rendering of the scene when called within a loop\nor a function):\n\n::: {.cell execution_count=24}\n``` {.julia .cell-code}\nfunction render_forest(forest, soil)\n    scene = Scene(vec(forest)) # create scene from forest\n    scene = Scene([scene, soil]) # merges the two scenes\n    display(render(scene))\nend\n```\n:::\n\n\n## Simulation\n\nWe can now create a forest of trees on a regular grid:\n\n::: {.cell execution_count=25}\n``` {.julia .cell-code}\nforest = create_tree.(origins, orientations, RUEs);\nrender_forest(forest, soil)\nstart = 180\nfor i in 1:50\n    println(\"Day $i\")\n    daily_step!(forest, i + start)\n    if mod(i, 5) == 0\n        render_forest(forest, soil)\n    end\nend\n```\n:::\n\n\n",
    "supporting": [
      "index_files\\figure-html"
    ],
    "filters": [],
    "includes": {}
  }
}