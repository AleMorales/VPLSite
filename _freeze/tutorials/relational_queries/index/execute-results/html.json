{
  "hash": "3c9db349330f9b81f710296e4ad93c54",
  "result": {
    "markdown": "---\ntitle: \"Relational queries\"\nauthor: \n    - name: \"Alejandro Morales Sierra\"\n      affiliation: \"Centre for Crop Systems Analysis - Wageningen University\"\ndate: last-modified\nformat: \n    html:\n        code-fold: true\n        code-summary: \"Show the code\"\nexecute: \n  cache: true\n---\n\nIn this example we illustrate how to test relationships among nodes inside queries.\nRelational queries allow to establish relationships between nodes in the graph, \nwhich generally requires a intimiate knowledge of the graph. For this reason,\nrelational queries are inheretly complex as graphs can become complex and there\nmay be solutions that do not require relational queries in many instances.\nNevertheless, they are integral part of VPL and can sometimes be useful. As they\ncan be hard to grasp, this tutorial will illustrate with a relatively simple\ngraph a series of relational queries with increasing complexity with the aim\nthat users will get a better understanding of relational queries. For this purpose, \nan abstract graph with several branching levels will be used, so that we can focus\non the relations among the nodes without being distracted by case-specific details.\n\nThe graph will be composed of two types of nodes: the inner nodes (`A` and `C`) and the \nleaf nodes (`B`). Each leaf node will be identified uniquely with an index and\nthe objective is to write queries that can identify a specific subset of the leaf\nnodes, without using the data stored in the nodes themselves. That is, the queries\nshould select the right nodes based on their relationships to the rest of nodes\nin the graph. Note that `C` nodes contain a single value that may be positive or negative, \nwhereas `A` nodes contain no data.\n\nAs usual, we start with defining the types of nodes in the graph\n\n::: {.cell execution_count=2}\n``` {.julia .cell-code code-fold=\"false\"}\nusing VPL\n\nmodule Queries\n    using VPL\n    struct A <: Node end\n\n    struct C <: Node\n        val::Float64\n    end\n\n    struct B <: Node\n        ID::Int\n    end\nend\nimport .Queries as Q\n```\n:::\n\n\nWe generate the graph directly, rather than with rewriting rules. The graph has\na motif that is repeated three times (with a small variation), so we can create\nthe graph in a piecewise manner. Note how we can use the function `sum` to add\nnodes to the graph (i.e. `sum(A() for i in 1:3)` is equivalent to `A() + A() + A()`)\n\n::: {.cell execution_count=3}\n``` {.julia .cell-code code-fold=\"false\"}\nmotif(n, i = 0) = Q.A() + (Q.C(45.0) + Q.A() + (Q.C(45.0) +  Q.A() + Q.B(i + 1), \n                                           Q.C(-45.0) + Q.A() + Q.B(i + 2), \n                                                       Q.A() + Q.B(i + 3)), \n                         Q.C(- 45.0) + sum(Q.A() for i in 1:n) + Q.B(i + 4))\naxiom =  motif(3, 0) + motif(2, 4) + motif(1, 8) + Q.A() + Q.A() + Q.B(13)\ngraph = Graph(axiom = axiom);\ndraw(graph)\n```\n\n::: {.cell-output .cell-output-display execution_count=3}\n![](index_files/figure-html/cell-3-output-1.png){}\n:::\n:::\n\n\nBy default, VPL will use as node label the type of node and the internal ID generated by VPL itself. This ID is useful if we want to\nextract a particular node from the graph, but it is not controlled by the user. However, the user can specialized the function `node_label()`\nto specify exactly how to label the nodes of a particular type. In this case, we want to just print `A` or `C` for nodes of type `A` and `C`, whereas\nfor nodes of type `B` we want to use the `ID` field that was stored inside the node during the graph generation.\n\n::: {.cell execution_count=4}\n``` {.julia .cell-code}\nVPL.node_label(n::Q.B, id) = \"B-$(n.ID)\"\nVPL.node_label(n::Q.A, id) = \"A\"\nVPL.node_label(n::Q.C, id) = \"C\"\ndraw(graph)\n```\n\n::: {.cell-output .cell-output-display execution_count=4}\n![](index_files/figure-html/cell-4-output-1.png){}\n:::\n:::\n\n\nTo clarify, the `id` argument of the function `node_label()` refers to the internal id generated by VPL (used by the default method for `node_label()`, whereas the the first argument is the data stored inside a node (in the case of `B` nodes, there is a field called `ID` that will not be modified by VPL as that is user-provided data).\n\nThe goal of this exercise is then to write queries that retrieve specific `B` nodes (without using the data stored in the node in the query, that is, we have to identify nodes based on their topological connections to other nodes).\n\n## All nodes of type `B`\n\nFirst, we create the query object. In this case, there is no special condition as\nwe want to retrieve all the nodes of type `B`\n\n::: {.cell execution_count=5}\n``` {.julia .cell-code code-fold=\"false\"}\nQ1 = Query(Q.B)\n```\n\n::: {.cell-output .cell-output-display execution_count=5}\n```\nQuery object for nodes of type Main.Queries.B\n```\n:::\n:::\n\n\nApplying the query to the graph returns an array with all the `B` nodes\n\n::: {.cell execution_count=6}\n``` {.julia .cell-code code-fold=\"false\"}\nA1 = apply(graph, Q1)\n```\n\n::: {.cell-output .cell-output-display execution_count=6}\n```\n13-element Vector{Main.Queries.B}:\n Main.Queries.B(7)\n Main.Queries.B(8)\n Main.Queries.B(3)\n Main.Queries.B(10)\n Main.Queries.B(5)\n Main.Queries.B(6)\n Main.Queries.B(2)\n Main.Queries.B(12)\n Main.Queries.B(1)\n Main.Queries.B(11)\n Main.Queries.B(13)\n Main.Queries.B(9)\n Main.Queries.B(4)\n```\n:::\n:::\n\n\nFor the remainder of this tutorial, the code will be hidden by default to allow users to try on their own.\n\n\n## Node containing value 13\n\nSince the `B` node 13 is the leaf node of the main branch of the graph (e.g. this could be the apical meristem of the main stem of a plant), there\nare no rotations between the root node of the graph and this node. Therefore,\nthe only condition require to single out this node is that it has no ancestor\nnode of type `C`. \n\nChecking whether a node has an ancestor that meets a certain\ncondition can be achieved with the function `hasAncestor()`. Similarly to the \ncondition of the `Query` object, the `hasAncestor()` function also has a condition,\nin this case applied to the parent node of the node being tested, and moving\nupwards in the graph recursively (until reaching the root node). Note that, in\norder to access the object stored inside the node, we need to use the `data()`\nfunction, and then we can test if that object is of type `C`. The `B` node 13\nis the only node for which `hasAncestor()` should return `false`:\n\n::: {.cell execution_count=7}\n``` {.julia .cell-code}\nfunction Q2_fun(n)\n    check, steps = hasAncestor(n, condition = x -> data(x) isa Q.C)\n    !check\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=7}\n```\nQ2_fun (generic function with 1 method)\n```\n:::\n:::\n\n\nAs before, we just need to apply the `Query` object to the graph:\n\n::: {.cell execution_count=8}\n``` {.julia .cell-code}\nQ2 = Query(Q.B, condition = Q2_fun)\nA2 = apply(graph, Q2)\n```\n\n::: {.cell-output .cell-output-display execution_count=8}\n```\n1-element Vector{Main.Queries.B}:\n Main.Queries.B(13)\n```\n:::\n:::\n\n\n## Nodes containing values 1, 2 and 3  \n\nThese three nodes belong to one of the branch motifs repeated through the graph. Thus,\nwe need to identify the specific motif they belong to and chose all the `B` nodes\ninside that motif. The motif is defined by an `A` node that has a `C` child with\na negative `val` and parent node `C` with positive `val`. This `A` node \nshould then be 2 nodes away from the root node to separate it from upper repetitions\nof the motif.\nTherefore, we need to test for two conditions, first find those nodes inside a \nbranch motif, then retrieve the root of the branch motif (i.e., the `A` node \ndescribed in the above) and then check the distance of that node from the root:\n\n::: {.cell execution_count=9}\n``` {.julia .cell-code}\nfunction branch_motif(p)\n    data(p) isa Q.A && \n    hasDescendent(p, condition = x -> data(x) isa Q.C && data(x).val < 0.0) &&\n    hasAncestor(p, condition = x -> data(x) isa Q.C && data(x).val > 0.0)[1]\nend\n\nfunction Q3_fun(n, nsteps)\n    # Condition 1\n    check, steps = hasAncestor(n, condition = branch_motif)\n    !check && return false\n    # Condition 2\n    p = parent(n, nsteps = steps)\n    check, steps = hasAncestor(p, condition = isRoot)\n    steps != nsteps && return false\n    return true\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=9}\n```\nQ3_fun (generic function with 1 method)\n```\n:::\n:::\n\n\nAnd applying the query to the object results in the required nodes:\n\n::: {.cell execution_count=10}\n``` {.julia .cell-code}\nQ3 = Query(Q.B, condition = n -> Q3_fun(n, 2))\nA3 = apply(graph, Q3)\n```\n\n::: {.cell-output .cell-output-display execution_count=10}\n```\n3-element Vector{Main.Queries.B}:\n Main.Queries.B(3)\n Main.Queries.B(2)\n Main.Queries.B(1)\n```\n:::\n:::\n\n\n## Node containing value 4   \n\nThe node `B` with value 4 can be singled-out because there is no branching point\nbetween the root node and this node. This means that no ancestor node should have\nmore than one children node except the root node. Remember that `hasAncestor()`\nreturns two values, but we are only interested in the first value. You do not need to \nassign the returned object from a Julia function, you can just index directly the element\nto be selected from the returned tuple:\n\n::: {.cell execution_count=11}\n``` {.julia .cell-code}\nfunction Q4_fun(n)\n    !hasAncestor(n, condition = x -> !isRoot(x) && length(children(x)) > 1)[1]\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=11}\n```\nQ4_fun (generic function with 1 method)\n```\n:::\n:::\n\n\nAnd applying the query to the object results in the required node:\n\n::: {.cell execution_count=12}\n``` {.julia .cell-code}\nQ4 = Query(Q.B, condition = Q4_fun)\nA4 = apply(graph, Q4)\n```\n\n::: {.cell-output .cell-output-display execution_count=12}\n```\n1-element Vector{Main.Queries.B}:\n Main.Queries.B(4)\n```\n:::\n:::\n\n\n## Node containing value 3  \n\nThis node is the only `B` node that is four steps from the root node, which we can\nretrieve from the second argument returned by `hasAncestor()`:\n\n::: {.cell execution_count=13}\n``` {.julia .cell-code}\nfunction Q5_fun(n)\n    check, steps = hasAncestor(n, condition = isRoot)\n    steps == 4\nend\n\nQ5 = Query(Q.B, condition = Q5_fun)\nA5 = apply(graph, Q5)\n```\n\n::: {.cell-output .cell-output-display execution_count=13}\n```\n1-element Vector{Main.Queries.B}:\n Main.Queries.B(3)\n```\n:::\n:::\n\n\n## Node containing value 7  \n\nNode `B` 7 belongs to the second lateral branch motif and the second parent\nnode is of type `A`. Note that we can reuse the `Q3_fun` from before in the \ncondition required for this node:\n\n::: {.cell execution_count=14}\n``` {.julia .cell-code}\nfunction Q6_fun(n, nA)\n    check = Q3_fun(n, nA)\n    !check && return false\n    p2 = parent(n, nsteps = 2)\n    data(p2) isa Q.A\nend\n\nQ6 = Query(Q.B, condition = n -> Q6_fun(n, 3))\nA6 = apply(graph, Q6)\n```\n\n::: {.cell-output .cell-output-display execution_count=14}\n```\n1-element Vector{Main.Queries.B}:\n Main.Queries.B(7)\n```\n:::\n:::\n\n\n## Nodes containing values 11 and 13  \n\nThe `B` nodes 11 and 13 actually have different relationships to the rest of the graph,\nso we just need to define two different condition functions and combine them.\nThe condition for the `B` node 11 is similar to the `B` node 7, whereas the condition\nfor node 13 was already constructed before, so we just need to combined them with an\nOR operator:\n\n::: {.cell execution_count=15}\n``` {.julia .cell-code}\nQ7 = Query(Q.B, condition = n -> Q6_fun(n, 4) || Q2_fun(n))\nA7 = apply(graph, Q7)\n```\n\n::: {.cell-output .cell-output-display execution_count=15}\n```\n2-element Vector{Main.Queries.B}:\n Main.Queries.B(11)\n Main.Queries.B(13)\n```\n:::\n:::\n\n\n## Nodes containing values 1, 5 and 9  \n\nThese nodes play the same role in the three lateral branch motifs. They are the\nonly `B` nodes preceded by the sequence A C+ A. We just need to check the\nsequence og types of objects for the the first three parents of each `B` node:\n\n::: {.cell execution_count=16}\n``` {.julia .cell-code}\nfunction Q8_fun(n)\n    p1 = parent(n)\n    p2 = parent(n, nsteps = 2)\n    p3 = parent(n, nsteps = 3)\n    data(p1) isa Q.A && data(p2) isa Q.C && data(p2).val > 0.0 && data(p3) isa Q.A\nend\n\nQ8 = Query(Q.B, condition = Q8_fun)\nA8 = apply(graph, Q8)\n```\n\n::: {.cell-output .cell-output-display execution_count=16}\n```\n3-element Vector{Main.Queries.B}:\n Main.Queries.B(5)\n Main.Queries.B(1)\n Main.Queries.B(9)\n```\n:::\n:::\n\n\n## Nodes contaning values 2, 6 and 10  \n\nThis exercise is similar to the previous one, but the C node has a negative\n`val`. The problem is that node 12 would also match the pattern A C- A. We\ncan differentiate between this node and the rest by checking for a fourth \nancestor node of class `C`:\n\n::: {.cell execution_count=17}\n``` {.julia .cell-code}\nfunction Q9_fun(n)\n    p1 = parent(n)\n    p2 = parent(n, nsteps = 2)\n    p3 = parent(n, nsteps = 3)\n    p4 = parent(n, nsteps = 4)\n    data(p1) isa Q.A && data(p2) isa Q.C && data(p2).val < 0.0 && \n       data(p3) isa Q.A && data(p4) isa Q.C\nend\n\nQ9 = Query(Q.B, condition = Q9_fun)\nA9 = apply(graph, Q9)\n```\n\n::: {.cell-output .cell-output-display execution_count=17}\n```\n3-element Vector{Main.Queries.B}:\n Main.Queries.B(10)\n Main.Queries.B(6)\n Main.Queries.B(2)\n```\n:::\n:::\n\n\n## Nodes containg values 6, 7 and 8  \n\nWe already came up with a condition to extract node 7. We can also modify the previous\ncondition so that it only node 6.  Node 8 can be identified by checking for the third \nparent node being of type `C` and being 5 nodes from the root of the graph.\n\nAs always, we can reusing previous conditions since they are just regular Julia functions:\n\n::: {.cell execution_count=18}\n``` {.julia .cell-code}\nfunction Q10_fun(n)\n    Q6_fun(n, 3) && return true # Check node 7\n    Q9_fun(n) && hasAncestor(n, condition = isRoot)[2] == 6 && return true # Check node 6\n    hasAncestor(n, condition = isRoot)[2] == 5 && data(parent(n, nsteps = 3)) isa Q.C && return true # Check node 8 (and not 4!)\nend\n\nQ10 = Query(Q.B, condition = Q10_fun)\nA10 = apply(graph, Q10)\n```\n\n::: {.cell-output .cell-output-display execution_count=18}\n```\n3-element Vector{Main.Queries.B}:\n Main.Queries.B(7)\n Main.Queries.B(8)\n Main.Queries.B(6)\n```\n:::\n:::\n\n\n## Nodes containig values 3, 7, 11 and 12  \n\nWe already have conditions to select nodes 3, 7 and 11 so we just need a new condition\nfor node 12 (similar to the condition for 8).\n\n::: {.cell execution_count=19}\n``` {.julia .cell-code}\nfunction Q11_fun(n)\n    Q5_fun(n) && return true # 3\n    Q6_fun(n, 3) && return true # 7\n    Q6_fun(n, 4) && return true # 11\n    hasAncestor(n, condition = isRoot)[2] == 5 && data(parent(n, nsteps = 2)) isa Q.C && \n        data(parent(n, nsteps = 4)) isa Q.A && return true # 12\nend\n\nQ11 = Query(Q.B, condition = Q11_fun)\nA11 = apply(graph, Q11)\n```\n\n::: {.cell-output .cell-output-display execution_count=19}\n```\n4-element Vector{Main.Queries.B}:\n Main.Queries.B(7)\n Main.Queries.B(3)\n Main.Queries.B(12)\n Main.Queries.B(11)\n```\n:::\n:::\n\n\n## Nodes containing values 7 and 12 \n\nWe just need to combine the conditions for the nodes 7 and 12\n\n::: {.cell execution_count=20}\n``` {.julia .cell-code}\nfunction Q12_fun(n)\n    Q6_fun(n, 3) && return true # 7\n    hasAncestor(n, condition = isRoot)[2] == 5 && data(parent(n, nsteps = 2)) isa Q.C && \n        data(parent(n, nsteps = 4)) isa Q.A && return true # 12\nend\n\nQ12 = Query(Q.B, condition = Q12_fun)\nA12 = apply(graph, Q12)\n```\n\n::: {.cell-output .cell-output-display execution_count=20}\n```\n2-element Vector{Main.Queries.B}:\n Main.Queries.B(7)\n Main.Queries.B(12)\n```\n:::\n:::\n\n\n",
    "supporting": [
      "index_files\\figure-html"
    ],
    "filters": [],
    "includes": {}
  }
}