{
  "hash": "12f0efb7ed2a65e10b2257f9a4934fd1",
  "result": {
    "markdown": "---\ntitle: \"Forest\"\nauthor: \n    - name: \"Alejandro Morales Sierra\"\n      affiliation: \"Centre for Crop Systems Analysis - Wageningen University\"\ndate: last-modified\nexecute: \n  cache: true\n---\n\nIn this example we extend the tree example into a forest, where\neach tree is described by a separate graph object and parameters driving the\ngrowth of these trees vary across individuals following a predefined distribution.\nThis tutorial requires using the Distributions.jl package:\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nimport Pkg\nPkg.add(\"Distributions\")\nPkg.add(\"Plots\")\n```\n:::\n\n\nThe data types, rendering methods and growth rules are the same as in the binary\ntree example:\n\n::: {.cell execution_count=2}\n``` {.julia .cell-code}\nusing VPL\nusing Distributions, Plots\n# Data types\nmodule TreeTypes\n    import VPL\n    # Meristem\n    struct Meristem <: VPL.Node end\n    # Bud\n    struct Bud <: VPL.Node end\n    # Node\n    struct Node <: VPL.Node end\n    # BudNode\n    struct BudNode <: VPL.Node end\n    # Internode (needs to be mutable to allow for changes over time)\n    Base.@kwdef mutable struct Internode <: VPL.Node\n        length::Float64 = 0.10 # Internodes start at 10 cm\n    end\n    # Leaf\n    Base.@kwdef struct Leaf <: VPL.Node\n        length::Float64 = 0.20 # Leaves are 20 cm long\n        width::Float64  = 0.1 # Leaves are 10 cm wide\n    end    \n    # Graph-level variables\n    Base.@kwdef struct treeparams\n        growth::Float64 = 0.1   \n        budbreak::Float64 = 0.25\n        phyllotaxis::Float64 = 140.0\n        leaf_angle::Float64 = 30.0\n        branch_angle::Float64 = 45.0\n    end\nend\n\nimport .TreeTypes\n\n# Create geometry + color for the internodes\nfunction VPL.feed!(turtle::Turtle, i::TreeTypes.Internode, vars)\n    # Rotate turtle around the head to implement elliptical phyllotaxis\n    rh!(turtle, vars.phyllotaxis) \n    HollowCylinder!(turtle, length = i.length, height = i.length/15, width = i.length/15, \n                move = true, color = RGB(0.5,0.4,0.0))\n    return nothing\nend\n\n# Create geometry + color for the leaves\nfunction VPL.feed!(turtle::Turtle, l::TreeTypes.Leaf, vars)\n    # Rotate turtle around the arm for insertion angle\n    ra!(turtle, -vars.leaf_angle)\n    # Generate the leaf \n    Ellipse!(turtle, length = l.length, width = l.width, move = false, \n             color = RGB(0.2,0.6,0.2))\n    # Rotate turtle back to original direction\n    ra!(turtle, vars.leaf_angle)\n    return nothing\nend\n\n# Insertion angle for the bud nodes\nfunction VPL.feed!(turtle::Turtle, b::TreeTypes.BudNode, vars)\n    # Rotate turtle around the arm for insertion angle\n    ra!(turtle, -vars.branch_angle)\nend\n\n\n# Rules\nmeristem_rule = Rule(TreeTypes.Meristem, rhs = mer -> TreeTypes.Node() + \n                                              (TreeTypes.Bud(), TreeTypes.Leaf()) +\n                                         TreeTypes.Internode() + TreeTypes.Meristem())\n\nfunction prob_break(bud)\n    # We move to parent node in the branch where the bud was created\n    node =  parent(bud)\n    # We count the number of internodes between node and the first Meristem \n    # moving down the graph\n    check, steps = hasDescendent(node, condition = n -> data(n) isa TreeTypes.Meristem)\n    steps = Int(ceil(steps/2)) # Because it will count both the nodes and the internodes\n    # Compute probability of bud break and determine whether it happens\n    if check\n        prob =  min(1.0, steps*vars(bud).budbreak)\n        return rand() < prob\n    # If there is no meristem, an error happened since the model does not allow for this    \n    else\n        error(\"No meristem found in branch\")\n    end\nend\nbranch_rule = Rule(TreeTypes.Bud, \n            lhs = prob_break, \n            rhs = bud -> TreeTypes.BudNode() + TreeTypes.Internode() + TreeTypes.Meristem())\n```\n\n::: {.cell-output .cell-output-display execution_count=2}\n```\nRule replacing nodes of type Main.TreeTypes.Bud without context capturing.\n```\n:::\n:::\n\n\nThe main difference with respect to the tree is that several of the parameters\nwill vary per TreeTypes. Also, the location of the tree and initial orientation of \nthe turtle will also vary. To achieve this we need to:\n\n(i) Add two additional initial nodes that move the turtle to the starting position\nof each tree and rotates it.\n\n(ii) Wrap the axiom, rules and the creation of the graph into a function that \ntakes the required parameters as inputs.\n\n::: {.cell execution_count=3}\n``` {.julia .cell-code}\nfunction create_tree(origin, growth, budbreak, orientation)\n    axiom = T(origin) + RH(orientation) + TreeTypes.Internode() + TreeTypes.Meristem()\n    tree =  Graph(axiom = axiom, rules = (meristem_rule, branch_rule), \n                  vars = TreeTypes.treeparams(growth = growth, budbreak = budbreak))\n    return tree\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=3}\n```\ncreate_tree (generic function with 1 method)\n```\n:::\n:::\n\n\nThe code for elongating the internodes to simulate growth remains the same as for\nthe binary tree example\n\n::: {.cell execution_count=4}\n``` {.julia .cell-code}\ngetInternode = Query(TreeTypes.Internode)\n\nfunction elongate!(tree, query)\n    for x in apply(tree, query)\n        x.length = x.length*(1.0 + vars(tree).growth)\n    end\nend\n\nfunction growth!(tree, query)\n    elongate!(tree, query)\n    rewrite!(tree)\nend\n\nfunction simulate(tree, query, nsteps)\n    new_tree = deepcopy(tree)\n    for i in 1:nsteps\n        growth!(new_tree, query)\n    end\n    return new_tree\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=4}\n```\nsimulate (generic function with 1 method)\n```\n:::\n:::\n\n\nLet's simulate a forest of 10 x 10 trees with a distance between (and within) rows\nof 2 meters. First we generate the original positions of the trees. For the \nposition we just need to pass a `Vec` object with the x, y, and z coordinates of \nthe location of each TreeTypes. The code below will generate a matrix with the coordinates:\n\n::: {.cell execution_count=5}\n``` {.julia .cell-code}\norigins = [Vec(i,j,0) for i = 1:2.0:20.0, j = 1:2.0:20.0]\n```\n\n::: {.cell-output .cell-output-display execution_count=5}\n```\n10×10 Matrix{StaticArraysCore.SVector{3, Float64}}:\n [1.0, 1.0, 0.0]   [1.0, 3.0, 0.0]   [1.0, 5.0, 0.0]   …  [1.0, 19.0, 0.0]\n [3.0, 1.0, 0.0]   [3.0, 3.0, 0.0]   [3.0, 5.0, 0.0]      [3.0, 19.0, 0.0]\n [5.0, 1.0, 0.0]   [5.0, 3.0, 0.0]   [5.0, 5.0, 0.0]      [5.0, 19.0, 0.0]\n [7.0, 1.0, 0.0]   [7.0, 3.0, 0.0]   [7.0, 5.0, 0.0]      [7.0, 19.0, 0.0]\n [9.0, 1.0, 0.0]   [9.0, 3.0, 0.0]   [9.0, 5.0, 0.0]      [9.0, 19.0, 0.0]\n [11.0, 1.0, 0.0]  [11.0, 3.0, 0.0]  [11.0, 5.0, 0.0]  …  [11.0, 19.0, 0.0]\n [13.0, 1.0, 0.0]  [13.0, 3.0, 0.0]  [13.0, 5.0, 0.0]     [13.0, 19.0, 0.0]\n [15.0, 1.0, 0.0]  [15.0, 3.0, 0.0]  [15.0, 5.0, 0.0]     [15.0, 19.0, 0.0]\n [17.0, 1.0, 0.0]  [17.0, 3.0, 0.0]  [17.0, 5.0, 0.0]     [17.0, 19.0, 0.0]\n [19.0, 1.0, 0.0]  [19.0, 3.0, 0.0]  [19.0, 5.0, 0.0]     [19.0, 19.0, 0.0]\n```\n:::\n:::\n\n\nWe may assume that the initial orientation is uniformly distributed between 0 and 360 degrees:\n\n::: {.cell execution_count=6}\n``` {.julia .cell-code}\norientations = [rand()*360.0 for i = 1:2.0:20.0, j = 1:2.0:20.0]\n```\n\n::: {.cell-output .cell-output-display execution_count=6}\n```\n10×10 Matrix{Float64}:\n  27.2394   154.296    162.521   113.22    …   76.6013  173.924    73.7872\n 245.883    116.24     134.826    19.548       66.1573  351.229    33.7842\n   1.34475  331.04     162.612   144.042       12.9932  354.268   266.823\n 246.113    323.081    241.702   135.583      116.74    336.492   134.127\n 147.595    160.24     168.138   182.911       35.8897  285.26     31.8624\n   4.34266    3.14685  344.979   135.261   …  256.206    70.0738  281.339\n  84.2829   308.832    111.606    50.7506     353.403   244.852   300.688\n  94.7387   209.314     91.1912  120.355       92.0456  323.353    26.5338\n  51.3843   135.731    256.809   145.749      171.177   303.278   209.693\n  29.8936   131.392    185.185   152.757      333.609    43.3001  165.296\n```\n:::\n:::\n\n\nFor the `growth` and `budbreak` parameters we will assumed that they follow a \nLogNormal and Beta distribution, respectively. We can generate random\nvalues from these distributions using the `Distributions` package. For the\nrelative growth rate:\n\n::: {.cell execution_count=7}\n``` {.julia .cell-code}\ngrowths = rand(LogNormal(-2, 0.3), 10, 10)\nhistogram(vec(growths))\n```\n\n::: {.cell-output .cell-output-display execution_count=7}\n![](index_files/figure-html/cell-8-output-1.svg){}\n:::\n:::\n\n\nAnd for the budbreak parameter:\n\n::: {.cell execution_count=8}\n``` {.julia .cell-code}\nbudbreaks = rand(Beta(2.0, 10), 10, 10)\nhistogram(vec(budbreaks))\n```\n\n::: {.cell-output .cell-output-display execution_count=8}\n![](index_files/figure-html/cell-9-output-1.svg){}\n:::\n:::\n\n\nNow we can create our forest by calling the `create_tree` function we defined earlier\nwith the correct inputs per tree:\n\n::: {.cell execution_count=9}\n``` {.julia .cell-code}\nforest = vec(create_tree.(origins, growths, budbreaks, orientations));\n```\n:::\n\n\nBy vectorizing `create_tree()` over the different arrays, we end up with an array\nof trees. Each tree is a different Graph, with its own nodes, rewriting rules \nand variables. This avoids having to create a large graphs to include all the \nplants in a simulation. Below we will run a simulation, first using a sequential\napproach (i.e. using one core) and then using multiple cores in our computers (please check\nhttps://docs.julialang.org/en/v1/manual/multi-threading/ if the different cores are not being used\nas you may need to change some settings in your computer).\n\n## Sequential simulation\n\nWe can simulate the growth of each tree by applying the method `simulate` to each\ntree, creating a new version of the forest (the code below is an array comprehension)\n\n::: {.cell execution_count=10}\n``` {.julia .cell-code}\nnewforest = [simulate(tree, getInternode, 2) for tree in forest];\n```\n:::\n\n\nAnd we can render the forest with the function `render` as in the binary tree\nexample but passing the whole forest at once\n\n::: {.cell execution_count=11}\n``` {.julia .cell-code}\nrender(newforest)\n```\n\n::: {.cell-output .cell-output-display execution_count=11}\n![](index_files/figure-html/cell-12-output-1.png){}\n:::\n:::\n\n\nIf we iterate 4 more iterations we will start seeing the different individuals\ndiverging in size due to the differences in growth rates\n\n::: {.cell execution_count=12}\n``` {.julia .cell-code}\nnewforest = [simulate(tree, getInternode, 15) for tree in newforest];\nrender(newforest)\n```\n\n::: {.cell-output .cell-output-display execution_count=12}\n![](index_files/figure-html/cell-13-output-1.png){}\n:::\n:::\n\n\n## Multithreaded simulation\n\nIn the previous section, the simulation of growth was done sequentially, one tree\nafter another (since the growth of a tree only depends on its own parameters). However,\nthis can also be executed in multiple threads. In this case we use an explicit loop \nand execute the iterations of the loop in multiple threads using the macro `@threads`.\nNote that the rendering function can also be ran in parallel (i.e. the geometry will be\ngenerated separately for each plant and the merge together):\n\n::: {.cell execution_count=13}\n``` {.julia .cell-code}\nusing Base.Threads\nnewforest = deepcopy(forest)\n@threads for i in 1:length(forest)\n    newforest[i] = simulate(forest[i], getInternode, 6)\nend\nrender(newforest, parallel = true)\n```\n\n::: {.cell-output .cell-output-display execution_count=13}\n![](index_files/figure-html/cell-14-output-1.png){}\n:::\n:::\n\n\nAn alternative way to perform the simulation is to have an outer loop for each timestep and an internal loop over the different trees. Although this approach is not required for this simple model, most FSP models will probably need such a scheme as growth of each individual plant will depend on competition for resources with neighbouring plants. In this case, this approach would look as follows:\n\n::: {.cell execution_count=14}\n``` {.julia .cell-code}\nnewforest = deepcopy(forest)\nfor step in 1:15\n    @threads for i in 1:length(newforest)\n        newforest[i] = simulate(newforest[i], getInternode, 1)\n    end\nend\nrender(newforest, parallel = true)\n```\n\n::: {.cell-output .cell-output-display execution_count=14}\n![](index_files/figure-html/cell-15-output-1.png){}\n:::\n:::\n\n\n# Customizing the scene\n\nHere we are going to customize the scene of our simulation by adding a horizontal tile represting soil and\ntweaking the 3D representation. When we want to combine plants generated from graphs with any other\ngeometric element it is best to combine all these geometries in a `GLScene` object. We can start the scene\nwith the `newforest` generated in the above:\n\n::: {.cell execution_count=15}\n``` {.julia .cell-code}\nscene = Scene(newforest);\n```\n:::\n\n\nWe can create the soil tile directly, without having to create a graph. The simplest approach is two use \na special constructor `Rectangle` where one species a corner of the rectangle and two vectors defining the\ntwo sides of the vectors. Both the sides and the corner need to be specified with `Vec` just like in the\nabove when we determined the origin of each plant. VPL offers some shortcuts: `O()` returns the origin\n(`Vec(0.0, 0.0, 0.0)`), whereas `X`, `Y` and `Z` returns the corresponding axes and you can scale them by \npassing the desired length as input. Below, a rectangle is created on the XY plane with the origin as a \ncorner and each side being 11 units long:\n\n::: {.cell execution_count=16}\n``` {.julia .cell-code}\nsoil = Rectangle(length = 21.0, width = 21.0)\nrotatey!(soil, pi/2)\nVPL.translate!(soil, Vec(0.0, 10.5, 0.0))\n```\n:::\n\n\nWe can now add the `soil` to the `scene` object with the `add!` function.\n\n::: {.cell execution_count=17}\n``` {.julia .cell-code}\nVPL.add!(scene, mesh = soil, color = RGB(1,1,0))\n```\n:::\n\n\nWe can now render the scene that combines the random forest of binary trees and a yellow soil. Notice that\nin all previous figures, a coordinate system with grids was being depicted. This is helpful for debugging\nyour code but also to help setup the scene (e.g. if you are not sure how big the soil tile should be).\nHowver, it may be distracting for the visualization. It turns out that we can turn that off with\n`show_axes = false`:\n\n::: {.cell execution_count=18}\n``` {.julia .cell-code}\nrender(scene, axes = false)\n```\n\n::: {.cell-output .cell-output-display execution_count=18}\n![](index_files/figure-html/cell-19-output-1.png){}\n:::\n:::\n\n\nWe may also want to save a screenshot of the scene. For this, we need to store the output of the `render` function.\nWe can then resize the window rendering the scene, move around, zoom, etc. When we have a perspective that we like,\nwe can run the `save_scene` function on the object returned from `render`. The argument `resolution` can be adjusted in both\n`render` to increase the number of pixels in the final image. A helper function `calculate_resolution` is provided to \ncompute the resolution from a physical width and height in cm and a dpi (e.g., useful for publications and posters):\n\n::: {.cell execution_count=19}\n``` {.julia .cell-code}\nres = calculate_resolution(width = 16.0, height = 16.0, dpi = 1_000)\noutput = render(scene, axes = false, resolution = res)\nexport_scene(scene = output, filename = \"nice_trees.png\") \n```\n:::\n\n\n",
    "supporting": [
      "index_files\\figure-html"
    ],
    "filters": [],
    "includes": {}
  }
}