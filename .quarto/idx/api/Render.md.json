{"title":"Module Render","markdown":{"headingText":"Module Render","containsRefs":false,"markdown":"\n<a id='Module-Render'></a>\n\n<a id='Module-Render-1'></a>\n\n\n\n\n\n<a id='Scenes-for-rendering'></a>\n\n<a id='Scenes-for-rendering-1'></a>\n\n## Scenes for rendering\n\n<a id='VPL.Render.GLScene' href='#VPL.Render.GLScene'>#</a>\n**`VPL.Render.GLScene`** &mdash; *Type*.\n\n\n\n```julia\nGLScene(mesh, colors)\n```\n\nCreate a 3D scene for rendering from a `Mesh` object (`m`) and colors associated to the different  primitives (`colors`). This method is useful when the user has generated separately the 3D mesh and array with colors, as otherwise other methods of `GLScene()` will be more useful.\n\n\n<a target='_blank' href='https://github.com/AleMorales/VPL.jl/blob/95b9ec3af8f79b223271d3a3a2886919076df5ea/src/Render/Scene.jl#LL1-L7' class='documenter-source'>source</a><br>\n\n<a id='VPL.add!-Tuple{Any}' href='#VPL.add!-Tuple{Any}'>#</a>\n**`VPL.add!`** &mdash; *Method*.\n\n\n\n```julia\nadd!(scene; mesh, color)\n```\n\nManually add a 3D mesh with corresponding colors (`mesh` and `color`) to an  existing `GLScene` object (`scene`).\n\n\n<a target='_blank' href='https://github.com/AleMorales/VPL.jl/blob/95b9ec3af8f79b223271d3a3a2886919076df5ea/src/Render/Scene.jl#LL72-L77' class='documenter-source'>source</a><br>\n\n\n<a id='Rendering-methods'></a>\n\n<a id='Rendering-methods-1'></a>\n\n## Rendering methods\n\n<a id='VPL.Render.GLTurtle' href='#VPL.Render.GLTurtle'>#</a>\n**`VPL.Render.GLTurtle`** &mdash; *Type*.\n\n\n\n```julia\nGLTurtle(colors, message)\n```\n\nCreate a `GLTurtle()` object that will parse a `Graph` object and store the colors associated to the different primitives. This type of turtle is automatically created by calls to `GLScene()` and `render()` but the user may want to separately construct the geometry and colors and manually combine them into a `GLScene` object for  performance reasons. The argument `message` is any user-defined object.\n\n\n<a target='_blank' href='https://github.com/AleMorales/VPL.jl/blob/95b9ec3af8f79b223271d3a3a2886919076df5ea/src/Render/Turtle.jl#LL2-L10' class='documenter-source'>source</a><br>\n\n<a id='VPL.Render.colors-Tuple{VPL.Render.GLTurtle}' href='#VPL.Render.colors-Tuple{VPL.Render.GLTurtle}'>#</a>\n**`VPL.Render.colors`** &mdash; *Method*.\n\n\n\n```julia\ncolors(turtle)\n```\n\nExtract the array of colors stored inside an `GLTurtle` object\n\n\n<a target='_blank' href='https://github.com/AleMorales/VPL.jl/blob/95b9ec3af8f79b223271d3a3a2886919076df5ea/src/Render/Turtle.jl#LL16-L20' class='documenter-source'>source</a><br>\n\n<a id='VPL.Render.feedcolor!' href='#VPL.Render.feedcolor!'>#</a>\n**`VPL.Render.feedcolor!`** &mdash; *Function*.\n\n\n\n```julia\nfeedcolor!(turtle::GLTurtle, color::Colorant)\n```\n\nGeneral purpose method to feed a color to a GL turtle. This should be used inside user's defined methods to add any color object that inherits from `Colorant` from the package *Color*, for example, by using `RGB()`.\n\n\n<a target='_blank' href='https://github.com/AleMorales/VPL.jl/blob/95b9ec3af8f79b223271d3a3a2886919076df5ea/src/Render/Turtle.jl#LL23-L29' class='documenter-source'>source</a><br>\n\n\n```\nfeedcolor!(turtle::GLTurtle, node::Node)\n```\n\nDefault method for `feedcolor!()` that does not do anything. Hence, the user can include nodes in a graph withour associated colors (the nodes should not generate geometry either).\n\n\n<a target='_blank' href='https://github.com/AleMorales/VPL.jl/blob/95b9ec3af8f79b223271d3a3a2886919076df5ea/src/Render/Turtle.jl#LL32-L37' class='documenter-source'>source</a><br>\n\n\n```\nfeedcolor!(turtle::GLTurtle, g::Graph)\n```\n\nProcess a `Graph` object with a GL turtle and collect the colors defined in the graph, in the same order in which the 3D mesh is created by the corresponding `feedgeom!()` method.\n\n\n<a target='_blank' href='https://github.com/AleMorales/VPL.jl/blob/95b9ec3af8f79b223271d3a3a2886919076df5ea/src/Render/Turtle.jl#LL40-L45' class='documenter-source'>source</a><br>\n\n\n```\nfeedcolor!(turtle::GLTurtle, collection::AbstractArray)\nfeedcolor!(turtle::GLTurtle, collection::Tuple)\n```\n\nFeed a GL turtle an array or tuple of objects (`collection`) with existing `feedcolor!()` methods.\n\n\n<a target='_blank' href='https://github.com/AleMorales/VPL.jl/blob/95b9ec3af8f79b223271d3a3a2886919076df5ea/src/Render/Turtle.jl#LL70-L75' class='documenter-source'>source</a><br>\n\n<a id='VPL.Render.render' href='#VPL.Render.render'>#</a>\n**`VPL.Render.render`** &mdash; *Function*.\n\n\n\n```julia\nrender(m::Mesh; kwargs...)\n```\n\nRender a mesh. This will create a new visualization (see Documentation for  details). Keyword arguments are passed to the `render(scene::GLScene)` method  and any unmatched keywords will be passed along to `Makie.mesh()`.\n\n\n<a target='_blank' href='https://github.com/AleMorales/VPL.jl/blob/95b9ec3af8f79b223271d3a3a2886919076df5ea/src/Render/Render.jl#LL6-L12' class='documenter-source'>source</a><br>\n\n\n```\nrender(scene::GLScene; normals::Bool = false, wireframe::Bool = false, kwargs...)\n```\n\nRender a `GLScene` object. This will create a new visualization (see  Documentation for details). `normals = true` will draw arrows in the direction  of the normal vector for each triangle in the mesh, `wireframe = true` will draw  the edges of each triangle with black lines. Keyword arguments are passed to  `Makie.mesh()`.\n\n\n<a target='_blank' href='https://github.com/AleMorales/VPL.jl/blob/95b9ec3af8f79b223271d3a3a2886919076df5ea/src/Render/Render.jl#LL63-L71' class='documenter-source'>source</a><br>\n\n\n```\nrender(graph::Graph, Float64; normals::Bool = false, message = nothing,\n       wireframe::Bool = false, kwargs...)\n```\n\nRender the 3D mesh associated to a `Graph` object. This will create a new  visualization (see Documentation for details). `normals = true` will draw arrows  in the direction of the normal vector for each triangle in the mesh,  `wireframe = true` will draw the edges of each triangle with black lines.  Keyword arguments are passed to `Makie.mesh()`. The argument `message` is any user-defined object that will be stored in the turtles and hence available  within the `feedgeom!` and `feedcolor!` methods. By default, double  floating precision will be used (`Float64`) but it is possible to generate a  version with a different precision by specifying the corresponding type as in  `render(graph, Float32)`.\n\n\n<a target='_blank' href='https://github.com/AleMorales/VPL.jl/blob/95b9ec3af8f79b223271d3a3a2886919076df5ea/src/Render/Render.jl#LL77-L91' class='documenter-source'>source</a><br>\n\n\n```\nrender(graphs::Vector{<:Graph}, Float64; normals::Bool = false, \n       wireframe::Bool = false, messsage = nothing, kwargs...)\n```\n\nRender the 3D mesh associated to an array of `Graph` objects. This will create a  new visualization (see Documentation for details). `normals = true` will draw  arrows in the direction of the normal vector for each triangle in the mesh,  `wireframe = true` will draw the edges of each triangle with black lines.  Keyword arguments are passed to `Makie.mesh()`. The argument `message` is any user-defined object that will be stored in the turtles and hence available  within the `feedgeom!` and `feedcolor!` methods. By default, double  floating precision will be used (`Float64`) but it is possible to generate a  version with a different precision by specifying the corresponding type as in  `render(graphs, Float32)`.\n\n\n<a target='_blank' href='https://github.com/AleMorales/VPL.jl/blob/95b9ec3af8f79b223271d3a3a2886919076df5ea/src/Render/Render.jl#LL98-L112' class='documenter-source'>source</a><br>\n\n<a id='VPL.Render.render!' href='#VPL.Render.render!'>#</a>\n**`VPL.Render.render!`** &mdash; *Function*.\n\n\n\n```julia\nrender!(source::Source{G, A, nw}; n = 20, alpha = 0.2)\n```\n\nAdd a mesh representing the light source to a 3D scene. For each type of light source a triangular mesh will be created, where `n` is the number of triangles (see documentation of geometric primitives for details) and `alpha` is the transparency to be used for each triangle.\n\n\n<a target='_blank' href='https://github.com/AleMorales/VPL.jl/blob/95b9ec3af8f79b223271d3a3a2886919076df5ea/src/Raytracer/Render.jl#LL4-L11' class='documenter-source'>source</a><br>\n\n\n```\nrender!(grid::GridCloner; alpha = 0.2)\n```\n\nAdd a mesh representing the bounding boxes of the grid cloner to a 3D scene,  where `alpha` represents the transparency of each box.\n\n\n<a target='_blank' href='https://github.com/AleMorales/VPL.jl/blob/95b9ec3af8f79b223271d3a3a2886919076df5ea/src/Raytracer/Render.jl#LL27-L32' class='documenter-source'>source</a><br>\n\n\n```\nrender!(m::Mesh; kwargs...)\n```\n\nAdd a mesh to the visualization currently active. This will create a new  visualization (see Documentation for details). Keyword arguments are passed to  the `render!(scene::GLScene)` method and any unmatched keywords will be passed  along to `Makie.mesh!()`.\n\n\n<a target='_blank' href='https://github.com/AleMorales/VPL.jl/blob/95b9ec3af8f79b223271d3a3a2886919076df5ea/src/Render/Render.jl#LL17-L24' class='documenter-source'>source</a><br>\n\n<a id='VPL.Render.export_scene-Tuple{}' href='#VPL.Render.export_scene-Tuple{}'>#</a>\n**`VPL.Render.export_scene`** &mdash; *Method*.\n\n\n\n```julia\nexport_scene(;scene, filename, kwargs...)\n```\n\nExport a screenshot of the current visualization (stored as `scene` as output of a call to `render`) as a PNG file store in the path given by `filename`  (including `.png` extension). Keyword arguments will be passed along to the  corresponding `save` method from Makie (see VPL documentation for details).\n\n\n<a target='_blank' href='https://github.com/AleMorales/VPL.jl/blob/95b9ec3af8f79b223271d3a3a2886919076df5ea/src/Render/Render.jl#LL124-L131' class='documenter-source'>source</a><br>\n\n"},"formats":{"html":{"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":"auto","echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"markdown"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../styles.css"],"output-file":"Render.html"},"language":{},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.2.313","theme":{"light":"default","dark":"darkly"}},"extensions":{"book":{"multiFile":true}}}}}