{"title":"Module Core","markdown":{"headingText":"Module Core","containsRefs":false,"markdown":"\n<a id='Module-Core'></a>\n\n<a id='Module-Core-1'></a>\n\n\n\n\n\n<a id='Types'></a>\n\n<a id='Types-1'></a>\n\n## Types\n\n<a id='VPL.Core.Graph' href='#VPL.Core.Graph'>#</a>\n**`VPL.Core.Graph`** &mdash; *Type*.\n\n\n\n```julia\nGraph(axiom; rules = nothing, vars = nothing)\n```\n\nCreates a dynamic graph defined by the initial node or nodes (`axiom`), one or more rules  (`rules`), and an object with graph-level variables (`vars`). Rules and graph-level variables are optional and must be assigned by keyword (see example below).  Rules must be a `Rule` or tuple of `Rule` objects.  The `axiom` may be a single object inheriting from `Node` or a subgraph generated  with the graph construction DSL.  A copy of the axiom and rules is always made when constructing the graph, but if object containing graph-level variables is not `mutable`, the user must manually copy it (with `copy` or `deepcopy`) or else changes within the graph will affect the original object (and other graphs created from the same object).\n\n**Example**\n\n```julia\nstruct A <: Node end\nstruct B <: Node end\naxiom = A() + B()\nno_rules_graph = Graph(axiom)\nrule = Rule(A, rhs = x -> A() + B())\nrules_graph = Graph(axiom, rules = rule)\n```\n\n\n<a target='_blank' href='https://github.com/AleMorales/VPL.jl/blob/ad86afd063ba4a15975584f1b4744fe3ef405caa/src/Core/Graph.jl#LL7-L30' class='documenter-source'>source</a><br>\n\n<a id='VPL.Core.Rule' href='#VPL.Core.Rule'>#</a>\n**`VPL.Core.Rule`** &mdash; *Type*.\n\n\n\n```julia\nRule(nodetype; lhs = x -> true, rhs = x -> nothing, captures = false)\n```\n\nCreate a replacement rule for nodes of type `nodetype` with function-like objects for the left-hand side (`lhs`) and right-hand side (`rhs`). If the rule captures nodes in the context of the replacement node this must be indicated by the argument `captures`.\n\n**Example**\n\n```julia\nstruct A <: Node end\nstruct B <: Node end\naxiom = A() + B()\nrule = Rule(A, rhs = x -> A() + B())\nrules_graph = Graph(axiom, rules = rule)\nrewrite!(rules_graph)\n```\n\n\n<a target='_blank' href='https://github.com/AleMorales/VPL.jl/blob/ad86afd063ba4a15975584f1b4744fe3ef405caa/src/Core/Rule.jl#LL7-L24' class='documenter-source'>source</a><br>\n\n<a id='VPL.Core.Query' href='#VPL.Core.Query'>#</a>\n**`VPL.Core.Query`** &mdash; *Type*.\n\n\n\n```julia\nQuery(nodetype::DataType, query = x -> true)\n```\n\nCreate a query that matches nodes of type `nodetype` and the conditions specified in the argument `query` (must be a function that returns `true`). It returns an object of type `Query` that can be applied to a graph with the function `apply`.\n\n**Example**\n\n```julia\nstruct A <: Node end\nstruct B <: Node end\naxiom = A() + B()\ngraph = Graph(axiom)\nquery = Query(A)\napply(graph, query)\n```\n\n\n<a target='_blank' href='https://github.com/AleMorales/VPL.jl/blob/ad86afd063ba4a15975584f1b4744fe3ef405caa/src/Core/Query.jl#LL7-L23' class='documenter-source'>source</a><br>\n\n<a id='VPL.Core.Node' href='#VPL.Core.Node'>#</a>\n**`VPL.Core.Node`** &mdash; *Type*.\n\n\n\n```julia\nNode\n```\n\nAbstract type from which every node in a graph should inherit. This allows using the graph construction DSL.\n\n**Example**\n\n```julia\nstruct bar <: Node\n  x::Int\nend\nb1 = bar(1)\nb2 = bar(2)\nb1 + b2\n```\n\n\n<a target='_blank' href='https://github.com/AleMorales/VPL.jl/blob/ad86afd063ba4a15975584f1b4744fe3ef405caa/src/Core/Types.jl#LL2-L17' class='documenter-source'>source</a><br>\n\n<a id='VPL.Core.Context' href='#VPL.Core.Context'>#</a>\n**`VPL.Core.Context`** &mdash; *Type*.\n\n\n\n```julia\nContext\n```\n\nData structure than links a `GraphNode` to a `Graph`. Functions `data()` and `vars()`  give access to the data stored in the node and graph, respectively. Several  methods are also available to test relationships among nodes in the graph and to  extract these related nodes (see User Manual for details).\n\nUsers do not build `Context` objects directly but they are provided by VPL as  inputs to the user-defined functions inside rules and queries. \n\n\n<a target='_blank' href='https://github.com/AleMorales/VPL.jl/blob/ad86afd063ba4a15975584f1b4744fe3ef405caa/src/Core/Types.jl#LL38-L48' class='documenter-source'>source</a><br>\n\n\n<a id='Graph-DSL'></a>\n\n<a id='Graph-DSL-1'></a>\n\n## Graph DSL\n\n<a id='Base.:+-Tuple{VPL.Core.Node, VPL.Core.Node}' href='#Base.:+-Tuple{VPL.Core.Node, VPL.Core.Node}'>#</a>\n**`Base.:+`** &mdash; *Method*.\n\n\n\n```julia\n+(n1::Node, n2::Node)\n```\n\nCreates a graph with two nodes where `n1` is the root and `n2` is the insertion point.\n\n\n<a target='_blank' href='https://github.com/AleMorales/VPL.jl/blob/ad86afd063ba4a15975584f1b4744fe3ef405caa/src/Core/GraphConstruction.jl#LL52-L55' class='documenter-source'>source</a><br>\n\n<a id='Base.:+-Tuple{VPL.Core.StaticGraph, VPL.Core.Node}' href='#Base.:+-Tuple{VPL.Core.StaticGraph, VPL.Core.Node}'>#</a>\n**`Base.:+`** &mdash; *Method*.\n\n\n\n```julia\n+(g::StaticGraph, n::Node)\n```\n\nCreates a graph as the result of appending the node `n` to the insertion point of graph `g`.\n\n\n<a target='_blank' href='https://github.com/AleMorales/VPL.jl/blob/ad86afd063ba4a15975584f1b4744fe3ef405caa/src/Core/GraphConstruction.jl#LL65-L68' class='documenter-source'>source</a><br>\n\n<a id='Base.:+-Tuple{VPL.Core.Node, VPL.Core.StaticGraph}' href='#Base.:+-Tuple{VPL.Core.Node, VPL.Core.StaticGraph}'>#</a>\n**`Base.:+`** &mdash; *Method*.\n\n\n\n```julia\n+(n::Node, g::StaticGraph)\n```\n\nCreates a graph as the result of appending the static graph `g` to the node `n`.\n\n\n<a target='_blank' href='https://github.com/AleMorales/VPL.jl/blob/ad86afd063ba4a15975584f1b4744fe3ef405caa/src/Core/GraphConstruction.jl#LL71-L74' class='documenter-source'>source</a><br>\n\n<a id='Base.:+-Tuple{VPL.Core.StaticGraph, VPL.Core.StaticGraph}' href='#Base.:+-Tuple{VPL.Core.StaticGraph, VPL.Core.StaticGraph}'>#</a>\n**`Base.:+`** &mdash; *Method*.\n\n\n\n```julia\n+(g1::StaticGraph, g2::StaticGraph)\n```\n\nCreates a graph as the result of appending `g2` to the insertion point of `g1`. The insertion point of the final graph corresponds to the insertion point of `g2`\n\n\n<a target='_blank' href='https://github.com/AleMorales/VPL.jl/blob/ad86afd063ba4a15975584f1b4744fe3ef405caa/src/Core/GraphConstruction.jl#LL78-L82' class='documenter-source'>source</a><br>\n\n<a id='Base.:+-Tuple{VPL.Core.Node, Tuple}' href='#Base.:+-Tuple{VPL.Core.Node, Tuple}'>#</a>\n**`Base.:+`** &mdash; *Method*.\n\n\n\n```julia\n+(g::StaticGraph, T::Tuple)\n+(n::Node, T::Tuple)\n```\n\nCreates a graph as the result of appending a tuple of graphs/nodes `T` to the insertion point of the graph `g` or node `n`. Each graph/node in `L` becomes a branch.\n\n\n<a target='_blank' href='https://github.com/AleMorales/VPL.jl/blob/ad86afd063ba4a15975584f1b4744fe3ef405caa/src/Core/GraphConstruction.jl#LL100-L105' class='documenter-source'>source</a><br>\n\n\n<a id='Applying-rules-and-queries'></a>\n\n<a id='Applying-rules-and-queries-1'></a>\n\n## Applying rules and queries\n\n<a id='VPL.Core.apply-Tuple{VPL.Core.Graph, VPL.Core.Query}' href='#VPL.Core.apply-Tuple{VPL.Core.Graph, VPL.Core.Query}'>#</a>\n**`VPL.Core.apply`** &mdash; *Method*.\n\n\n\n```julia\napply(g::Graph, query::Query)\n```\n\nReturn an array with all the nodes in the graph that match the query supplied by  the user.\n\n**Example**\n\n```julia\nstruct A <: Node end\nstruct B <: Node end\naxiom = A() + B()\ngraph = Graph(axiom)\nquery = Query(A)\napply(graph, query)\n```\n\n\n<a target='_blank' href='https://github.com/AleMorales/VPL.jl/blob/ad86afd063ba4a15975584f1b4744fe3ef405caa/src/Core/Query.jl#LL45-L60' class='documenter-source'>source</a><br>\n\n<a id='VPL.Core.rewrite!-Tuple{VPL.Core.Graph}' href='#VPL.Core.rewrite!-Tuple{VPL.Core.Graph}'>#</a>\n**`VPL.Core.rewrite!`** &mdash; *Method*.\n\n\n\n```julia\nrewrite!(g::Graph)\n```\n\nApply the graph-rewriting rules stored in the graph. This function will match the left-hand sides of the rules against the graph and then replace and/or prune the graph at every location where the left-hand sides matched by the result of executing the right hand side of each rule. The modification is performed in-place, so this function returns `nothing`.\n\n**Example**\n\n```julia\nstruct A <: Node end\nstruct B <: Node end\naxiom = A() + B()\nrule = Rule(A, rhs = x -> A() + B())\nrules_graph = Graph(axiom, rules = rule)\nrewrite!(rules_graph)\n```\n\n\n<a target='_blank' href='https://github.com/AleMorales/VPL.jl/blob/ad86afd063ba4a15975584f1b4744fe3ef405caa/src/Core/Rule.jl#LL142-L160' class='documenter-source'>source</a><br>\n\n\n<a id='Extracting-information'></a>\n\n<a id='Extracting-information-1'></a>\n\n## Extracting information\n\n<a id='VPL.Core.vars-Tuple{VPL.Core.Graph}' href='#VPL.Core.vars-Tuple{VPL.Core.Graph}'>#</a>\n**`VPL.Core.vars`** &mdash; *Method*.\n\n\n\nvars(g::Graph)\n\nReturns the object storing the graph-level variables\n\n**Example**\n\n```julia\nstruct A <: Node end\naxiom = A()\ngraph = Graph(axiom, vars = 2)\nvars(graph)\n```\n\n\n<a target='_blank' href='https://github.com/AleMorales/VPL.jl/blob/ad86afd063ba4a15975584f1b4744fe3ef405caa/src/Core/Graph.jl#LL62-L74' class='documenter-source'>source</a><br>\n\n<a id='VPL.Core.rules-Tuple{VPL.Core.Graph}' href='#VPL.Core.rules-Tuple{VPL.Core.Graph}'>#</a>\n**`VPL.Core.rules`** &mdash; *Method*.\n\n\n\n```julia\nrules(g::Graph)\n```\n\nReturns a tuple with all the graph-rewriting rules stored in the graph\n\n**Example**\n\n```julia\nstruct A <: Node end\nstruct B <: Node end\naxiom = A() + B()\nrule = Rule(A, rhs = x -> A() + B())\nrules_graph = Graph(axiom, rules = rule)\nrules(rules_graph)\n```\n\n\n<a target='_blank' href='https://github.com/AleMorales/VPL.jl/blob/ad86afd063ba4a15975584f1b4744fe3ef405caa/src/Core/Graph.jl#LL45-L59' class='documenter-source'>source</a><br>\n\n<a id='VPL.Core.vars-Tuple{VPL.Core.Context}' href='#VPL.Core.vars-Tuple{VPL.Core.Context}'>#</a>\n**`VPL.Core.vars`** &mdash; *Method*.\n\n\n\n```julia\nvars(c::Context)\n```\n\nReturns the object storing the graph-level variables in the graph associated to  a `Context` object. This needs to be used inside rules and queries.\n\n\n<a target='_blank' href='https://github.com/AleMorales/VPL.jl/blob/ad86afd063ba4a15975584f1b4744fe3ef405caa/src/Core/Context.jl#LL23-L28' class='documenter-source'>source</a><br>\n\n<a id='VPL.Core.data-Tuple{VPL.Core.Context}' href='#VPL.Core.data-Tuple{VPL.Core.Context}'>#</a>\n**`VPL.Core.data`** &mdash; *Method*.\n\n\n\n```julia\ndata(c::Context)\n```\n\nReturns the data stored in the node associated to a `Context` object. This needs to be used inside rules and queries.\n\n\n<a target='_blank' href='https://github.com/AleMorales/VPL.jl/blob/ad86afd063ba4a15975584f1b4744fe3ef405caa/src/Core/Context.jl#LL11-L16' class='documenter-source'>source</a><br>\n\n\n<a id='Graph-traversal'></a>\n\n<a id='Graph-traversal-1'></a>\n\n## Graph traversal\n\n<a id='VPL.Core.hasParent-Tuple{VPL.Core.Context}' href='#VPL.Core.hasParent-Tuple{VPL.Core.Context}'>#</a>\n**`VPL.Core.hasParent`** &mdash; *Method*.\n\n\n\n```julia\nhasParent(c::Context)\n```\n\nCheck if the node passed as argument has a parent and return `true` or `false`.\n\n\n<a target='_blank' href='https://github.com/AleMorales/VPL.jl/blob/ad86afd063ba4a15975584f1b4744fe3ef405caa/src/Core/Context.jl#LL38-L42' class='documenter-source'>source</a><br>\n\n<a id='VPL.Core.isRoot-Tuple{VPL.Core.Context}' href='#VPL.Core.isRoot-Tuple{VPL.Core.Context}'>#</a>\n**`VPL.Core.isRoot`** &mdash; *Method*.\n\n\n\n```julia\nisRoot(c::Context)\n```\n\nCheck if the node passed as argument is the root of the graph (i.e. has no parent)  and return `true` or `false`.\n\n\n<a target='_blank' href='https://github.com/AleMorales/VPL.jl/blob/ad86afd063ba4a15975584f1b4744fe3ef405caa/src/Core/Context.jl#LL45-L50' class='documenter-source'>source</a><br>\n\n<a id='VPL.Core.hasAncestor' href='#VPL.Core.hasAncestor'>#</a>\n**`VPL.Core.hasAncestor`** &mdash; *Function*.\n\n\n\n```julia\nhasAncestor(c::Context, condition, maxlevel)\n```\n\nCheck if the node passed as argument has an ancestor that matches the optional  condition and and return `true` or `false` and the number of steps taken.  The `argument` maxlevel is optional and limits the number of steps that the  algorithm will move through the graph (by default there is no limitation). The default condition returns `true` for any ancestor  and it takes an object of type `Context`.\n\n\n<a target='_blank' href='https://github.com/AleMorales/VPL.jl/blob/ad86afd063ba4a15975584f1b4744fe3ef405caa/src/Core/Context.jl#LL53-L62' class='documenter-source'>source</a><br>\n\n<a id='Base.parent-Tuple{VPL.Core.Context}' href='#Base.parent-Tuple{VPL.Core.Context}'>#</a>\n**`Base.parent`** &mdash; *Method*.\n\n\n\n```julia\nparent(c::Context, nsteps::Int)\n```\n\nReturns a `Context` object associated to the parent of the node passed as first argument (`nsteps = 1`, the default) or an ancestor that is `nsteps` away from the node passed as first argument.\n\n\n<a target='_blank' href='https://github.com/AleMorales/VPL.jl/blob/ad86afd063ba4a15975584f1b4744fe3ef405caa/src/Core/Context.jl#LL100-L106' class='documenter-source'>source</a><br>\n\n<a id='VPL.Core.ancestor' href='#VPL.Core.ancestor'>#</a>\n**`VPL.Core.ancestor`** &mdash; *Function*.\n\n\n\n```julia\nancestor(c::Context, condition, maxlevel)\n```\n\nReturns a `Context` object associated to the first ancestor of the node given as  argument that matches the optional condition. The `argument` maxlevel is optional and limits the number of steps that the algorithm will move through the graph (by default there is no limitation). The matched node is returned as a `Context` object. The default condition returns `true` for any ancestor and it takes an object of type `Context`.\n\n\n<a target='_blank' href='https://github.com/AleMorales/VPL.jl/blob/ad86afd063ba4a15975584f1b4744fe3ef405caa/src/Core/Context.jl#LL111-L120' class='documenter-source'>source</a><br>\n\n<a id='VPL.Core.hasChildren-Tuple{VPL.Core.Context}' href='#VPL.Core.hasChildren-Tuple{VPL.Core.Context}'>#</a>\n**`VPL.Core.hasChildren`** &mdash; *Method*.\n\n\n\n```julia\nhasChildren(c::Context)\n```\n\nCheck if the node passed as argument has at least one child and return `true` or `false`.\n\n\n<a target='_blank' href='https://github.com/AleMorales/VPL.jl/blob/ad86afd063ba4a15975584f1b4744fe3ef405caa/src/Core/Context.jl#LL68-L72' class='documenter-source'>source</a><br>\n\n<a id='VPL.Core.isLeaf-Tuple{VPL.Core.Context}' href='#VPL.Core.isLeaf-Tuple{VPL.Core.Context}'>#</a>\n**`VPL.Core.isLeaf`** &mdash; *Method*.\n\n\n\n```julia\nisLeaf(c::Context)\n```\n\nCheck if the node passed as argument is a leaf in the graph (i.e. has no children)  and return `true` or `false`.\n\n\n<a target='_blank' href='https://github.com/AleMorales/VPL.jl/blob/ad86afd063ba4a15975584f1b4744fe3ef405caa/src/Core/Context.jl#LL75-L80' class='documenter-source'>source</a><br>\n\n<a id='VPL.Core.hasDescendent' href='#VPL.Core.hasDescendent'>#</a>\n**`VPL.Core.hasDescendent`** &mdash; *Function*.\n\n\n\n```julia\nhasDescendent(c::Context, condition, maxlevel)\n```\n\nCheck if the node passed as argument has a descendent that matches the optional condition  and return `true` or `false`. The argument `maxlevel` is optional and limits the number of steps that the algorithm will move through the graph (by default there is no limitation). The default condition returns `true` for any descendent  and it takes an object of type `Context`.\n\n\n<a target='_blank' href='https://github.com/AleMorales/VPL.jl/blob/ad86afd063ba4a15975584f1b4744fe3ef405caa/src/Core/Context.jl#LL83-L91' class='documenter-source'>source</a><br>\n\n<a id='VPL.Core.children-Tuple{VPL.Core.Context}' href='#VPL.Core.children-Tuple{VPL.Core.Context}'>#</a>\n**`VPL.Core.children`** &mdash; *Method*.\n\n\n\n```julia\nchildren(c::Context)\n```\n\nReturns a tuple of `Context` objects with all the children of the node given as  argument.\n\n\n<a target='_blank' href='https://github.com/AleMorales/VPL.jl/blob/ad86afd063ba4a15975584f1b4744fe3ef405caa/src/Core/Context.jl#LL126-L131' class='documenter-source'>source</a><br>\n\n<a id='VPL.Core.descendent' href='#VPL.Core.descendent'>#</a>\n**`VPL.Core.descendent`** &mdash; *Function*.\n\n\n\n```julia\ndescendent(c::Context, condition, maxlevel)\n```\n\nReturns a `Context` object associated to the first descendent of the node given as  argument that matches the optional condition. The argument `maxlevel` is optional and limits the number of steps that the algorithm will move through the graph (by default there is no limitation). The matched node is returned as a `Context` object. The default condition returns `true` for any descendent and it takes an object of type `Context`.\n\n\n<a target='_blank' href='https://github.com/AleMorales/VPL.jl/blob/ad86afd063ba4a15975584f1b4744fe3ef405caa/src/Core/Context.jl#LL136-L145' class='documenter-source'>source</a><br>\n\n<a id='VPL.Core.traverse-Tuple{VPL.Core.Graph, Any}' href='#VPL.Core.traverse-Tuple{VPL.Core.Graph, Any}'>#</a>\n**`VPL.Core.traverse`** &mdash; *Method*.\n\n\n\n```julia\ntraverse(g::Graph, f)\n```\n\nIterates over all the nodes in the graph (in no particular order) and execute for each node the function `f` taking as input the data stored in the node.\n\n\n<a target='_blank' href='https://github.com/AleMorales/VPL.jl/blob/ad86afd063ba4a15975584f1b4744fe3ef405caa/src/Core/Algorithms.jl#LL5-L10' class='documenter-source'>source</a><br>\n\n<a id='VPL.Core.traverseDFS-Tuple{VPL.Core.Graph, Any}' href='#VPL.Core.traverseDFS-Tuple{VPL.Core.Graph, Any}'>#</a>\n**`VPL.Core.traverseDFS`** &mdash; *Method*.\n\n\n\n```julia\ntraverseDFS(g::Graph, f)\n```\n\nIterates over all the nodes in the graph (depth-first order, starting at the  root of the graph) and execute for each node the function `f` taking as input the  data stored in the node.\n\n\n<a target='_blank' href='https://github.com/AleMorales/VPL.jl/blob/ad86afd063ba4a15975584f1b4744fe3ef405caa/src/Core/Algorithms.jl#LL18-L24' class='documenter-source'>source</a><br>\n\n<a id='VPL.Core.traverseBFS-Tuple{VPL.Core.Graph, Any}' href='#VPL.Core.traverseBFS-Tuple{VPL.Core.Graph, Any}'>#</a>\n**`VPL.Core.traverseBFS`** &mdash; *Method*.\n\n\n\n```julia\ntraverseBFS(g::Graph, f)\n```\n\nIterates over all the nodes in the graph (breadth-first order, starting at the  root of the graph) and execute for each node the function `f` taking as input the  data stored in the node.\n\n\n<a target='_blank' href='https://github.com/AleMorales/VPL.jl/blob/ad86afd063ba4a15975584f1b4744fe3ef405caa/src/Core/Algorithms.jl#LL43-L49' class='documenter-source'>source</a><br>\n\n\n<a id='Graph-visualization'></a>\n\n<a id='Graph-visualization-1'></a>\n\n## Graph visualization\n\n<a id='VPL.Core.draw-Tuple{VPL.Core.Graph}' href='#VPL.Core.draw-Tuple{VPL.Core.Graph}'>#</a>\n**`VPL.Core.draw`** &mdash; *Method*.\n\n\n\n```julia\ndraw(g::Graph; force = false, backend = \"native\", inline = false, resolution = (1920, 1080),\n```\n\nnlabels*textsize = 15, arrow*size = 15, node_size = 5)\n\nVisualize a graph as a network using different backends (`native` for OpenGL, `web` for WebGL and `vector` for Cairo vector graphics, see VPL documentation for details). To force an external window when using the native backend set `force = true` whereas to force to be inlined use `inline = true`. Details on the behaviour of each backend on different contexts of code execution can be found in the VPL documentation. For backend `native` or `web`, the user may specify the  resolution in pixels (by default HD is used). Additional customization is possible via `nlabels_textsize` (useful if the labels of the nodes are too large or small), `arrow_size` (this adjust the size of arrow heads) and `node_size` (for the size of the nodes).\n\n\n<a target='_blank' href='https://github.com/AleMorales/VPL.jl/blob/ad86afd063ba4a15975584f1b4744fe3ef405caa/src/Core/Draw.jl#LL104-L115' class='documenter-source'>source</a><br>\n\n<a id='VPL.Core.draw-Tuple{VPL.Core.StaticGraph}' href='#VPL.Core.draw-Tuple{VPL.Core.StaticGraph}'>#</a>\n**`VPL.Core.draw`** &mdash; *Method*.\n\n\n\n```julia\ndraw(g::StaticGraph; force = false, backend = \"native\", inline = false, resolution = (1920, 1080),\n```\n\nnlabels*textsize = 15, arrow*size = 15, node_size = 5)\n\nEquivalent to the method `draw(g::Graph)` but useful to visualize static graphs (e.g., usually this would be  the axiom of a graph).\n\n\n<a target='_blank' href='https://github.com/AleMorales/VPL.jl/blob/ad86afd063ba4a15975584f1b4744fe3ef405caa/src/Core/Draw.jl#LL57-L63' class='documenter-source'>source</a><br>\n\n<a id='VPL.Core.node_label-Tuple{VPL.Core.Node, Any}' href='#VPL.Core.node_label-Tuple{VPL.Core.Node, Any}'>#</a>\n**`VPL.Core.node_label`** &mdash; *Method*.\n\n\n\n```julia\nnode_label(n::Node, id)\n```\n\nFunction that constructs a label for a node to be used by `draw()` when visualizing the graph  as a network. The default method will create a label from the type of node its unique id. The user can specialize this method for user-defined data types to customize the label.\n\n\n<a target='_blank' href='https://github.com/AleMorales/VPL.jl/blob/ad86afd063ba4a15975584f1b4744fe3ef405caa/src/Core/Draw.jl#LL2-L8' class='documenter-source'>source</a><br>\n\n<a id='VPL.Core.export_graph-Tuple{Any, Any}' href='#VPL.Core.export_graph-Tuple{Any, Any}'>#</a>\n**`VPL.Core.export_graph`** &mdash; *Method*.\n\n\n\n```julia\nexport_graph(f, filename; kwargs...)\n```\n\nExport a graph visualization (created by `draw()`) into an external file. Supported formats are png (if the `native` or `web` backends were used in `draw()`), pdf or svg (if the `vector` backend was used). The file name should include the extension from which the format will be inferred. Additional keyword arguments are passed along to the corresponding `save()` method defined in the *Makie* package (see VPL documentation for details).\n\n\n<a target='_blank' href='https://github.com/AleMorales/VPL.jl/blob/ad86afd063ba4a15975584f1b4744fe3ef405caa/src/Core/Draw.jl#LL122-L130' class='documenter-source'>source</a><br>\n\n<a id='VPL.Core.calculate_resolution-Tuple{Any, Any}' href='#VPL.Core.calculate_resolution-Tuple{Any, Any}'>#</a>\n**`VPL.Core.calculate_resolution`** &mdash; *Method*.\n\n\n\n```julia\ncalculate_resolution(width, height; format = \"png\", dpi = 300)\n```\n\nCalculate the resolution required to achieve a specific `width` and `height` (in cm) of the exported image, with a particular `dpi` (for png format).\n\n\n<a target='_blank' href='https://github.com/AleMorales/VPL.jl/blob/ad86afd063ba4a15975584f1b4744fe3ef405caa/src/Core/Draw.jl#LL135-L140' class='documenter-source'>source</a><br>\n\n"},"formats":{"html":{"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":"auto","echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"markdown"},"render":{"keep-tex":false,"keep-yaml":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../styles.css"],"output-file":"Core.html"},"language":{},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.0.32","theme":{"light":"default","dark":"darkly"}},"extensions":{"book":{"multiFile":true}}}}}