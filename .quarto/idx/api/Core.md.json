{"title":"Module Core","markdown":{"headingText":"Module Core","containsRefs":false,"markdown":"\n<a id='Module-Core'></a>\n\n<a id='Module-Core-1'></a>\n\n\n\n\n\n<a id='Types'></a>\n\n<a id='Types-1'></a>\n\n## Types\n\n<a id='VPL.Core.Graph' href='#VPL.Core.Graph'>#</a>\n**`VPL.Core.Graph`** &mdash; *Type*.\n\n\n\n```julia\nGraph(;axiom, rules = nothing, vars = nothing)\n```\n\nCreate a dynamic graph from an axiom, one or more rules and, optionally,  graph-level variables.\n\n**Arguments**\n\n  * `axiom`: A single object inheriting from `Node` or a subgraph generated  with\n\nthe graph construction DSL. It should represent the initial state of the dynamic graph. \n\n  * `rules`:  A single `Rule` object or a tuple of `Rule` objects (optional). It\n\nshould include all graph-rewriting rules of the graph. \n\n  * `vars`: A single object of any user-defined type (optional). This will be the\n\ngraph-level variable accessible from any rule or query applied to the graph.\n\n  * `FT`: Floating-point precision to be used when generating the 3D geometry\n\nassociated to a graph. \n\n**Details**\n\nAll arguments are assigned by keyword. The axiom and rules are deep-copied when  creating the graph but the graph-level variables (if a copy is needed due to mutability, the user needs to care of that).\n\n**Return**\n\nAn object of type `Graph` representing a dynamic graph. Printing this object results in a human-readable description of the type of data stored in the graph.\n\n**Examples**\n\n```julia\nlet\n    struct A0 <: Node end\n    struct B0 <: Node end\n    axiom = A0() + B0()\n    no_rules_graph = Graph(axiom = axiom)\n    rule = Rule(A, rhs = x -> A0() + B0())\n    rules_graph = Graph(axiom = axiom, rules = rule)\nend\n```\n\n\n<a target='_blank' href='https://github.com/AleMorales/VPL.jl/blob/5958cb5f2472fe814ba61832037cd95c2988bab5/src/Core/Graph.jl#LL7-L44' class='documenter-source'>source</a><br>\n\n<a id='VPL.Core.Rule' href='#VPL.Core.Rule'>#</a>\n**`VPL.Core.Rule`** &mdash; *Type*.\n\n\n\n```julia\nRule(nodetype; lhs = x -> true, rhs = x -> nothing, captures = false)\n```\n\nCreate a replacement rule for nodes of type `nodetype`.\n\n**Arguments**\n\n  * `nodetype`: Type of node to be matched.\n  * `lhs`: Function or function-like object that takes a `Context` object and\n\nreturns whether the node should be replaced or not (with `true` or `false`).\n\n  * `rhs`: Function or function-like object that takes one or more `Context`\n\nobjects and returns a replacement graph or `nothing`. If it takes several  inputs, the first one will correspond to the node being replaced.  \n\n  * `captures`: Either `false` or `true` to indicate whether the left-hand side\n\nof the rule is capturing nodes in the context of the replacement node to be used for the construction of the replace graph.\n\n**Details**\n\nSee VPL documentation for details on rule-based graph rewriting.\n\n**Return**\n\nAn object of type `Rule`.\n\n**Examples**\n\n```julia\nlet\n    struct A <: Node end\n    struct B <: Node end\n    axiom = A() + B()\n    rule = Rule(A, rhs = x -> A() + B())\n    rules_graph = Graph(axiom = axiom, rules = rule)\n    rewrite!(rules_graph)\nend\n```\n\n\n<a target='_blank' href='https://github.com/AleMorales/VPL.jl/blob/5958cb5f2472fe814ba61832037cd95c2988bab5/src/Core/Rule.jl#LL7-L40' class='documenter-source'>source</a><br>\n\n<a id='VPL.Core.Query' href='#VPL.Core.Query'>#</a>\n**`VPL.Core.Query`** &mdash; *Type*.\n\n\n\n```julia\nQuery(nodetype::DataType; condition = x -> true)\n```\n\nCreate a query that matches nodes of type `nodetype` and a `condition`.\n\n**Arguments**\n\n  * `nodetype::DataType`: Type of node to be matched.\n  * `condition`: Function or function-like object that checks if a node should be\n\nselected. It is assigned as a keyword argument.\n\n**Details**\n\nIf the `nodetype` should refer to a concrete type and match one of the types stored inside the graph. Abstract types or types that are not contained in the graph are allowed but the query will never return anything.\n\nThe `condition` must be a function or function-like object that takes a  `Context` as input and returns `true` or `false`. The default `condition` always return `true` such that the query will\n\n**Return**\n\nIt returns an object of type `Query`. Use `apply()` to execute the query on a  dynamic graph.\n\n**Example**\n\n```julia\nstruct A <: Node end\nstruct B <: Node end\naxiom = A() + B()\ngraph = Graph(axiom)\nquery = Query(A)\napply(graph, query)\n```\n\n\n<a target='_blank' href='https://github.com/AleMorales/VPL.jl/blob/5958cb5f2472fe814ba61832037cd95c2988bab5/src/Core/Query.jl#LL7-L39' class='documenter-source'>source</a><br>\n\n<a id='VPL.Core.Node' href='#VPL.Core.Node'>#</a>\n**`VPL.Core.Node`** &mdash; *Type*.\n\n\n\n```julia\nNode\n```\n\nAbstract type from which every node in a graph should inherit. This allows using the graph construction DSL.\n\n**Example**\n\n```julia\nlet\n  struct bar <: Node\n    x::Int\n  end\n  b1 = bar(1)\n  b2 = bar(2)\n  b1 + b2\nend\n```\n\n\n<a target='_blank' href='https://github.com/AleMorales/VPL.jl/blob/5958cb5f2472fe814ba61832037cd95c2988bab5/src/Core/Types.jl#LL3-L20' class='documenter-source'>source</a><br>\n\n<a id='VPL.Core.Context' href='#VPL.Core.Context'>#</a>\n**`VPL.Core.Context`** &mdash; *Type*.\n\n\n\n```julia\nContext\n```\n\nData structure than links a node to the rest of the graph.\n\n**Fields**\n\n  * `graph`: Dynamic graph that contains the node.\n  * `node`: Node inside the graph.\n\n**Details**\n\nA `Context` object wraps references to a node and its associated graph. The purpose of this structure is to be able to test relationships among nodes within a graph (from with a query or rule), as well as access the data stored in a node (with `data()`) or the graph (with `vars()`).\n\nUsers do not build `Context` objects directly but they are provided by VPL as  inputs to the user-defined functions inside rules and queries. \n\n\n<a target='_blank' href='https://github.com/AleMorales/VPL.jl/blob/5958cb5f2472fe814ba61832037cd95c2988bab5/src/Core/Types.jl#LL41-L58' class='documenter-source'>source</a><br>\n\n\n<a id='Graph-DSL'></a>\n\n<a id='Graph-DSL-1'></a>\n\n## Graph DSL\n\n<a id='Base.:+-Tuple{VPL.Core.Node, VPL.Core.Node}' href='#Base.:+-Tuple{VPL.Core.Node, VPL.Core.Node}'>#</a>\n**`Base.:+`** &mdash; *Method*.\n\n\n\n```julia\n+(n1::Node, n2::Node)\n```\n\nCreates a graph with two nodes where `n1` is the root and `n2` is the insertion point.\n\n**Examples**\n\n```julia\nlet\n    struct A1 <: Node val::Int end\n    struct B1 <: Node val::Int end\n    axiom = A1(1) + B1(1)\n    draw(axiom)\nend\n```\n\n\n<a target='_blank' href='https://github.com/AleMorales/VPL.jl/blob/5958cb5f2472fe814ba61832037cd95c2988bab5/src/Core/GraphConstruction.jl#LL52-L66' class='documenter-source'>source</a><br>\n\n<a id='Base.:+-Tuple{VPL.Core.StaticGraph, VPL.Core.Node}' href='#Base.:+-Tuple{VPL.Core.StaticGraph, VPL.Core.Node}'>#</a>\n**`Base.:+`** &mdash; *Method*.\n\n\n\n```julia\n+(g::StaticGraph, n::Node)\n```\n\nCreates a graph as the result of appending the node `n` to the insertion point of graph `g`.\n\n**Examples**\n\n```julia\nlet\n    struct A1 <: Node val::Int end\n    struct B1 <: Node val::Int end\n    axiom = A1(1) + B1(1)\n    axiom = axiom + A1(2)\n    draw(axiom)\nend\n```\n\n\n<a target='_blank' href='https://github.com/AleMorales/VPL.jl/blob/5958cb5f2472fe814ba61832037cd95c2988bab5/src/Core/GraphConstruction.jl#LL76-L91' class='documenter-source'>source</a><br>\n\n<a id='Base.:+-Tuple{VPL.Core.Node, VPL.Core.StaticGraph}' href='#Base.:+-Tuple{VPL.Core.Node, VPL.Core.StaticGraph}'>#</a>\n**`Base.:+`** &mdash; *Method*.\n\n\n\n```julia\n+(n::Node, g::StaticGraph)\n```\n\nCreates a graph as the result of appending the static graph `g` to the node `n`.\n\n**Examples**\n\n```julia\nlet\n    struct A1 <: Node val::Int end\n    struct B1 <: Node val::Int end\n    axiom = A1(1) + B1(1)\n    axiom = A1(2) + axiom\n    draw(axiom)\nend\n```\n\n\n<a target='_blank' href='https://github.com/AleMorales/VPL.jl/blob/5958cb5f2472fe814ba61832037cd95c2988bab5/src/Core/GraphConstruction.jl#LL94-L109' class='documenter-source'>source</a><br>\n\n<a id='Base.:+-Tuple{VPL.Core.StaticGraph, VPL.Core.StaticGraph}' href='#Base.:+-Tuple{VPL.Core.StaticGraph, VPL.Core.StaticGraph}'>#</a>\n**`Base.:+`** &mdash; *Method*.\n\n\n\n```julia\n+(g1::StaticGraph, g2::StaticGraph)\n```\n\nCreates a graph as the result of appending `g2` to the insertion point of `g1`.  The insertion point of the final graph corresponds to the insertion point of `g2`.\n\n**Examples**\n\n```julia\nlet\n    struct A1 <: Node val::Int end\n    struct B1 <: Node val::Int end\n    axiom1 = A1(1) + B1(1)\n    axiom2 = A1(2) + B1(2)\n    axiom = axiom1 + axiom2\n    draw(axiom)\nend\n```\n\n\n<a target='_blank' href='https://github.com/AleMorales/VPL.jl/blob/5958cb5f2472fe814ba61832037cd95c2988bab5/src/Core/GraphConstruction.jl#LL113-L130' class='documenter-source'>source</a><br>\n\n<a id='Base.:+-Tuple{VPL.Core.Node, Tuple}' href='#Base.:+-Tuple{VPL.Core.Node, Tuple}'>#</a>\n**`Base.:+`** &mdash; *Method*.\n\n\n\n```julia\n+(g::StaticGraph, T::Tuple)\n+(n::Node, T::Tuple)\n```\n\nCreates a graph as the result of appending a tuple of graphs/nodes `T` to the insertion point of the graph `g` or node `n`. Each graph/node in `L` becomes a  branch.\n\n**Examples**\n\n```julia\nlet\n    struct A1 <: Node val::Int end\n    struct B1 <: Node val::Int end\n    axiom = A1(1) + (B1(1) + A1(3), B1(4))\n    draw(axiom)\nend\n```\n\n\n<a target='_blank' href='https://github.com/AleMorales/VPL.jl/blob/5958cb5f2472fe814ba61832037cd95c2988bab5/src/Core/GraphConstruction.jl#LL149-L166' class='documenter-source'>source</a><br>\n\n\n<a id='Applying-rules-and-queries'></a>\n\n<a id='Applying-rules-and-queries-1'></a>\n\n## Applying rules and queries\n\n<a id='VPL.Core.apply-Tuple{VPL.Core.Graph, VPL.Core.Query}' href='#VPL.Core.apply-Tuple{VPL.Core.Graph, VPL.Core.Query}'>#</a>\n**`VPL.Core.apply`** &mdash; *Method*.\n\n\n\n```julia\napply(g::Graph, query::Query)\n```\n\nReturn an array with all the nodes in the graph that match the query supplied by  the user.\n\n**Example**\n\n```julia\nstruct A <: Node end\nstruct B <: Node end\naxiom = A() + B()\ngraph = Graph(axiom)\nquery = Query(A)\napply(graph, query)\n```\n\n\n<a target='_blank' href='https://github.com/AleMorales/VPL.jl/blob/5958cb5f2472fe814ba61832037cd95c2988bab5/src/Core/Query.jl#LL61-L76' class='documenter-source'>source</a><br>\n\n<a id='VPL.Core.rewrite!-Tuple{VPL.Core.Graph}' href='#VPL.Core.rewrite!-Tuple{VPL.Core.Graph}'>#</a>\n**`VPL.Core.rewrite!`** &mdash; *Method*.\n\n\n\n```julia\nrewrite!(g::Graph)\n```\n\nApply the graph-rewriting rules stored in the graph.\n\n**Arguments**\n\n  * `g::Graph`: The graph to be rewritten. It will be modified in-place.\n\n**Details**\n\nThis function will match the left-hand sides of all the rules in a graph. If any node is matched by more than one rule this will result in an error. The rules are then applied in order to replaced the matched nodes with the result of executing the right hand side of the rules. The rules are applied in the order in which they are stored in the graph but the order in which the nodes are  processed is not defined. Since graph rewriting is semantically a parallel process, the rules should not be rely on any particular order for their  functioning.\n\n**Returns**\n\nThis function returns `nothing`, but the graph passed as input will be modified by the execution of the rules.\n\n**Example**\n\n```julia\nlet\n    struct A <: Node end\n    struct B <: Node end\n    axiom = A() + B()\n    rule = Rule(A, rhs = x -> A() + B())\n    g = Graph(axiom = axiom, rules = rule)\n    rewrite!(g)\nend\n```\n\n\n<a target='_blank' href='https://github.com/AleMorales/VPL.jl/blob/5958cb5f2472fe814ba61832037cd95c2988bab5/src/Core/Rule.jl#LL158-L191' class='documenter-source'>source</a><br>\n\n\n<a id='Extracting-information'></a>\n\n<a id='Extracting-information-1'></a>\n\n## Extracting information\n\n<a id='VPL.Core.vars-Tuple{VPL.Core.Graph}' href='#VPL.Core.vars-Tuple{VPL.Core.Graph}'>#</a>\n**`VPL.Core.vars`** &mdash; *Method*.\n\n\n\nvars(g::Graph)\n\nReturns the graph-level variables.\n\n**Example**\n\n```julia\nstruct A <: Node end\naxiom = A()\ngraph = Graph(axiom, vars = 2)\nvars(graph)\n```\n\n\n<a target='_blank' href='https://github.com/AleMorales/VPL.jl/blob/5958cb5f2472fe814ba61832037cd95c2988bab5/src/Core/Graph.jl#LL76-L88' class='documenter-source'>source</a><br>\n\n<a id='VPL.Core.rules-Tuple{VPL.Core.Graph}' href='#VPL.Core.rules-Tuple{VPL.Core.Graph}'>#</a>\n**`VPL.Core.rules`** &mdash; *Method*.\n\n\n\n```julia\nrules(g::Graph)\n```\n\nReturns a tuple with all the graph-rewriting rules stored in a dynamic graph\n\n**Examples**\n\n```julia\nstruct A <: Node end\nstruct B <: Node end\naxiom = A() + B()\nrule = Rule(A, rhs = x -> A() + B())\nrules_graph = Graph(axiom, rules = rule)\nrules(rules_graph)\n```\n\n\n<a target='_blank' href='https://github.com/AleMorales/VPL.jl/blob/5958cb5f2472fe814ba61832037cd95c2988bab5/src/Core/Graph.jl#LL59-L73' class='documenter-source'>source</a><br>\n\n<a id='VPL.Core.vars-Tuple{VPL.Core.Context}' href='#VPL.Core.vars-Tuple{VPL.Core.Context}'>#</a>\n**`VPL.Core.vars`** &mdash; *Method*.\n\n\n\n```julia\nvars(c::Context)\n```\n\nReturns the graph-level variables. Intended to be used within a rule or query. \n\n\n<a target='_blank' href='https://github.com/AleMorales/VPL.jl/blob/5958cb5f2472fe814ba61832037cd95c2988bab5/src/Core/Context.jl#LL22-L26' class='documenter-source'>source</a><br>\n\n<a id='VPL.Core.data-Tuple{VPL.Core.Context}' href='#VPL.Core.data-Tuple{VPL.Core.Context}'>#</a>\n**`VPL.Core.data`** &mdash; *Method*.\n\n\n\n```julia\ndata(c::Context)\n```\n\nReturns the data stored in a node. Intended to be used within a rule or query. \n\n\n<a target='_blank' href='https://github.com/AleMorales/VPL.jl/blob/5958cb5f2472fe814ba61832037cd95c2988bab5/src/Core/Context.jl#LL11-L15' class='documenter-source'>source</a><br>\n\n\n<a id='Node-relations'></a>\n\n<a id='Node-relations-1'></a>\n\n## Node relations\n\n<a id='VPL.Core.hasParent-Tuple{VPL.Core.Context}' href='#VPL.Core.hasParent-Tuple{VPL.Core.Context}'>#</a>\n**`VPL.Core.hasParent`** &mdash; *Method*.\n\n\n\n```julia\nhasParent(c::Context)\n```\n\nCheck if a node has a parent and return `true` or `false`. Intended to be used  within a rule or query. \n\n\n<a target='_blank' href='https://github.com/AleMorales/VPL.jl/blob/5958cb5f2472fe814ba61832037cd95c2988bab5/src/Core/Context.jl#LL36-L41' class='documenter-source'>source</a><br>\n\n<a id='VPL.Core.isRoot-Tuple{VPL.Core.Context}' href='#VPL.Core.isRoot-Tuple{VPL.Core.Context}'>#</a>\n**`VPL.Core.isRoot`** &mdash; *Method*.\n\n\n\n```julia\nisRoot(c::Context)\n```\n\nCheck if a node is the root of the graph (i.e., has no parent) and return `true` or  `false`. Intended to be used within a rule or query. \n\n\n<a target='_blank' href='https://github.com/AleMorales/VPL.jl/blob/5958cb5f2472fe814ba61832037cd95c2988bab5/src/Core/Context.jl#LL44-L49' class='documenter-source'>source</a><br>\n\n<a id='VPL.Core.hasAncestor-Tuple{VPL.Core.Context}' href='#VPL.Core.hasAncestor-Tuple{VPL.Core.Context}'>#</a>\n**`VPL.Core.hasAncestor`** &mdash; *Method*.\n\n\n\n```julia\nhasAncestor(c::Context; condition = x -> true, maxlevel::Int = typemax(Int))\n```\n\nCheck if a node has an ancestor that matches the condition. Intended to be used within  a rule or query. \n\n**Arguments**\n\n  * `c::Context`: Context associated to a node in a dynamic graph.\n  * `condition`: An user-defined function that takes a `Context` object as input\n\nand returns `true` or `false`. It is assigned by the user by keyword.\n\n  * `maxlevel::Int`: Maximum number of steps that the algorithm may take when\n\ntraversing the graph.\n\n**Details**\n\nThis function traverses the graph from the node associated to `c` towards the  root of the graph until a node is found for which `condition` returns `true`. If no node meets the condition, then it will return `false`. The defaults values  for this function are such that the algorithm always returns `true`  after one step (unless it is applied to the root node) in which case it is  equivalent to calling `hasParent` on the node.\n\nThe number of levels that the algorithm is allowed to traverse is capped by `maxlevel` (mostly to avoid excessive computation, though the user may want to specify a meaningful limit based on the topology of the graphs being used).\n\nThe function `condition` should take an object of type `Context` as input and return `true` or `false`.\n\n**Return**\n\nReturn a tuple with two values a `Bool` and an `Int`, the boolean indicating  whether the node has an ancestor meeting the condition, the integer indicating  the number of levels in the graph separating the node an its ancestor.\n\n**Examples**\n\n```julia\nlet\n    struct A1 <: Node val::Int end\n    struct B1 <: Node val::Int end\n    axiom = A1(2) + (B1(1) + A1(3), B1(4))\n    g = Graph(axiom = axiom)\n    function qfun(n)\n        hasAncestor(n, condition = x -> data(x).val == 1)[1]\n    end\n    Q1 = Query(A1, query = qfun)\n    R1 = apply(g, Q1)\n    Q2 = Query(B1, query = qfun)\n    R2 = apply(g, Q2)\n    (R1,R2)\nend\n```\n\n\n<a target='_blank' href='https://github.com/AleMorales/VPL.jl/blob/5958cb5f2472fe814ba61832037cd95c2988bab5/src/Core/Context.jl#LL52-L102' class='documenter-source'>source</a><br>\n\n<a id='Base.parent-Tuple{VPL.Core.Context}' href='#Base.parent-Tuple{VPL.Core.Context}'>#</a>\n**`Base.parent`** &mdash; *Method*.\n\n\n\n```julia\nparent(c::Context; nsteps::Int)\n```\n\nReturns the parent of a node that is `nsteps` away towards the root of the graph. Intended to be used within a rule or query. \n\n**Details**\n\nIf `hasParent()` returns `false` for the same node or the algorithm has reached the root node but `nsteps` have not been reached, then `parent()` will return  `missing`, otherwise it returns the `Context` associated to the matching node.\n\n**Return**\n\nReturn a `Context` object or `missing`.\n\n**Examples**\n\n```julia\nlet\n    struct A1 <: Node val::Int end\n    struct B1 <: Node val::Int end\n    axiom = A1(2) + (B1(1) + A1(3), B1(4))\n    g = Graph(axiom = axiom)\n    function qfun(n)\n        np = parent(n, nsteps = 2)\n        !ismissing(np) && data(np).val == 2\n    end\n    Q1 = Query(A1, query = qfun)\n    R1 = apply(g, Q1)\n    Q2 = Query(B1, query = qfun)\n    R2 = apply(g, Q2)\n    (R1,R2)\nend\n```\n\n\n<a target='_blank' href='https://github.com/AleMorales/VPL.jl/blob/5958cb5f2472fe814ba61832037cd95c2988bab5/src/Core/Context.jl#LL183-L215' class='documenter-source'>source</a><br>\n\n<a id='VPL.Core.ancestor-Tuple{VPL.Core.Context}' href='#VPL.Core.ancestor-Tuple{VPL.Core.Context}'>#</a>\n**`VPL.Core.ancestor`** &mdash; *Method*.\n\n\n\n```julia\nancestor(c::Context; condition = x -> true, maxlevel::Int = typemax(Int))\n```\n\nReturns the first ancestor of a node that matches the `condition`. Intended to be  used within a rule or query. \n\n**Details**\n\nIf `hasAncestor()` returns `false` for the same node and `condition`, `ancestor()` will return `missing`, otherwise it returns the `Context` associated to the  matching node\n\n**Return**\n\nReturn a `Context` object or `missing`.\n\n**Examples**\n\n```julia\nlet\n    struct A1 <: Node val::Int end\n    struct B1 <: Node val::Int end\n    axiom = A1(1) + (B1(1) + A1(3), B1(4))\n    g = Graph(axiom = axiom)\n    function qfun(n)\n        na = ancestor(n, condition = x -> (data(x).val == 1))\n        if !ismissing(na)\n            data(na) isa B1\n        else\n            false\n        end\n    end\n    Q1 = Query(A1, query = qfun)\n    R1 = apply(g, Q1)\n    Q2 = Query(B1, query = qfun)\n    R2 = apply(g, Q2)\n    (R1,R2)\nend\n```\n\n\n<a target='_blank' href='https://github.com/AleMorales/VPL.jl/blob/5958cb5f2472fe814ba61832037cd95c2988bab5/src/Core/Context.jl#LL220-L256' class='documenter-source'>source</a><br>\n\n<a id='VPL.Core.hasChildren-Tuple{VPL.Core.Context}' href='#VPL.Core.hasChildren-Tuple{VPL.Core.Context}'>#</a>\n**`VPL.Core.hasChildren`** &mdash; *Method*.\n\n\n\n```julia\nhasChildren(c::Context)\n```\n\nCheck if a node has at least one child and return `true` or `false`. Intended to be used within a rule or query. \n\n\n<a target='_blank' href='https://github.com/AleMorales/VPL.jl/blob/5958cb5f2472fe814ba61832037cd95c2988bab5/src/Core/Context.jl#LL108-L113' class='documenter-source'>source</a><br>\n\n<a id='VPL.Core.isLeaf-Tuple{VPL.Core.Context}' href='#VPL.Core.isLeaf-Tuple{VPL.Core.Context}'>#</a>\n**`VPL.Core.isLeaf`** &mdash; *Method*.\n\n\n\n```julia\nisLeaf(c::Context)\n```\n\nCheck if a node is a leaf in the graph (i.e., has no children) and return `true` or  `false`. Intended to be used within a rule or query. \n\n\n<a target='_blank' href='https://github.com/AleMorales/VPL.jl/blob/5958cb5f2472fe814ba61832037cd95c2988bab5/src/Core/Context.jl#LL116-L121' class='documenter-source'>source</a><br>\n\n<a id='VPL.Core.hasDescendent-Tuple{VPL.Core.Context}' href='#VPL.Core.hasDescendent-Tuple{VPL.Core.Context}'>#</a>\n**`VPL.Core.hasDescendent`** &mdash; *Method*.\n\n\n\n```julia\nhasDescendent(c::Context; condition = x -> true, maxlevel::Int = typemax(Int))\n```\n\nCheck if a node has a descendent that matches the optional condition. Intended to be used  within a rule or query. \n\n**Arguments**\n\n  * `c::Context`: Context associated to a node in a dynamic graph.\n  * `condition`: An user-defined function that takes a `Context` object as input\n\nand returns `true` or `false`. It is assigned by the user by keyword.\n\n  * `maxlevel::Int`: Maximum number of steps that the algorithm may take when\n\ntraversing the graph.\n\n**Details**\n\nThis function traverses the graph from the node associated to `c` towards the  leaves of the graph until a node is found for which `condition` returns `true`.  If no node meets the condition, then it will return `false`. The defaults values  for this function are such that the algorithm always returns `true`  after one step (unless it is applied to a leaf node) in which case it is  equivalent to calling `hasChildren` on the node.\n\nThe number of levels that the algorithm is allowed to traverse is capped by `maxlevel` (mostly to avoid excessive computation, though the user may want to specify a meaningful limit based on the topology of the graphs being used).\n\nThe function `condition` should take an object of type `Context` as input and return `true` or `false`.\n\n**Return**\n\nReturn a tuple with two values a `Bool` and an `Int`, the boolean indicating  whether the node has an ancestor meeting the condition, the integer indicating  the number of levels in the graph separating the node an its ancestor.\n\n**Examples**\n\n```julia\nlet\n    struct A1 <: Node val::Int end\n    struct B1 <: Node val::Int end\n    axiom = A1(2) + (B1(1) + A1(3), B1(4))\n    g = Graph(axiom = axiom)\n    function qfun(n)\n        hasDescendent(n, condition = x -> data(x).val == 1)[1]\n    end\n    Q1 = Query(A1, query = qfun)\n    R1 = apply(g, Q1)\n    Q2 = Query(B1, query = qfun)\n    R2 = apply(g, Q2)\n    (R1,R2)\nend\n```\n\n\n<a target='_blank' href='https://github.com/AleMorales/VPL.jl/blob/5958cb5f2472fe814ba61832037cd95c2988bab5/src/Core/Context.jl#LL124-L174' class='documenter-source'>source</a><br>\n\n<a id='VPL.Core.children-Tuple{VPL.Core.Context}' href='#VPL.Core.children-Tuple{VPL.Core.Context}'>#</a>\n**`VPL.Core.children`** &mdash; *Method*.\n\n\n\n```julia\nchildren(c::Context)\n```\n\nReturns all the children of a node as `Context` objects.\n\n\n<a target='_blank' href='https://github.com/AleMorales/VPL.jl/blob/5958cb5f2472fe814ba61832037cd95c2988bab5/src/Core/Context.jl#LL262-L266' class='documenter-source'>source</a><br>\n\n<a id='VPL.Core.descendent-Tuple{VPL.Core.Context}' href='#VPL.Core.descendent-Tuple{VPL.Core.Context}'>#</a>\n**`VPL.Core.descendent`** &mdash; *Method*.\n\n\n\n```julia\ndescendent(c::Context; condition = x -> true, maxlevel::Int = typemax(Int))\n```\n\nReturns the first descendent of a node that matches the `condition`. Intended to  be used within a rule or query. \n\n**Details**\n\nIf `hasDescendent()` returns `false` for the same node and `condition`,  `descendent()` will return `missing`, otherwise it returns the `Context`  associated to the matching node.\n\n**Return**\n\nReturn a `Context` object or `missing`.\n\n**Examples**\n\n```julia\nlet\n    struct A1 <: Node val::Int end\n    struct B1 <: Node val::Int end\n    axiom = A1(1) + (B1(1) + A1(3), B1(4))\n    g = Graph(axiom = axiom)\n    function qfun(n)\n        na = descendent(n, condition = x -> (data(x).val == 1))\n        if !ismissing(na)\n            data(na) isa B1\n        else\n            false\n        end\n    end\n    Q1 = Query(A1, query = qfun)\n    R1 = apply(g, Q1)\n    Q2 = Query(B1, query = qfun)\n    R2 = apply(g, Q2)\n    (R1,R2)\nend\n```\n\n\n<a target='_blank' href='https://github.com/AleMorales/VPL.jl/blob/5958cb5f2472fe814ba61832037cd95c2988bab5/src/Core/Context.jl#LL271-L308' class='documenter-source'>source</a><br>\n\n\n<a id='Traversal-algorithms'></a>\n\n<a id='Traversal-algorithms-1'></a>\n\n# Traversal algorithms\n\n<a id='VPL.Core.traverse-Tuple{VPL.Core.Graph}' href='#VPL.Core.traverse-Tuple{VPL.Core.Graph}'>#</a>\n**`VPL.Core.traverse`** &mdash; *Method*.\n\n\n\n```julia\ntraverse(g::Graph; fun = () -> nothing)\n```\n\nIterates over all the nodes in the graph and execute for the function `fun` on each node\n\n**Arguments**\n\n  * `g::Graph`: The graph object that will be traversed.\n  * `fun`: A function or function-like object defined by the user that will be\n\napplied to each node. This argument is assigned by keyword.\n\n**Details**\n\nThis traveral happens in the order in which the nodes are stored in the graph. This order is arbitrary and may vary across executions of the code (it does not correspond to the order in which nodes are created). For algorithms that require a particular traveral order of the graph, see `traverseDFS` and `traverseBFS`.\n\nThis function does not store any results generated by `fun`. Hence, if the user wants to keep track of such results, they should be stored indirectly (e.g., via a global variable or internally by creating a functor).\n\nThe function or function-like object provided by the user should take only one argument that corresponds to applying `data()` to each node in the graph. Several methods of such function may be defined for different types of nodes in the graph. Since the function will use the data stored in the nodes, relations among nodes may not be used as input. For algorithms where relations among nodes are important, the user should be using queries instead (see `Query` and general VPL documentation).\n\n**Return**\n\nThis function returns nothing but `fun` may have side-effects.\n\n**Examples**\n\n```julia\nlet\n    struct A1 <: Node val::Int end\n    struct B1 <: Node val::Int end\n    struct Foo\n        vals::Vector{Int}\n    end\n    function (f::Foo)(x)\n        push!(f.vals, x.val)\n    end\n    f = Foo(Int[])\n    axiom = A1(2) + (B1(1) + A1(3), B1(4))\n    g = Graph(axiom = axiom)\n    traverse(g, fun = f)\n    f.vals\nend\n```\n\n\n<a target='_blank' href='https://github.com/AleMorales/VPL.jl/blob/5958cb5f2472fe814ba61832037cd95c2988bab5/src/Core/Algorithms.jl#LL7-L57' class='documenter-source'>source</a><br>\n\n<a id='VPL.Core.traverseDFS-Tuple{VPL.Core.Graph}' href='#VPL.Core.traverseDFS-Tuple{VPL.Core.Graph}'>#</a>\n**`VPL.Core.traverseDFS`** &mdash; *Method*.\n\n\n\n```julia\ntraverseDFS(g::Graph; fun = () -> nothing, ID = root(g))\n```\n\nIterates over all the nodes in the graph (depth-first order, starting at a any node) and execute for the function `fun` on each node\n\n**Arguments**\n\n  * `g::Graph`: The graph object that will be traversed.\n  * `fun`: A function or function-like object defined by the user that will be\n\napplied to each node. This argument is assigned by keyword.\n\n  * `ID`: The ID of the node where the traveral should start. This argument is\n\nassigned by keyword and is, by default, the root of the graph.\n\n**Details**\n\nThis traveral happens in a depth-first order. That is, all nodes in a branch of the graph are visited until reach a leaf node, then moving to the next branch. Hence, this algorithm should always generate the same result when applied to the same graph (assuming the user-defined function is not stochastic). For a version of this function that us breadth-first order see `traverseBFS`.\n\nThis function does not store any results generated by `fun`. Hence, if the user wants to keep track of such results, they should be stored indirectly (e.g., via a global variable or internally by creating a functor).\n\nThe function or function-like object provided by the user should take only one argument that corresponds to applying `data()` to each node in the graph. Several methods of such function may be defined for different types of nodes in the graph. Since the function will use the data stored in the nodes, relations among nodes may not be used as input. For algorithms where relations among nodes are important, the user should be using queries instead (see `Query` and general VPL documentation).\n\n**Return**\n\nThis function returns nothing but `fun` may have side-effects.\n\n**Examples**\n\n```julia\nlet\n    struct A1 <: Node val::Int end\n    struct B1 <: Node val::Int end\n    struct Foo\n        vals::Vector{Int}\n    end\n    function (f::Foo)(x)\n        push!(f.vals, x.val)\n    end\n    f = Foo(Int[])\n    axiom = A1(2) + (B1(1) + A1(3), B1(4))\n    g = Graph(axiom = axiom)\n    traverseDFS(g, fun = f)\n    f.vals\nend\n```\n\n\n<a target='_blank' href='https://github.com/AleMorales/VPL.jl/blob/5958cb5f2472fe814ba61832037cd95c2988bab5/src/Core/Algorithms.jl#LL66-L119' class='documenter-source'>source</a><br>\n\n<a id='VPL.Core.traverseBFS-Tuple{VPL.Core.Graph}' href='#VPL.Core.traverseBFS-Tuple{VPL.Core.Graph}'>#</a>\n**`VPL.Core.traverseBFS`** &mdash; *Method*.\n\n\n\n```julia\ntraverseBFS(g::Graph; fun = () -> nothing, ID = root(g))\n```\n\nIterates over all the nodes in the graph (breadth-first order, starting at a any node) and execute for the function `fun` on each node\n\n**Arguments**\n\n  * `g::Graph`: The graph object that will be traversed.\n  * `fun`: A function or function-like object defined by the user that will be\n\napplied to each node. This argument is assigned by keyword.\n\n  * `ID`: The ID of the node where the traveral should start. This argument is\n\nassigned by keyword and is, by default, the root of the graph.\n\n**Details**\n\nThis traveral happens in a breadth-first order. That is, all nodes at a given depth of the the graph are visited first, then moving on to the next level. Hence, this algorithm should always generate the same result when applied to the same graph (assuming the user-defined function is not stochastic). For a version of this function that us depth-first order see `traverseDFS`.\n\nThis function does not store any results generated by `fun`. Hence, if the user wants to keep track of such results, they should be stored indirectly (e.g., via a global variable or internally by creating a functor).\n\nThe function or function-like object provided by the user should take only one argument that corresponds to applying `data()` to each node in the graph. Several methods of such function may be defined for different types of nodes in the graph. Since the function will use the data stored in the nodes, relations among nodes may not be used as input. For algorithms where relations among nodes are important, the user should be using queries instead (see `Query` and general VPL documentation).\n\n**Return**\n\nThis function returns nothing but `fun` may have side-effects.\n\n**Examples**\n\n```julia\nlet\n    struct A1 <: Node val::Int end\n    struct B1 <: Node val::Int end\n    struct Foo\n        vals::Vector{Int}\n    end\n    function (f::Foo)(x)\n        push!(f.vals, x.val)\n    end\n    f = Foo(Int[])\n    axiom = A1(2) + (B1(1) + A1(3), B1(4))\n    g = Graph(axiom = axiom)\n    traverseBFS(g, fun = f)\n    f.vals\nend\n```\n\n\n<a target='_blank' href='https://github.com/AleMorales/VPL.jl/blob/5958cb5f2472fe814ba61832037cd95c2988bab5/src/Core/Algorithms.jl#LL140-L193' class='documenter-source'>source</a><br>\n\n\n<a id='Graph-visualization'></a>\n\n<a id='Graph-visualization-1'></a>\n\n## Graph visualization\n\n<a id='VPL.Core.draw-Tuple{VPL.Core.Graph}' href='#VPL.Core.draw-Tuple{VPL.Core.Graph}'>#</a>\n**`VPL.Core.draw`** &mdash; *Method*.\n\n\n\n```julia\ndraw(g::Graph; force = false, backend = \"native\", inline = false, \n     resolution = (1920, 1080), nlabels_textsize = 15, arrow_size = 15, \n     node_size = 5)\n```\n\nVisualize a graph as network diagram.\n\n**Arguments**\n\nAll arguments are assigned by keywords except the graph `g`.  \n\n  * `g::Graph`: The graph to be visualized.\n  * `force = false`: Force the creation of a new window to store the network\n\ndiagram.  \n\n  * `backend = \"native\"`: The graphics backend to render the network diagram. It\n\ncan have the values `\"native\"`, `\"web\"` and `\"vector\"`. See VPL documentation for details.  \n\n  * `inline = false`: Currently this argument does not do anything (will change in\n\nfuture versions of VPL).  \n\n  * `resolution = (1920, 1080)`: The resolution of the image to be rendered, in\n\npixels (online relevant for native and web backends). Default resolution is HD. \n\n  * `nlabels_textsize = 15`: Customize the size of the labels in the diagram.\n  * `arrow_size = 15`: Customize the size of the arrows representing edges in the\n\ndiagram.  \n\n  * `node_size = 5`: Customize the size of the nodes in the diagram.\n\n**Details**\n\nBy default, nodes are labelled with the type of data stored and their unique ID. See function `node_label()` to customize the label for different types of data.\n\nSee `export_graph()` to export the network diagram as a raster or vector image (depending on the backend). The function `calculate_resolution()` can be useful to ensure a particular dpi of the exported image (assuming some physical size).\n\nThe graphics backend will interact with the environment where the Julia code is being executed (i.e., terminal, IDE such as VS Code, interactive notebook such as Jupyter or Pluto). These interactions are all controlled by the graphics  package Makie that VPL relies on. Some details on the expected behavior specific to `draw()` can be found in the general VPL documentation as www.virtualplantlab.com\n\n**Return**\n\nThis function returns a Makie `Figure` object, while producing the visualization as a side effect.\n\n**Examples**\n\n```julia\nlet\n    struct A1 <: Node val::Int end\n    struct B1 <: Node val::Int end\n    axiom = A1(1) + (B1(1) + A1(3), B1(4))\n    g = Graph(axiom = axiom)\n    draw(g)\nend\n```\n\n\n<a target='_blank' href='https://github.com/AleMorales/VPL.jl/blob/5958cb5f2472fe814ba61832037cd95c2988bab5/src/Core/Draw.jl#LL115-L169' class='documenter-source'>source</a><br>\n\n<a id='VPL.Core.draw-Tuple{VPL.Core.StaticGraph}' href='#VPL.Core.draw-Tuple{VPL.Core.StaticGraph}'>#</a>\n**`VPL.Core.draw`** &mdash; *Method*.\n\n\n\n```julia\ndraw(g::StaticGraph; force = false, backend = \"native\", inline = false, \n     resolution = (1920, 1080), nlabels_textsize = 15, arrow_size = 15, \n     node_size = 5)\n```\n\nEquivalent to the method `draw(g::Graph; kwargs...)` but  to visualize static  graphs (e.g., the axiom of a graph).\n\n\n<a target='_blank' href='https://github.com/AleMorales/VPL.jl/blob/5958cb5f2472fe814ba61832037cd95c2988bab5/src/Core/Draw.jl#LL67-L74' class='documenter-source'>source</a><br>\n\n<a id='VPL.Core.node_label-Tuple{VPL.Core.Node, Any}' href='#VPL.Core.node_label-Tuple{VPL.Core.Node, Any}'>#</a>\n**`VPL.Core.node_label`** &mdash; *Method*.\n\n\n\n```julia\nnode_label(n::Node, id)\n```\n\nFunction to construct a label for a node to be used by `draw()` when visualizing. The user can specialize this method for user-defined data types to customize the  labels. By default, the type of data stored in the node and the unique ID of the node are used as labels.\n\n\n<a target='_blank' href='https://github.com/AleMorales/VPL.jl/blob/5958cb5f2472fe814ba61832037cd95c2988bab5/src/Core/Draw.jl#LL3-L10' class='documenter-source'>source</a><br>\n\n<a id='VPL.Core.export_graph-Tuple{Any}' href='#VPL.Core.export_graph-Tuple{Any}'>#</a>\n**`VPL.Core.export_graph`** &mdash; *Method*.\n\n\n\n```julia\nexport_graph(f; filename, kwargs...)\n```\n\nSave a network diagram generated by `draw()` to an external file.\n\n**Arguments**\n\n  * `f`: Object of type `Figure` return by `draw()`.\n  * `filename`: Name of the file where the diagram will be stored. The extension\n\nwill be used to determined the format of the image (see example below).\n\n**Details**\n\nInternally, `export_graph()` calls the `save()` method from the ImageIO package and its dependencies. Any keyword argument supported by the relevant save method  will be passed along by `export_graph()`. For example, exporting diagrams as PNG  allows defining the compression level as `compression_level` (see PNGFiles  package for details).\n\n**Return**\n\nThe function returns nothing but, if successful, it will generate a new file containing the network diagram in the appropiate format.\n\n**Examples**\n\n**Examples**\n\n```julia\nlet\n    struct A1 <: Node val::Int end\n    struct B1 <: Node val::Int end\n    axiom = A1(1) + (B1(1) + A1(3), B1(4))\n    g = Graph(axiom = axiom)\n    f = draw(g);\n    export_graph(f, filename = \"test.png\")\nend\n```\n\n\n<a target='_blank' href='https://github.com/AleMorales/VPL.jl/blob/5958cb5f2472fe814ba61832037cd95c2988bab5/src/Core/Draw.jl#LL176-L209' class='documenter-source'>source</a><br>\n\n<a id='VPL.Core.calculate_resolution-Tuple{}' href='#VPL.Core.calculate_resolution-Tuple{}'>#</a>\n**`VPL.Core.calculate_resolution`** &mdash; *Method*.\n\n\n\n```julia\ncalculate_resolution(;width = 1024/300*2.54, height = 768/300*2.54, \n                      format = \"raster\", dpi = 300)\n```\n\nCalculate the resolution required to achieve a specific `width` and `height`  (in cm) of the exported image, with a particular `dpi` (for raster formats).\n\n\n<a target='_blank' href='https://github.com/AleMorales/VPL.jl/blob/5958cb5f2472fe814ba61832037cd95c2988bab5/src/Core/Draw.jl#LL214-L220' class='documenter-source'>source</a><br>\n\n"},"formats":{"html":{"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":"auto","echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"markdown"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../styles.css"],"output-file":"Core.html"},"language":{},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.2.242","theme":{"light":"default","dark":"darkly"}},"extensions":{"book":{"multiFile":true}}}}}