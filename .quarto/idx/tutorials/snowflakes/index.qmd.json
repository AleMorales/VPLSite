{"title":"The Koch snowflake","markdown":{"yaml":{"title":"The Koch snowflake ","author":"Alejandro Morales Sierra","date":"last-modified","execute":{"cache":true}},"headingText":"Other snowflake fractals","containsRefs":false,"markdown":"\n\nIn this example, we create a Koch snowflake, which is one of the earliest fractals to be described. The Koch snowflake is a closed curve composed on multiple of segments of different lengths. Starting with an equilateral triangle, each segment in the snowflake is replaced by four segments of smaller length arrange in a specific manner. Graphically, the first four iterations of the Koch snowflake construction process result in the following figures (the green segments are shown as guides but they are not part of the snowflake):\n\n![First four iterations fo Koch snowflake fractal](./KochWikipedia.png)\n\nIn order to implement the construction process of a Koch snowflake in VPL we need to understand how a 3D structure can be generated from a graph of nodes. VPL uses a procedural approach to generate of structure based on the concept of turtle graphics.\n\nThe idea behind this approach is to imagine a turtle located in space with a particular position and orientation. The turtle then starts consuming the different nodes in the graph (following its topological structure) and generates 3D structures as defined by the user for each type of node. The consumption of a node may also include instructions to move and/or rotate the turtle, which allows to alter the relative position of the different 3D structures described by a graph.\n\nThe construction process of the Koch snowflake in VPL could then be represented by the following axiom and rewriting rule:\n\naxiom: E(L) + RU(120) + E(L) + RU(120) + E(L)  \nrule:  E(L) → E(L/3) + RU(-60) + E(L/3) + RU(120) + E(L/3) + RU(-60) + E(L/3)\n\nWhere E represent and edge of a given length (given in parenthesis) and RU represents a rotation of the turtle around the upward axis, with angle of rotation given in parenthesis in hexadecimal degrees. The rule can be visualized as follows:\n\n![Koch construction rule](./Koch_order_1.png)\n\nNote that VPL already provides several classes for common turtle movements and rotations, so our implementation of the Koch snowflake only needs to define a class to implement the edges of the snowflake. This can be achieved as follows:\n\n```{julia}\nusing VPL\nmodule sn\n    import VPL\n    struct E <: VPL.Node\n        length::Float64\n    end\nend\nimport .sn\n```\n\nNote that nodes of type E need to keep track of the length as illustrated in the above. The axiom is straightforward:\n\n```{julia}\nconst L = 1.0\naxiom = sn.E(L) + VPL.RU(120.0) + sn.E(L) + VPL.RU(120.0) + sn.E(L)\n```\n\nThe rule is also straightforward to implement as all the nodes of type E will be replaced in each iteration. However, we need to ensure that the length of the new edges is a calculated from the length of the edge being replaced. In order to extract the data stored in the node being replaced we can simply use the function data. In this case, the replacement function is defined and then added to the rule. This can make the code more readable but helps debugging and testing the replacement function.\n\n```{julia}\nfunction Kochsnowflake(x)\n    L = data(x).length\n    sn.E(L/3) + RU(-60.0) + sn.E(L/3) + RU(120.0) + sn.E(L/3) + RU(-60.0) + sn.E(L/3)\n end\n rule = Rule(sn.E, rhs = Kochsnowflake)\n```\n\nThe model is then created by constructing the graph\n\n```{julia}\nKoch = Graph(axiom, rules = Tuple(rule))\n```\n\nIn order to be able to generate a 3D structure we need to define a method for the function `VPL.feedgeom!` (notice the need to prefix it with `VPL.` as we are going to define a method for this function). The method needs to two take two arguments, the first one is always an object of type MTurtle and the second is an object of the type for which the method is defined (in this case, E).\n\nThe body of the method should generate the 3D structures using the geometry primitives provided by VPL and feed them to the turtle that is being passed to the method as first argument. In this case, we are going to represent the edges of the Koch snowflakes with cylinders, which can be generated with the `HollowCylinder!` function from VPL. Note that the `feedgeom!` should return `nothing`, the turtle will be modified in place (hence the use of `!` at the end of the function as customary in the VPL community):\n\n```{julia}\nfunction VPL.feedgeom!(turtle::MTurtle, e::sn.E)\n    HollowCylinder!(turtle, l = e.length, w = e.length/10, h = e.length/10, move = true)\n    return nothing\nend\n```\n\nNote that the argument `move = true` indicates that the turtle should move forward as the cylinder is generated a distance equal to the length of the cylinder.\n\nWith the `feedgeom!` method defined we can already generate the 3D structure, but we cannot render it yet as we also need to define the color with which to render it. This is achieved by defining the `VPL.feedcolor!` method that takes a `GLTurtle` as argument (notice the different data types, `MTurtle` to collect triangular meshes, `GLTurtle` to collect colors for rendering). In this case, we just feed a basic `RGB` color defined by the proportion of red, green and blue. To make the figures more appealing, we can assign random values to each channel of the color to generate random colors.\n\n```{julia}\nfunction VPL.feedcolor!(turtle::GLTurtle, e::sn.E)\n    feedcolor!(turtle, RGB(rand(), rand(), rand()))\n    return nothing\nend\n```\n\nAfter defining these two methods, we can now call the function render on the graph to generate a 3D interactive image of the Koch snowflake in the current state\n\n```{julia}\nrender(Koch, axes = false)\n```\n\nThis renders the initial triangle of the construction procedure of the Koch snowflake. Let's execute the rules once to verify that we get the 2nd iteration (check the figure at the beginning of this document):\n\n```{julia}\nrewrite!(Koch)\nrender(Koch, axes = false)\n```\n\nAnd two more times\n\n```{julia}\nfor i in 1:3\n    rewrite!(Koch)\nend\nrender(Koch, axes = false)\n```\n\n\nTo demonstrate the power of this approach, let's create an alternative snowflake. We will simply invert the rotations of the turtle in the rewriting rule\n\n```{julia}\nfunction Kochsnowflake2(x)\n   L = data(x).length\n   sn.E(L/3) + RU(60.0) + sn.E(L/3) + RU(-120.0) + sn.E(L/3) + RU(60.0) + sn.E(L/3)\nend\nrule2 = Rule(sn.E, rhs = Kochsnowflake2)\nKoch2 = Graph(axiom, rules = Tuple(rule2))\n```\n\nThe axiom is the same, but now the edges added by the rule will generate the edges towards the inside of the initial triangle. Let's execute the first three iterations and render the results\n\n```{julia}\n# First iteration\nrewrite!(Koch2)\nrender(Koch2, axes = false)\n# Second iteration\nrewrite!(Koch2)\nrender(Koch2, axes = false)\n# Third iteration\nrewrite!(Koch2)\nrender(Koch2, axes = false)\n```\n\nThis is know as [Koch antisnowflake](https://mathworld.wolfram.com/KochAntisnowflake.html). We could also easily generate a [Cesàro fractal](https://mathworld.wolfram.com/CesaroFractal.html) by also changing the axiom:\n\n```{julia}\naxiomCesaro = sn.E(L) + RU(90.0) + sn.E(L) + RU(90.0) + sn.E(L) + RU(90.0) + sn.E(L)\nCesaro = Graph(axiomCesaro, rules = (rule2,))\nrender(Cesaro, axes = false)\n```\n\nAnd, as before, let's go through the first three iterations\n\n```{julia}\n# First iteration\nrewrite!(Cesaro)\nrender(Cesaro, axes = false)\n# Second iteration\nrewrite!(Cesaro)\nrender(Cesaro, axes = false)\n# Third iteration\nrewrite!(Cesaro)\nrender(Cesaro, axes = false)\n```"},"formats":{"html":{"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":true,"freeze":"auto","echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"jupyter"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../../styles.css"],"output-file":"index.html"},"language":{},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.2.242","theme":{"light":"default","dark":"darkly"},"title":"The Koch snowflake ","author":"Alejandro Morales Sierra","date":"last-modified"},"extensions":{"book":{"multiFile":true}}}}}