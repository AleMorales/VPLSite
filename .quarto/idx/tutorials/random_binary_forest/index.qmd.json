{"title":"Random binary tree","markdown":{"yaml":{"title":"Random binary tree","author":"Alejandro Morales Sierra","date":"last-modified","execute":{"cache":true}},"headingText":"Sequential simulation","containsRefs":false,"markdown":"\n\nIn this example we extend the binary tree example into a random binary forest, where\neach tree is described by a separate graph object and parameters driving the\ngrowth of these trees vary across individuals following a predefined distribution.\n\nThe data types, rendering methods and growth rules are the same as in the binary\ntree example:\n\n```{julia}\nusing VPL\n\nmodule rbtree\n    import VPL\n    # Meristem\n    struct Meristem <: VPL.Node end\n    # Node\n    struct Node <: VPL.Node end\n    # Internode\n    mutable struct Internode <: VPL.Node\n        length::Float64\n    end\n    struct treeparams\n        growth::Float64\n    end\nend\n\nfunction VPL.feedgeom!(turtle::MTurtle, i::rbtree.Internode)\n    HollowCube!(turtle, l = i.length, h =  min(i.length/10, 0.3), w =  min(i.length/10, 0.3), move = true)\n    return nothing\nend\nfunction VPL.feedcolor!(turtle::GLTurtle, i::rbtree.Internode)\n    feedcolor!(turtle, RGB(0,1,0))\n    return nothing\nend\n\nrule = Rule(rbtree.Meristem, rhs = mer -> rbtree.Node() + \n                                         (RU(-60.0) + rbtree.Internode(0.1) + RH(90.0) + rbtree.Meristem(), \n                                          RU(60.0)  + rbtree.Internode(0.1) + RH(90.0) + rbtree.Meristem()))\n\n```\n\nThe main difference with respect to the binary tree is that the  `growth` parameter\n will differ across individuals. Also, the starting\npoint of the turtle will differ per individual. To achieve this we need to:\n\n(i) Add an additional initial node that moves the turtle to the starting position\nof each binary tree.\n\n(ii) Wrap the axiom rule and the creation of the graph into a function that takes\nthe required parameters as inputs.\n\n```{julia}\nfunction create_tree(origin, growth)\n    axiom = T(origin) + rbtree.Internode(0.1) + rbtree.Meristem()\n    tree = Graph(axiom, Tuple(rule), rbtree.treeparams(growth))\n    return tree\nend\n```\n\nThe code for elongating the internodes to simulate growth remains the same as for\nthe binary tree example\n\n```{julia}\ngetInternode = Query(rbtree.Internode)\n\nfunction elongate!(tree, query)\n    for x in apply(tree, query)\n        x.length = x.length*(1.0 + vars(tree).growth)\n    end\nend\n\nfunction growth!(tree, query)\n    elongate!(tree, query)\n    rewrite!(tree)\nend\n\nfunction simulate(tree, query, nsteps)\n    new_tree = deepcopy(tree)\n    for i in 1:nsteps\n        growth!(new_tree, query)\n    end\n    return new_tree\nend\n```\n\nLet's simulate a forest of 10 x 10 binary trees with a distance between (and within) rows\nof 2 meters. First we generate the original\npositions of the trees. For the position we just need to pass a `Vec` object with the\nx, y, and z coordinates of the location of each tree. The code below will generate \na matrix with the coordinates:\n\n```{julia}\norigins = [Vec(i,j,0) for i = 1:2.0:20.0, j = 1:2.0:20.0]\n```\n\nWe now simulate the values of the `growth` parameter, by sampling values for a normal\ndistribution (in practice you would determine this distribution from experiments). \nWe can implement a function that returns random values with the desired characteristics but\ntake into account that `randn` implements the standard Normal distribution (so mean = 0 and \nstandard deviation = 1) so we need to scale it\n\n```{julia}\ngrowth_distr(n) = 0.5 .+ randn(n)./10\n```\n\nYou may also use the Distributions Julia package (you will need to install it first) that allows to\nconstruct different distributions and sample from them. For now, let's work with this ad-hoc function\nbut before we use it to generate the growth parameters of the different trees, let's visualize it\nusing the Plots package (as before, you need to install it first if you have not done so already):\n\n```{julia}\nusing Plots\nhistogram(growth_distr(10_000))\n```\n\nSo our trees will have, on average, a relative growth rate of 0.5 (like in the binary tree example) but\neach individual tree can have any value, mostly between 0.2 and 0.8. Let's generate the growth parameters\nfor the 100 trees in our simulation:\n\n```{julia}\ngrowths = growth_distr(100);\n```\n\nNow we can create our random forest of binary trees by calling the `create_tree` function we defined earlier\nwith the correct origins and growth parameter\n\n```{julia}\nforest = [create_tree(origins[i], growths[i]) for i in 1:100];\n```\n\nThe object `forest` contains an array of binary trees. Each tree is a different Graph, with\nits own nodes, rewriting rules and variables. This avoids having to create a large graphs to\ninclude all the plants in a simulation. Below we will run a simulation, first using a sequential\napproach (i.e. using one core) and then using multiple cores in our computers (please check\nhttps://docs.julialang.org/en/v1/manual/multi-threading/ if the different cores are not being used\nas you may need to change some settings in your computer).\n\n\nWe can simulate the growth of each tree by applying the method `simulate` to each\ntree, creating a new version of the forest (the code below is an array comprehension)\n\n```{julia}\nnewforest = [simulate(tree, getInternode, 2) for tree in forest];\n```\n\nAnd we can render the forest with the function `render` as in the binary tree\nexample but passing the whole forest at once\n\n```{julia}\nrender(newforest)\n```\n\nIf we iterate 4 more iterations we will start seeing the different individuals\ndiverging in size due to the differences in growth rates\n\n```{julia}\nnewforest = [simulate(tree, getInternode, 4) for tree in newforest];\nrender(newforest)\n```\n\n## Multithreaded simulation\n\nIn the previous section, the simulation of growth was done sequentially, one tree\nafter another (since the growth of a tree only depends on its own parameters). However,\nthis can also be executed in multiple threads. In this case we use an explicit loop \nand execute the iterations of the loop in multiple threads using the macro `@threads`.\nNote that the rendering function can also be ran in parallel (i.e. the geometry will be\ngenerated separately for each plant and the merge together):\n\n```{julia}\nusing Base.Threads\nnewforest = deepcopy(forest)\n@threads for i in 1:length(forest)\n    newforest[i] = simulate(forest[i], getInternode, 6)\nend\nrender(newforest, parallel = true)\n```\n\nAn alternative way to perform the simulation is to have an outer loop for each timestep and an internal loop over the different trees. Although this approach is not required for this simple model, most FSP models will probably need such a scheme as growth of each individual plant will depend on competition for resources with neighbouring plants. In this case, this approach would look as follows:\n\n```{julia}\nnewforest = deepcopy(forest)\nfor step in 1:6\n    @threads for i in 1:length(newforest)\n        newforest[i] = simulate(newforest[i], getInternode, 1)\n    end\nend\nrender(newforest, parallel = true)\n```\n\n# Customizing the scene\n\nHere we are going to customize the scene of our simulation by adding a horizontal tile represting soil and\ntweaking the 3D representation. When we want to combine plants generated from graphs with any other\ngeometric element it is best to combine all these geometries in a `GLScene` object. We can start the scene\nwith the `newforest` generated in the above:\n\n```{julia}\nscene = GLScene(newforest);\n```\n\nWe can create the soil tile directly, without having to create a graph. The simplest approach is two use \na special constructor `Rectangle` where one species a corner of the rectangle and two vectors defining the\ntwo sides of the vectors. Both the sides and the corner need to be specified with `Vec` just like in the\nabove when we determined the origin of each plant. VPL offers some shortcuts: `O()` returns the origin\n(`Vec(0.0, 0.0, 0.0)`), whereas `X`, `Y` and `Z` returns the corresponding axes and you can scale them by \npassing the desired length as input. Below, a rectangle is created on the XY plane with the origin as a \ncorner and each side being 11 units long:\n\n```{julia}\nsoil = Rectangle(O(), Y(21.0), X(21.0)); # (corner, side1, side2)\n```\n\nWe can now add the `soil` to the `scene` object with the `add!` function.\n```{julia}\nVPL.add!(scene = scene, mesh = soil, color = RGB(1,1,0))\n```\n\nWe can now render the scene that combines the random forest of binary trees and a yellow soil. Notice that\nin all previous figures, a coordinate system with grids was being depicted. This is helpful for debugging\nyour code but also to help setup the scene (e.g. if you are not sure how big the soil tile should be).\nHowver, it may be distracting for the visualization. It turns out that we can turn that off with\n`show_axes = false`:\n\n```{julia}\nrender(scene, axes = false)\n```\n\nWe may also want to save a screenshot of the scene. For this, we need to store the output of the `render` function.\nWe can then resize the window rendering the scene, move around, zoom, etc. When we have a perspective that we like,\nwe can run the `save_scene` function on the object returned from `render`. The argument `resolution` can be adjust in both\n`render` and `save_scene` (the image will have the correct number of pixels but it looks much worse than in the original\nwindow...):\n\n```{julia}\n#| eval: false\noutput = render(scene, axes = false)\n# Play around with the scene\nexport_scene(\"nice_trees.png\", output) \n```\n"},"formats":{"html":{"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":true,"freeze":"auto","echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"jupyter"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../../styles.css"],"output-file":"index.html"},"language":{},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.2.242","theme":{"light":"default","dark":"darkly"},"title":"Random binary tree","author":"Alejandro Morales Sierra","date":"last-modified"},"extensions":{"book":{"multiFile":true}}}}}