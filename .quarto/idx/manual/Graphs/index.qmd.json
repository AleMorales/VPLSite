{"title":"Dynamic graph creation and manipulation","markdown":{"yaml":{"title":"Dynamic graph creation and manipulation","author":"Alejandro Morales Sierra","date":"last-modified","execute":{"cache":true}},"headingText":"Graphs, Rules and Queries","containsRefs":false,"markdown":"\n\n\nA model in VPL is a (discrete) dynamical model that describes the time evolution \nof one or more entities (i.e. objects of type `graph`). Each graph  (usually \nassumed to be an individual plant) is characterized by a series of nodes \n(usually organs) that are represented by nodes in a graph. Each node is \ndefined by its own state, including (if applicable) a description of its geometry, \ncolor, optical propertes, etc. The dynamic simulation of a graph consists of the \ncreation and destruction of nodes via graph rewriting rules, and changes to \nthe internal state of its nodes with the help of queries.\n\nThe 3D structure of a graph is generated by processing its nodes using a \n**Turtle** procedural geometry approach (i.e. inspired on Logo's turtle graphs \nas used in L-systems) and following the topology of the graph. This 3D structure \nmay be used for visualization using a 3D renderer or for simulating  spatial \nprocesses.\n\nVPL does not provide a domain-specific language to implement rules and queries. \nRather, they are defined by functions which are stored in objects of types `Rule` \nand `Query`, respectively. Similarly, the nodes of a graph can be of any \nuser-defined type, as long as the user defines the necessary methods to support \nspecific functionality (e.g. the `feed!` method to generate geometry).\n\nVPL is designed around data types and methods. Building a model in VPL typically\nrequires:\n\n* Defining types for the different classes of nodes of a graph\n* Creating rules and queries based on these types\n* Creating graphs by combining rules and the initial states of the graphs\n* Creating additional elements in the scene (e.g. soil)\n\nA simulation in VPL consists of executing rules iteratively and, within each iteration:\n\n* Use queries to select subset of nodes and modify their states.\n* Modify graph-level variables directly.\n* Use algorithms in VPL to simulate interactions among nodes or between nodes and their environment.\n\nIn addition, VPL allows visualizing the results of a simulation by:\n* 3D rendering of the generated scenes\n* Network graph representing the nodes in the graph\n\nVPL is designed to facilitate modular model development, such as using different \ntypes of graphs in the same simulation, alternative visualizations of the same \nscene by mapping internal states of nodes to colors, or including multiple \nray tracers in the same simulation. Users may also create their own data types \nthat include graphs as fields or to nest graphs within other graphs.\n\n# Graph\n\nA graph is the basic unit of a model in VPL. Three types of data are stored \ninside a graph:\n\n* Components of the graph.\n* Graph rewriting rules.\n* An user-defined object that characterizes the state of a graph besides its nodes (i.e. graph-level variables).\n\nThe nodes of a graph are objects created by the user that inherit from the \nabstract type `Node`. This abstract type enables describing the relationship \nbetween nodes using a simple algebra for graph construction (see below). A \ngraph always needs to be initialized by at least one node (i.e. analogous \nto the axiom of L-Systems), as otherwise graph rewriting rules could not be \napplied.\n\nThe creation of a graph is achieved with the constructor `graph(axiom, rules[, vars])` \nwhere `axiom`, `rules` and `vars` are the axiom, a tuple with \nthe graph rewriting rules and an user-defined object that stores all graph-level \nvariables, respectively. Note that the last argument is optional. The method \n`rewrite!(graph)` takes a graph as input and executes the graph rewriting rules, \nupdating the internal state of the graph in-place. Note that this method will not\nbe called implicitly: it is the responsability of the user to decide when to call\nthis method.\n\nThe system is designed to allow rewriting of graphs in parallel, including shared\nmemory approaches such as multi-threading with the `Threads.@threads` macro. This\nis ensured by deep-copying `axiom`, `rules` and `vars` so that changes in one \ngraph do not affect other graphs that may be built from the same axioms and rules.\nIf the user wants some state to be shared across graphs, they should define a global \nvariable that is modified during execution of rules. If such approach is used,\nit is the responsibility of the user to ensure that updates to such global variables\nare properly locked or executed atomatically.\n\n## Graph-construction algebra\n\nWhen initializing a graph and when specifying a graph rewriting rule it is \nnecessary to indicate the topological relationship between the nodes being \nadded to a graph (i.e. effectively we build graphs by appending sub-graphs). In \norder to facilitate the description of these relationships, a simple algebra is \ndefined for all objects that inherit from `Node`.\n\nThe `+` operator indicates a linear parent-child dependency between the operands. \nFor example, `M() + L()` indicates that the object generated by `L()` is a child \nof `M()`. A branching point is introduced by enclosing the children of a node \nwithin `()` and separating the different branches with \",\". For example, \n`(M(1) + (L(2), L(3)) + M(4) + L(5))` creates a tree that starts with `M(1)`, \nhas 3 children (`L(2)`, `L(3)` and `M(4)`) and `M(4)` has a child `L(5)`.\n\nA graph always keep tracks of two special nodes: the root and the insertion point. \nThe root is the node that has no parent. When you use a graph rewriting rule (see \nbelow) to replace a node *a* with a graph that has a root node *b*, the result is \nthat node *a* is replaced by node *b* and will inherit all the children and parent \nfrom node *a* (plus the children that *b* already had in the replacement graph).\n\nAn insertion point is the node of a graph where new nodes will be connected to \nwhen using the `+` operator. Branches do not modify the insertion point of an \nexisting graph, but linear addition of nodes will always update the insertion \npoint to the last node. Thus, these two expressions produce the same tree \nstructure but with different insertion points: `M(1) + (L(2), L(3)) + M(4) + L(5)` \nand `M(1) + (L(2), L(3), M(4) + L(5))`. In the first case, the insertion point \nbecomes the node `L(5)` but in the second case it remains at `M(1)`. Keeping \ntrack of the insertion point of a graph is important when building  a graph in \nseveral steps.\n\n# Rules\n\nRules consist of directives that define the dynamic evolution of the nodes \nthat form a graph, by replacing a subset of the nodes by one or more nodes. \nRules are not executed directly by the user. Instead, they are stored in the \ngraph and executed by the method `rewrite!`. A rule is made of three parts:\n\n* The type of node to be replaced.\n* A function to determine whether a candidate node is to be replaced  or not (**lhs** function)\n* A function that generates a node or subgraph to use as replacement (**rhs** function).\n\nThe first part must always be present, as it represents the minimum information \nrequired to match the rule against nodes inside a graph. This type must be \nthe concrete type of the node rather an abstract type or union type from \nwhich the node may inherit. The lhs and rhs functions are optional with the \nfollowing default values if missing:\n\n* lhs: `x -> true`\n* rhs: `x -> nothing`\n\nA rule with a missing lhs will match all the nodes of the specified type. A \nrule without an rhs will remove any matched node and all of its children \n(recursively, such that the topological tree is pruned).\n\n\nA `Context` object includes the data stored inside a node plus its relationship \nwith other nodes in the graph, as well as a reference to the graph-level \nvariables. In order to extract the data stored in the node use the function \n`data()`. In order to extract the object containing all the graph-level variables, \nuse the method `vars`. The `Context` object may also be used to access other nodes \nby walking through the graph (see below).\n\nFor rules that do not capture the context of a node, the lhs part \nis a function that takes an object of type `Context` and returns `true` or `false`, \nwhereas the rhs part is a function that takes a `Context` object and returns a \nnode or subgraph.\n\nAlthough rules may also be used to update the internal state of a node (i.e. \nby creating a new node of the same type but with a different state), this is only \nrequired when the node is an immutable type. Otherwise, one can also (and \nit is recommended to) use a query for better performance (see below).\n\n## Matching relationships among nodes\n\nSometimes the lhs function needs to check the relationships between nodes \ninside a graph (e.g. match all leaves that belong to a particular branch of a \ngraph). In order achieve that, one can use the functions `hasParent()` and `hasChildren()` to \ncheck for inmediate connections (i.e. effectively to check whether the node is a \nroot or a leaf in the graph) whereas `hasAncestor()` and `hasDescendant()` allow \ntraversing the graph and finding any connected node that matches a specific query. \nIf we need to extract the contents of the node, we may use the corresponding \nfunctions `parent()`, `children()`, `ancestor()` and `descendant()`. Note that `children()` \nwill return all the children nodes as a tuple, but the rest of functions only \nreturn one node at a time. All these functions take a `Context` object as input \nand return either `true` or `false` (for the functions that start with `has`) or a \n`Context` or tuple of `Context` objects for the functions that extract the actual \nconnected node. These methods may also be used inside the rhs function of rules. \nHowever, to avoid code repetition (and for performance reasons), it is recommended \nto *capture* the `Context` objects of connected in the lhs function and pass \nthem to the rhs as described below (see below).\n\n <!-- TODO: Add a table with the inputs and outputs of each graph-related method -->\n\n## Capturing the context of a node\n\nIn some scenarios, knowing the relationship between nodes in the graph \nis not sufficient, because data stored inside those related nodes is required \nin the rhs function of a rule. In those cases, an extra argument to the constructor for a \n`Rule` is required (`captures = true`) to indicate that this rule will pass \nadditional data from the lhs to the rhs function. Then, the lhs function should \nreturn a tuple, where the first element is still `true` or `false` (to indicate \nwhether the rule matches a node) and the second element is a tuple of \n`Context` objects associated to the nodes being matched. If no match occurs, \nit is sufficient to return `(false, ())`, where `()` indicates an empty tuple. \nThe rhs function should then be a function that takes as first argument the \n`Context` object of the node being replaced, and an additional argument for \nevery `Context` object being captured on the lhs function and passed to the rhs \nfunction.\n\n## Execution of rules\n\nRules are executed in the same order in which they are added to the graph object. \nThen, the lhs part of each rule is tested against all nodes of the specified \ntype in the same order in which they were added to the graph. Similarly, the rhs \npart of a rule will be applied to those nodes that matched the lhs part, in \nthe same order as in the matching.\n\n<!-- TODO: Diagram on rule execution -->\n\nThe lhs part of all the rules are executed first and VPL will check that each \nnode is not matched by more than rule. In case there is more than one match, \nan error will be generated. After all the lhs pars are executed, then the rhs parts \nare executed on the matched nodes. Although generating an error may seem \nrestrictive, the  reasoning for this approach is as follows:\n\n* Graph rewriting is, conceptually, a parallel operation, so two rules cannot replace the same node as that would mean the result depends on the order in which the rules are executed.\n\n* New nodes will be generated by graph rewriting rules that could be matched by the lhs of other graph rewriting rules. To guarantee that all rules rewrite the same graph, all nodes that need to be replaced are identified before any rhs function is executed. \n\nIn essence, you need to program your model such that it does not rely on any specific order of execution of the graph rewriting rules.\n\n# Query and `apply`\n\nThe `apply()` function will apply a `Query` object to a graph and return a list of \nnodes that match the query. The main differences between rules and queries is that queries \ndo not have an rhs part,they are not stored inside the graph and the user \ndecides when to apply them. Note that that a query does not modify a graph, \nit simply returns a collection of nodes matched by it. Another difference is that \na query always return a reference to the data stored  inside the node, rather \nthan a `Context` object (so no need to use `data()`). Note that if a query is used \nto modify the data stored in a node, then the node needs to be a mutable type.\n\nFor nodes of immutable type, a graph rewriting rule must be used to replace \nthe node. This may seem like a limitation but the fact is that, if one needs \nto modify the state of an object after it has been created then, by definition, \nthat object should be of mutable type. If immutability is required for some reason, \none may keep track of associated variables at the graph level, but such kind of \nmanual book-keeping is not recommended.\n\nA query is useful when the data stored inside the nodes of a graph need to \nbe modified or when these data are used as input for some function. Unlike in \nrules, the order in which queries are applied in the code will affect the result of \nthe simulation, especially whether they are applied before or after a call to \n`rewrite!`. The reasoning for this is that queries are not altering the structure \nof a graph (since they do not remove nor create nodes) and multiple queries \ncan (and often do) match the same node. For example, one query will alter \nan internal variable that is then need as input by another query. Thus, whereas \nrules implicitly follow a parallel programming paradigm, queries follow a \nsequential programming paradigm.\n\n<!-- TODO: Diagram that clarifies differences between rules and queries -->"},"formats":{"html":{"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":true,"freeze":"auto","echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"markdown"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../../styles.css"],"output-file":"index.html"},"language":{},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.2.313","theme":{"light":"default","dark":"darkly"},"title":"Dynamic graph creation and manipulation","author":"Alejandro Morales Sierra","date":"last-modified"},"extensions":{"book":{"multiFile":true}}}}}