[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site!"
  },
  {
    "objectID": "api/Core.html#types",
    "href": "api/Core.html#types",
    "title": "Virtual Plant Laboratory",
    "section": "Types",
    "text": "Types\n# VPL.Core.Graph — Type.\nGraph(;axiom, rules = nothing, vars = nothing)\nCreate a dynamic graph from an axiom, one or more rules and, optionally, graph-level variables.\nArguments\n\naxiom: A single object inheriting from Node or a subgraph generated with\n\nthe graph construction DSL. It should represent the initial state of the dynamic graph.\n\nrules: A single Rule object or a tuple of Rule objects (optional). It\n\nshould include all graph-rewriting rules of the graph.\n\nvars: A single object of any user-defined type (optional). This will be the\n\ngraph-level variable accessible from any rule or query applied to the graph.\n\nFT: Floating-point precision to be used when generating the 3D geometry\n\nassociated to a graph.\nDetails\nAll arguments are assigned by keyword. The axiom and rules are deep-copied when creating the graph but the graph-level variables (if a copy is needed due to mutability, the user needs to care of that).\nReturn\nAn object of type Graph representing a dynamic graph. Printing this object results in a human-readable description of the type of data stored in the graph.\nExamples\nlet\n    struct A0 <: Node end\n    struct B0 <: Node end\n    axiom = A0() + B0()\n    no_rules_graph = Graph(axiom = axiom)\n    rule = Rule(A, rhs = x -> A0() + B0())\n    rules_graph = Graph(axiom = axiom, rules = rule)\nend\nsource\n# VPL.Core.Rule — Type.\nRule(nodetype; lhs = x -> true, rhs = x -> nothing, captures = false)\nCreate a replacement rule for nodes of type nodetype.\nArguments\n\nnodetype: Type of node to be matched.\nlhs: Function or function-like object that takes a Context object and\n\nreturns whether the node should be replaced or not (with true or false).\n\nrhs: Function or function-like object that takes one or more Context\n\nobjects and returns a replacement graph or nothing. If it takes several inputs, the first one will correspond to the node being replaced.\n\ncaptures: Either false or true to indicate whether the left-hand side\n\nof the rule is capturing nodes in the context of the replacement node to be used for the construction of the replace graph.\nDetails\nSee VPL documentation for details on rule-based graph rewriting.\nReturn\nAn object of type Rule.\nExamples\nlet\n    struct A <: Node end\n    struct B <: Node end\n    axiom = A() + B()\n    rule = Rule(A, rhs = x -> A() + B())\n    rules_graph = Graph(axiom = axiom, rules = rule)\n    rewrite!(rules_graph)\nend\nsource\n# VPL.Core.Query — Type.\nQuery(nodetype::DataType; condition = x -> true)\nCreate a query that matches nodes of type nodetype and a condition.\nArguments\n\nnodetype::DataType: Type of node to be matched.\ncondition: Function or function-like object that checks if a node should be\n\nselected. It is assigned as a keyword argument.\nDetails\nIf the nodetype should refer to a concrete type and match one of the types stored inside the graph. Abstract types or types that are not contained in the graph are allowed but the query will never return anything.\nThe condition must be a function or function-like object that takes a Context as input and returns true or false. The default condition always return true such that the query will\nReturn\nIt returns an object of type Query. Use apply() to execute the query on a dynamic graph.\nExample\nstruct A <: Node end\nstruct B <: Node end\naxiom = A() + B()\ngraph = Graph(axiom)\nquery = Query(A)\napply(graph, query)\nsource\n# VPL.Core.Node — Type.\nNode\nAbstract type from which every node in a graph should inherit. This allows using the graph construction DSL.\nExample\nlet\n  struct bar <: Node\n    x::Int\n  end\n  b1 = bar(1)\n  b2 = bar(2)\n  b1 + b2\nend\nsource\n# VPL.Core.Context — Type.\nContext\nData structure than links a node to the rest of the graph.\nFields\n\ngraph: Dynamic graph that contains the node.\nnode: Node inside the graph.\n\nDetails\nA Context object wraps references to a node and its associated graph. The purpose of this structure is to be able to test relationships among nodes within a graph (from with a query or rule), as well as access the data stored in a node (with data()) or the graph (with vars()).\nUsers do not build Context objects directly but they are provided by VPL as inputs to the user-defined functions inside rules and queries.\nsource"
  },
  {
    "objectID": "api/Core.html#graph-dsl",
    "href": "api/Core.html#graph-dsl",
    "title": "Virtual Plant Laboratory",
    "section": "Graph DSL",
    "text": "Graph DSL\n# Base.:+ — Method.\n+(n1::Node, n2::Node)\nCreates a graph with two nodes where n1 is the root and n2 is the insertion point.\nExamples\nlet\n    struct A1 <: Node val::Int end\n    struct B1 <: Node val::Int end\n    axiom = A1(1) + B1(1)\n    draw(axiom)\nend\nsource\n# Base.:+ — Method.\n+(g::StaticGraph, n::Node)\nCreates a graph as the result of appending the node n to the insertion point of graph g.\nExamples\nlet\n    struct A1 <: Node val::Int end\n    struct B1 <: Node val::Int end\n    axiom = A1(1) + B1(1)\n    axiom = axiom + A1(2)\n    draw(axiom)\nend\nsource\n# Base.:+ — Method.\n+(n::Node, g::StaticGraph)\nCreates a graph as the result of appending the static graph g to the node n.\nExamples\nlet\n    struct A1 <: Node val::Int end\n    struct B1 <: Node val::Int end\n    axiom = A1(1) + B1(1)\n    axiom = A1(2) + axiom\n    draw(axiom)\nend\nsource\n# Base.:+ — Method.\n+(g1::StaticGraph, g2::StaticGraph)\nCreates a graph as the result of appending g2 to the insertion point of g1. The insertion point of the final graph corresponds to the insertion point of g2.\nExamples\nlet\n    struct A1 <: Node val::Int end\n    struct B1 <: Node val::Int end\n    axiom1 = A1(1) + B1(1)\n    axiom2 = A1(2) + B1(2)\n    axiom = axiom1 + axiom2\n    draw(axiom)\nend\nsource\n# Base.:+ — Method.\n+(g::StaticGraph, T::Tuple)\n+(n::Node, T::Tuple)\nCreates a graph as the result of appending a tuple of graphs/nodes T to the insertion point of the graph g or node n. Each graph/node in L becomes a branch.\nExamples\nlet\n    struct A1 <: Node val::Int end\n    struct B1 <: Node val::Int end\n    axiom = A1(1) + (B1(1) + A1(3), B1(4))\n    draw(axiom)\nend\nsource"
  },
  {
    "objectID": "api/Core.html#applying-rules-and-queries",
    "href": "api/Core.html#applying-rules-and-queries",
    "title": "Virtual Plant Laboratory",
    "section": "Applying rules and queries",
    "text": "Applying rules and queries\n# VPL.Core.apply — Method.\napply(g::Graph, query::Query)\nReturn an array with all the nodes in the graph that match the query supplied by the user.\nExample\nstruct A <: Node end\nstruct B <: Node end\naxiom = A() + B()\ngraph = Graph(axiom)\nquery = Query(A)\napply(graph, query)\nsource\n# VPL.Core.rewrite! — Method.\nrewrite!(g::Graph)\nApply the graph-rewriting rules stored in the graph.\nArguments\n\ng::Graph: The graph to be rewritten. It will be modified in-place.\n\nDetails\nThis function will match the left-hand sides of all the rules in a graph. If any node is matched by more than one rule this will result in an error. The rules are then applied in order to replaced the matched nodes with the result of executing the right hand side of the rules. The rules are applied in the order in which they are stored in the graph but the order in which the nodes are processed is not defined. Since graph rewriting is semantically a parallel process, the rules should not be rely on any particular order for their functioning.\nReturns\nThis function returns nothing, but the graph passed as input will be modified by the execution of the rules.\nExample\nlet\n    struct A <: Node end\n    struct B <: Node end\n    axiom = A() + B()\n    rule = Rule(A, rhs = x -> A() + B())\n    g = Graph(axiom = axiom, rules = rule)\n    rewrite!(g)\nend\nsource"
  },
  {
    "objectID": "api/Core.html#extracting-information",
    "href": "api/Core.html#extracting-information",
    "title": "Virtual Plant Laboratory",
    "section": "Extracting information",
    "text": "Extracting information\n# VPL.Core.vars — Method.\nvars(g::Graph)\nReturns the graph-level variables.\nExample\nstruct A <: Node end\naxiom = A()\ngraph = Graph(axiom, vars = 2)\nvars(graph)\nsource\n# VPL.Core.rules — Method.\nrules(g::Graph)\nReturns a tuple with all the graph-rewriting rules stored in a dynamic graph\nExamples\nstruct A <: Node end\nstruct B <: Node end\naxiom = A() + B()\nrule = Rule(A, rhs = x -> A() + B())\nrules_graph = Graph(axiom, rules = rule)\nrules(rules_graph)\nsource\n# VPL.Core.vars — Method.\nvars(c::Context)\nReturns the graph-level variables. Intended to be used within a rule or query.\nsource\n# VPL.Core.data — Method.\ndata(c::Context)\nReturns the data stored in a node. Intended to be used within a rule or query.\nsource"
  },
  {
    "objectID": "api/Core.html#node-relations",
    "href": "api/Core.html#node-relations",
    "title": "Virtual Plant Laboratory",
    "section": "Node relations",
    "text": "Node relations\n# VPL.Core.hasParent — Method.\nhasParent(c::Context)\nCheck if a node has a parent and return true or false. Intended to be used within a rule or query.\nsource\n# VPL.Core.isRoot — Method.\nisRoot(c::Context)\nCheck if a node is the root of the graph (i.e., has no parent) and return true or false. Intended to be used within a rule or query.\nsource\n# VPL.Core.hasAncestor — Method.\nhasAncestor(c::Context; condition = x -> true, maxlevel::Int = typemax(Int))\nCheck if a node has an ancestor that matches the condition. Intended to be used within a rule or query.\nArguments\n\nc::Context: Context associated to a node in a dynamic graph.\ncondition: An user-defined function that takes a Context object as input\n\nand returns true or false. It is assigned by the user by keyword.\n\nmaxlevel::Int: Maximum number of steps that the algorithm may take when\n\ntraversing the graph.\nDetails\nThis function traverses the graph from the node associated to c towards the root of the graph until a node is found for which condition returns true. If no node meets the condition, then it will return false. The defaults values for this function are such that the algorithm always returns true after one step (unless it is applied to the root node) in which case it is equivalent to calling hasParent on the node.\nThe number of levels that the algorithm is allowed to traverse is capped by maxlevel (mostly to avoid excessive computation, though the user may want to specify a meaningful limit based on the topology of the graphs being used).\nThe function condition should take an object of type Context as input and return true or false.\nReturn\nReturn a tuple with two values a Bool and an Int, the boolean indicating whether the node has an ancestor meeting the condition, the integer indicating the number of levels in the graph separating the node an its ancestor.\nExamples\nlet\n    struct A1 <: Node val::Int end\n    struct B1 <: Node val::Int end\n    axiom = A1(2) + (B1(1) + A1(3), B1(4))\n    g = Graph(axiom = axiom)\n    function qfun(n)\n        hasAncestor(n, condition = x -> data(x).val == 1)[1]\n    end\n    Q1 = Query(A1, query = qfun)\n    R1 = apply(g, Q1)\n    Q2 = Query(B1, query = qfun)\n    R2 = apply(g, Q2)\n    (R1,R2)\nend\nsource\n# Base.parent — Method.\nparent(c::Context; nsteps::Int)\nReturns the parent of a node that is nsteps away towards the root of the graph. Intended to be used within a rule or query.\nDetails\nIf hasParent() returns false for the same node or the algorithm has reached the root node but nsteps have not been reached, then parent() will return missing, otherwise it returns the Context associated to the matching node.\nReturn\nReturn a Context object or missing.\nExamples\nlet\n    struct A1 <: Node val::Int end\n    struct B1 <: Node val::Int end\n    axiom = A1(2) + (B1(1) + A1(3), B1(4))\n    g = Graph(axiom = axiom)\n    function qfun(n)\n        np = parent(n, nsteps = 2)\n        !ismissing(np) && data(np).val == 2\n    end\n    Q1 = Query(A1, query = qfun)\n    R1 = apply(g, Q1)\n    Q2 = Query(B1, query = qfun)\n    R2 = apply(g, Q2)\n    (R1,R2)\nend\nsource\n# VPL.Core.ancestor — Method.\nancestor(c::Context; condition = x -> true, maxlevel::Int = typemax(Int))\nReturns the first ancestor of a node that matches the condition. Intended to be used within a rule or query.\nDetails\nIf hasAncestor() returns false for the same node and condition, ancestor() will return missing, otherwise it returns the Context associated to the matching node\nReturn\nReturn a Context object or missing.\nExamples\nlet\n    struct A1 <: Node val::Int end\n    struct B1 <: Node val::Int end\n    axiom = A1(1) + (B1(1) + A1(3), B1(4))\n    g = Graph(axiom = axiom)\n    function qfun(n)\n        na = ancestor(n, condition = x -> (data(x).val == 1))\n        if !ismissing(na)\n            data(na) isa B1\n        else\n            false\n        end\n    end\n    Q1 = Query(A1, query = qfun)\n    R1 = apply(g, Q1)\n    Q2 = Query(B1, query = qfun)\n    R2 = apply(g, Q2)\n    (R1,R2)\nend\nsource\n# VPL.Core.hasChildren — Method.\nhasChildren(c::Context)\nCheck if a node has at least one child and return true or false. Intended to be used within a rule or query.\nsource\n# VPL.Core.isLeaf — Method.\nisLeaf(c::Context)\nCheck if a node is a leaf in the graph (i.e., has no children) and return true or false. Intended to be used within a rule or query.\nsource\n# VPL.Core.hasDescendent — Method.\nhasDescendent(c::Context; condition = x -> true, maxlevel::Int = typemax(Int))\nCheck if a node has a descendent that matches the optional condition. Intended to be used within a rule or query.\nArguments\n\nc::Context: Context associated to a node in a dynamic graph.\ncondition: An user-defined function that takes a Context object as input\n\nand returns true or false. It is assigned by the user by keyword.\n\nmaxlevel::Int: Maximum number of steps that the algorithm may take when\n\ntraversing the graph.\nDetails\nThis function traverses the graph from the node associated to c towards the leaves of the graph until a node is found for which condition returns true. If no node meets the condition, then it will return false. The defaults values for this function are such that the algorithm always returns true after one step (unless it is applied to a leaf node) in which case it is equivalent to calling hasChildren on the node.\nThe number of levels that the algorithm is allowed to traverse is capped by maxlevel (mostly to avoid excessive computation, though the user may want to specify a meaningful limit based on the topology of the graphs being used).\nThe function condition should take an object of type Context as input and return true or false.\nReturn\nReturn a tuple with two values a Bool and an Int, the boolean indicating whether the node has an ancestor meeting the condition, the integer indicating the number of levels in the graph separating the node an its ancestor.\nExamples\nlet\n    struct A1 <: Node val::Int end\n    struct B1 <: Node val::Int end\n    axiom = A1(2) + (B1(1) + A1(3), B1(4))\n    g = Graph(axiom = axiom)\n    function qfun(n)\n        hasDescendent(n, condition = x -> data(x).val == 1)[1]\n    end\n    Q1 = Query(A1, query = qfun)\n    R1 = apply(g, Q1)\n    Q2 = Query(B1, query = qfun)\n    R2 = apply(g, Q2)\n    (R1,R2)\nend\nsource\n# VPL.Core.children — Method.\nchildren(c::Context)\nReturns all the children of a node as Context objects.\nsource\n# VPL.Core.descendent — Method.\ndescendent(c::Context; condition = x -> true, maxlevel::Int = typemax(Int))\nReturns the first descendent of a node that matches the condition. Intended to be used within a rule or query.\nDetails\nIf hasDescendent() returns false for the same node and condition, descendent() will return missing, otherwise it returns the Context associated to the matching node.\nReturn\nReturn a Context object or missing.\nExamples\nlet\n    struct A1 <: Node val::Int end\n    struct B1 <: Node val::Int end\n    axiom = A1(1) + (B1(1) + A1(3), B1(4))\n    g = Graph(axiom = axiom)\n    function qfun(n)\n        na = descendent(n, condition = x -> (data(x).val == 1))\n        if !ismissing(na)\n            data(na) isa B1\n        else\n            false\n        end\n    end\n    Q1 = Query(A1, query = qfun)\n    R1 = apply(g, Q1)\n    Q2 = Query(B1, query = qfun)\n    R2 = apply(g, Q2)\n    (R1,R2)\nend\nsource"
  },
  {
    "objectID": "api/Core.html#graph-visualization",
    "href": "api/Core.html#graph-visualization",
    "title": "Virtual Plant Laboratory",
    "section": "Graph visualization",
    "text": "Graph visualization\n# VPL.Core.draw — Method.\ndraw(g::Graph; force = false, backend = \"native\", inline = false, \n     resolution = (1920, 1080), nlabels_textsize = 15, arrow_size = 15, \n     node_size = 5)\nVisualize a graph as network diagram.\nArguments\nAll arguments are assigned by keywords except the graph g.\n\ng::Graph: The graph to be visualized.\nforce = false: Force the creation of a new window to store the network\n\ndiagram.\n\nbackend = \"native\": The graphics backend to render the network diagram. It\n\ncan have the values \"native\", \"web\" and \"vector\". See VPL documentation for details.\n\ninline = false: Currently this argument does not do anything (will change in\n\nfuture versions of VPL).\n\nresolution = (1920, 1080): The resolution of the image to be rendered, in\n\npixels (online relevant for native and web backends). Default resolution is HD.\n\nnlabels_textsize = 15: Customize the size of the labels in the diagram.\narrow_size = 15: Customize the size of the arrows representing edges in the\n\ndiagram.\n\nnode_size = 5: Customize the size of the nodes in the diagram.\n\nDetails\nBy default, nodes are labelled with the type of data stored and their unique ID. See function node_label() to customize the label for different types of data.\nSee export_graph() to export the network diagram as a raster or vector image (depending on the backend). The function calculate_resolution() can be useful to ensure a particular dpi of the exported image (assuming some physical size).\nThe graphics backend will interact with the environment where the Julia code is being executed (i.e., terminal, IDE such as VS Code, interactive notebook such as Jupyter or Pluto). These interactions are all controlled by the graphics package Makie that VPL relies on. Some details on the expected behavior specific to draw() can be found in the general VPL documentation as www.virtualplantlab.com\nReturn\nThis function returns a Makie Figure object, while producing the visualization as a side effect.\nExamples\nlet\n    struct A1 <: Node val::Int end\n    struct B1 <: Node val::Int end\n    axiom = A1(1) + (B1(1) + A1(3), B1(4))\n    g = Graph(axiom = axiom)\n    draw(g)\nend\nsource\n# VPL.Core.draw — Method.\ndraw(g::StaticGraph; force = false, backend = \"native\", inline = false, \n     resolution = (1920, 1080), nlabels_textsize = 15, arrow_size = 15, \n     node_size = 5)\nEquivalent to the method draw(g::Graph; kwargs...) but to visualize static graphs (e.g., the axiom of a graph).\nsource\n# VPL.Core.node_label — Method.\nnode_label(n::Node, id)\nFunction to construct a label for a node to be used by draw() when visualizing. The user can specialize this method for user-defined data types to customize the labels. By default, the type of data stored in the node and the unique ID of the node are used as labels.\nsource\n# VPL.Core.export_graph — Method.\nexport_graph(f; filename, kwargs...)\nSave a network diagram generated by draw() to an external file.\nArguments\n\nf: Object of type Figure return by draw().\nfilename: Name of the file where the diagram will be stored. The extension\n\nwill be used to determined the format of the image (see example below).\nDetails\nInternally, export_graph() calls the save() method from the ImageIO package and its dependencies. Any keyword argument supported by the relevant save method will be passed along by export_graph(). For example, exporting diagrams as PNG allows defining the compression level as compression_level (see PNGFiles package for details).\nReturn\nThe function returns nothing but, if successful, it will generate a new file containing the network diagram in the appropiate format.\nExamples\nExamples\nlet\n    struct A1 <: Node val::Int end\n    struct B1 <: Node val::Int end\n    axiom = A1(1) + (B1(1) + A1(3), B1(4))\n    g = Graph(axiom = axiom)\n    f = draw(g);\n    export_graph(f, filename = \"test.png\")\nend\nsource\n# VPL.Core.calculate_resolution — Method.\ncalculate_resolution(;width = 1024/300*2.54, height = 768/300*2.54, \n                      format = \"raster\", dpi = 300)\nCalculate the resolution required to achieve a specific width and height (in cm) of the exported image, with a particular dpi (for raster formats).\nsource"
  },
  {
    "objectID": "api/Geometry.html#turtle-geometry",
    "href": "api/Geometry.html#turtle-geometry",
    "title": "Virtual Plant Laboratory",
    "section": "Turtle geometry",
    "text": "Turtle geometry\n# VPL.Geom.MTurtle — Method.\nMTurtle(Float64, message)\nCreate a meshing turtle that can convert a Graph into a 3D mesh using turtle operators, geometry primitives and methods of feedgeom!(). By default, the meshing turtle will generate geometry primitives with double floating precision (Float64) but it is possible to generate a version with lower precision as in MTurtle(Float32). The argument message is any user-defined object.\nsource\n# VPL.Geom.ntriangles — Method.\nntriangles(turtle)\nExtract the number of triangles in the mesh associated to each geometry primitive that were fed to the turtle.\nsource\n# VPL.Geom.head — Method.\nhead(turtle)\nExtract the direction vector (a Vec object) of the head of the turtle.\nsource\n# VPL.Geom.up — Method.\nup(turtle)\nExtract the direction vector (a Vec object) of the back of the turtle.\nsource\n# VPL.Geom.arm — Method.\narm(turtle)\nExtract the direction vector (a Vec object) of the arm of the turtle.\nsource\n# VPL.Geom.pos — Method.\npos(turtle)\nExtract the current position of the turtle (a Vec object).\nsource\n# VPL.Geom.geoms — Method.\ngeoms(turtle)\nExtract the 3D mesh generated by the turtle (a Mesh object).\nsource\n# VPL.Geom.nvertices — Method.\nnvertices(turtle)\nExtract the number of vertices in the mesh associated to each geometry primitive that were fed to the turtle.\nsource\n# VPL.Geom.feedgeom! — Function.\nfeedgeom!(turtle::MTurtle, m::Mesh)\nGeneral purpose method to feed a mesh to a turtle. Note that all primitives provided by VPL are implemented as meshes, but this is a generic method for meshes that are constructed directly by the user or imported from external software.\nsource\nfeedgeom!(turtle::MTurtle, node::Node)\nDefault method for feedgeom!() that does not do anything. This allows the user to include nodes in a graph without an associated geometry.\nsource\nfeedgeom!(turtle::MTurtle, g::Graph)\nProcess a Graph object with a turtle and generate the corresponding 3D mesh from executing the different feedgeom!() methods associated to the nodes in the graph.\nsource\nfeedgeom!(turtle::MTurtle, collection::AbstractArray)\nfeedgeom!(turtle::MTurtle, collection::Tuple)\nFeed a turtle an array or tuple of objects (collection) with existing feedgeom!() methods.\nsource\n# VPL.Geom.T — Type.\nT(to::Vec)\nNode that translates a turtle to the new position to (a Vec object).\nsource\n# VPL.Geom.t! — Method.\nt!(turtle; to = O())\nTranslate a turtle to the new position to (a Vec object).\nsource\n# VPL.Geom.OR — Type.\nOR(head::Vec, up::Vec, arm::Vec)\nNode that orients a turtle to a new direction by re-defining the local reference system.\nsource\n# VPL.Geom.or! — Method.\nor!(turtle; head = Z(), up = X(), arm = Y())\nOrient a turtle to a new direction by re-defining the local reference system. The arguments head, up and arm should be of type Vec.\nsource\n# VPL.Geom.SET — Type.\nSET(to, head, up, arm)\nNode that sets the position and orientation of a turtle.\nsource\n# VPL.Geom.set! — Method.\nset!(turtle; to = O(), head = Z(), up = X(), arm = Y())\nSet position and orientation of a turtle. The arguments to, head, up and arm should be of type Vec and be passed as keyword arguments.\nsource\n# VPL.Geom.RU — Type.\nRU(angle)\nNode that rotates a turtle around up axis. Angle must be in hexadecimal degrees and the rotation is clockwise.\nsource\n# VPL.Geom.ru! — Method.\nru!(turtle, angle)\nRotates a turtle around up axis. Angle must be in hexadecimal degrees and the rotation is clockwise.\nsource\n# VPL.Geom.RA — Type.\nRA(angle)\nNode that rotates a turtle around arm axis. Angle must be in hexadecimal degrees and the rotation is clockwise.\nsource\n# VPL.Geom.ra! — Method.\nra!(turtle, angle)\nRotates a turtle around arm axis. Angle must be in hexadecimal degrees and the rotation is clockwise.\nsource\n# VPL.Geom.RH — Type.\nRH(angle)\nNode that rotates a turtle around head axis. Angle must be in hexadecimal degrees and the rotation is clockwise.\nsource\n# VPL.Geom.rh! — Method.\nrh!(turtle, angle)\nRotate turtle around head axis. Angle must be in hexadecimal degrees and the rotation is clockwise.\nsource\n# VPL.Geom.F — Type.\nF(dist)\nMoves a turtle forward a given distance.\nsource\n# VPL.Geom.f! — Method.\nf!(turtle, dist)\nMove turtle forward a given distance.\nsource\n# VPL.Geom.RV — Type.\nRV(strength)\nRotates the turtle towards the Z axis. See documentation for rv! for details.\nsource\n# VPL.Geom.rv! — Method.\nrv!(turtle, strength)\nRotates the turtle towards the Z axis. The angle of rotation is proportional to the cosine of the zenith angle of the turtle (i.e., angle between its head and the vertical axis) with the absolute value of strength being the proportion between the two. strength should vary between -1 and 1. If strength is negative, the turtle rotates downwards (i.e., towards negative values of Z axis), otherwise upwards.\nsource"
  },
  {
    "objectID": "api/Geometry.html#d-vectors",
    "href": "api/Geometry.html#d-vectors",
    "title": "Virtual Plant Laboratory",
    "section": "3D vectors",
    "text": "3D vectors\n# VPL.Geom.Vec — Type.\nVec(x, y, z)\n3D vector or point with coordinates x, y and z.\nsource\n# VPL.Geom.O — Method.\nO()\nReturns the origin of the 3D coordinate system as a Vec object. By default, the coordinates will be in double floating precision (Float64) but it is possible to generate a version with lower floating precision as in O(Float32).\nsource\n# VPL.Geom.X — Method.\nX()\nReturns an unit vector in the direction of the X axis as a Vec object. By default, the coordinates will be in double floating precision (Float64) but it is possible to generate a version with lower floating precision as in X(Float32).\nsource\n# VPL.Geom.Y — Method.\nY()\nReturns an unit vector in the direction of the Y axis as a Vec object. By default, the coordinates will be in double floating precision (Float64) but it is possible to generate a version with lower floating precision as in Y(Float32).\nsource\n# VPL.Geom.Z — Method.\nZ()\nReturns an unit vector in the direction of the Z axis as a Vec object. By default, the coordinates will be in double floating precision (Float64) but it is possible to generate a version with lower floating precision as in Z(Float32).\nsource\n# VPL.Geom.X — Method.\nX(s)\nReturns scaled vector in the direction of the X axis with length s as a Vec object using the same floating point precision as s.\nsource\n# VPL.Geom.Y — Method.\nY(s)\nReturns scaled vector in the direction of the Y axis with length s as a Vec object using the same floating point precision as s.\nsource\n# VPL.Geom.Z — Method.\nZ(s)\nReturns scaled vector in the direction of the Z axis with length s as a Vec object using the same floating point precision as s.\nsource"
  },
  {
    "objectID": "api/Geometry.html#geometry-primitives",
    "href": "api/Geometry.html#geometry-primitives",
    "title": "Virtual Plant Laboratory",
    "section": "Geometry primitives",
    "text": "Geometry primitives\n\n\n\nTriangle\n# VPL.Geom.Triangle — Method.\nTriangle(;length = 1.0, width = 1.0\nCreate a triangle with dimensions given by length and width, standard location and orientation.\nsource\n# VPL.Geom.Triangle! — Method.\nTriangle!(turtle; length = 1.0, width = 1.0, move = false)\nGenerate a triangle in front of the turtle and feed it to a turtle.\nArguments\n\nturtle: The turtle that we feed the triangle to.\nlength: Length of the triangle.\nwidth: Width of the triangle.\nmove: Whether to move the turtle forward or not (true or false).\n\nDetails\nA triangle mesh will be generated representing the triangle. The triangle will be generated in front of the turtle, on the plane defined by the arm and head axes of the turtle. The argument length refers to the axis of the triangle aligned with the head axis of the turtle, whereas width refers to the orthogonal axis.\nWhen move = true, the turtle will be moved forward by a distance equal to length.\nReturn\nReturns nothing but modifies the turtle as a side effect.\nsource\n\n\n\n\nRectangle\n# VPL.Geom.Rectangle — Method.\nRectangle(;length = 1.0, width = 1.0)\nCreate a rectangle with dimensions given by length and width, standard location and orientation.\nsource\n# VPL.Geom.Rectangle! — Method.\nRectangle!(turtle; length = 1.0, width = 1.0, move = false)\nGenerate a rectangle in front of the turtle and feed it to a turtle.\nArguments\n\nturtle: The turtle that we feed the rectangle to.\nlength: Length of the rectangle.\nwidth: Width of the rectangle.\nmove: Whether to move the turtle forward or not (true or false).\n\nDetails\nA triangle mesh will be generated representing the rectangle. The rectangle will be generated in front of the turtle, on the plane defined by the arm and head axes of the turtle. The argument length refers to the axis of the rectangle aligned with the head axis of the turtle, whereas width refers to the orthogonal axis.\nWhen move = true, the turtle will be moved forward by a distance equal to length.\nReturn\nReturns nothing but modifies the turtle as a side effect.\nsource\n\n\n\n\nTrapezoid\n# VPL.Geom.Trapezoid — Method.\nTrapezoid(;length = 1.0, width = 1.0, ratio = 1.0)\nCreate a trapezoid with dimensions given by length and the larger width and the ratio between the smaller and larger widths. The trapezoid is generted at the standard location and orientation.\nsource\n# VPL.Geom.Trapezoid! — Method.\nTrapezoid!(turtle; length = 1.0, width = 1.0, ratio = 1.0, move = false)\nGenerate a trapezoid in front of the turtle and feed it to a turtle.\nArguments\n\nturtle: The turtle that we feed the trapezoid to.\nlength: Length of the trapezoid.\nwidth: Width of the base of the trapezoid.\nratio: Ratio between the width of the top and base of the trapezoid.\nmove: Whether to move the turtle forward or not (true or false).\n\nDetails\nA triangle mesh will be generated representing the trapezoid. The trapezoid will be generated in front of the turtle, on the plane defined by the arm and head axes of the turtle. The argument length refers to the axis of the trapezoid aligned with the head axis of the turtle, whereas width refers to the orthogonal axis.\nWhen move = true, the turtle will be moved forward by a distance equal to length.\nReturn\nReturns nothing but modifies the turtle as a side effect.\nsource\n\n\n\n\nEllipse\n# VPL.Geom.Ellipse — Method.\nEllipse(;length = 1.0, width = 1.0, n = 20)\nCreate an ellipse with dimensions given by length and width, discretized into n triangles (must be even) and standard location and orientation.\nsource\n# VPL.Geom.Ellipse! — Method.\nEllipse!(turtle; length = 1.0, width = 1.0, n = 20, move = false)\nGenerate an ellipse in front of a turtle and feed it to a turtle.\nArguments\n\nturtle: The turtle that we feed the ellipse to.\nlength: Length of the ellipse.\nwidth: Width of the ellipse.\nn: Number of triangles of the mesh approximating the ellipse (an integer).\nmove: Whether to move the turtle forward or not (true or false).\n\nDetails\nA triangle mesh will be generated with n triangles that approximates an ellipse. The ellipse will be generated in front of the turtle, on the plane defined by the arm and head axes of the turtle. The argument length refers to the axis of the ellipse aligned with the head axis of the turtle, whereas width refers to the orthogonal axis.\nWhen move = true, the turtle will be moved forward by a distance equal to length.\nReturn\nReturns nothing but modifies the turtle as a side effect.\nsource\n\n\n\n\nHollow cylinder\n# VPL.Geom.HollowCylinder — Method.\nHollowCylinder(;length = 1.0, width = 1.0, height = 1.0, n = 40)\nCreate a hollow cylinder with dimensions given by length, width and height, discretized into n triangles (must be even) and standard location and orientation.\nsource\n# VPL.Geom.HollowCylinder! — Method.\nHollowCylinder!(turtle; length = 1.0, width = 1.0, height = 1.0, n = 40, move = false)\nGenerate a hollow cylinder in front of the turtle and feed it to a turtle.\nArguments\n\nturtle: The turtle that we feed the hollow cylinder to.\nlength: Length of the ellipse at the base of the hollow cylinder.\nwidth: Width of the ellipse at the base of the hollow cylinder.\nheight: Height of the hollow cylinder.\nn: Number of triangles in the mesh (must be even).\nmove: Whether to move the turtle forward or not (true or false).\n\nDetails\nA mesh will be generated with n triangles that approximate the hollow cylinder. The cylinder will be generated in front of the turtle, with the base on the plane defined by the arm and up axes of the turtle, centered at the head axis. The length argument refers to the up axis, whereas width refers to the arm axis and height is associated to the head axis.\nWhen move = true, the turtle will be moved forward by a distance equal to height.\nReturn\nReturns nothing but modifies the turtle as a side effect.\nsource\n# VPL.Geom.SolidCylinder — Method.\nSolidCylinder(;length = 1.0, width = 1.0, height = 1.0, n = 80)\nCreate a solid cylinder with dimensions given by length, width and height, discretized into n triangles (must be even) and standard location and orientation.\nsource\n# VPL.Geom.SolidCylinder! — Method.\nSolidCylinder!(turtle; length = 1.0, width = 1.0, height = 1.0, n = 80, move = false)\nGenerate a solid cylinder in front of the turtle and feed it to a turtle.\nArguments\n\nturtle: The turtle that we feed the solid cylinder to.\nlength: Length of the ellipse at the base of the solid cylinder.\nwidth: Width of the ellipse at the base of the solid cylinder.\nheight: Height of the solid cylinder.\nn: Number of triangles in the mesh (must be even).\nmove: Whether to move the turtle forward or not (true or false).\n\nDetails\nA mesh will be generated with n triangles that approximate the solid cylinder. The cylinder will be generated in front of the turtle, with the base on the plane defined by the arm and up axes of the turtle, centered at the head axis. The length argument refers to the up axis, whereas width refers to the arm axis and height is associated to the head axis.\nWhen move = true, the turtle will be moved forward by a distance equal to height.\nReturn\nReturns nothing but modifies the turtle as a side effect.\nsource\n\n\n\n\nHollow cone\n# VPL.Geom.HollowCone — Method.\nHollowCone(;length = 1.0, width = 1.0, height = 1.0, n = 20)\nCreate a hollow cone with dimensions given by length, width and height, discretized into n triangles (must be even) and standard location and orientation.\nsource\n# VPL.Geom.HollowCone! — Method.\nHollowCone!(turtle; length = 1.0, width = 1.0, height = 1.0, n = 20, move = false)\nGenerate a hollow cone in front of the turtle and feed it to a turtle.\nArguments\n\nturtle: The turtle that we feed the hollow cone to.\nlength: Length of the ellipse at the base of the hollow cone.\nwidth: Width of the ellipse at the base of the hollow cone.\nheight: Height of the hollow cone.\nn: Number of triangles in the mesh.\nmove: Whether to move the turtle forward or not (true or false).\n\nDetails\nA mesh will be generated with n triangles that approximate the hollow cone. The cone will be generated in front of the turtle, with the base on the plane defined by the arm and up axes of the turtle, centered at the head axis. The length argument refers to the up axis, whereas width refers to the arm axis and height is associated to the head axis.\nWhen move = true, the turtle will be moved forward by a distance equal to height.\nReturn\nReturns nothing but modifies the turtle as a side effect.\nsource\n# VPL.Geom.SolidCone — Method.\nSolidCone(;length = 1.0, width = 1.0, height = 1.0, n = 40)\nCreate a solid cone with dimensions given by length, width and height, discretized into n triangles (must be even) and standard location and orientation.\nsource\n# VPL.Geom.SolidCone! — Method.\nSolidCone!(turtle; length = 1.0, width = 1.0, height = 1.0, n = 40, move = false)\nGenerate a solid frustum in front of the turtle and feed it to a turtle.\nArguments\n\nturtle: The turtle that we feed the solid cone to.\nlength: Length of the ellipse at the base of the solid cone.\nwidth: Width of the ellipse at the base of the solid cone.\nheight: Height of the solid cone.\nn: Number of triangles in the mesh (must be even).\nmove: Whether to move the turtle forward or not (true or false).\n\nDetails\nA mesh will be generated with n triangles that approximate the solid cone. The cone will be generated in front of the turtle, with the base on the plane defined by the arm and up axes of the turtle, centered at the head axis. The length argument refers to the up axis, whereas width refers to the arm axis and height is associated to the head axis.\nWhen move = true, the turtle will be moved forward by a distance equal to height.\nReturn\nReturns nothing but modifies the turtle as a side effect.\nsource\n\n\n\n\nCube\n# VPL.Geom.SolidCube — Method.\nSolidCube(;length = 1.0, width = 1.0, height = 1.0)\nCreate a solid cube with dimensions given by length, width and height, standard location and orientation.\nsource\n# VPL.Geom.SolidCube! — Method.\nSolidCube!(turtle; length = 1.0, width = 1.0, height = 1.0, move = false)\nGenerate a solid cube in front of the turtle and feed it to a turtle.\nArguments\n\nturtle: The turtle that we feed the solid cube to.\nlength: Length of the rectangle at the base of the solid cube.\nwidth: Width of the rectangle at the base of the solid cube.\nheight: Height of the solid cube.\nmove: Whether to move the turtle forward or not (true or false).\n\nDetails\nA mesh will be generated of a solid cube. The cube will be generated in front of the turtle, with the base on the plane defined by the arm and up axes of the turtle, centered at the head axis. The length argument refers to the up axis, whereas width refers to the arm axis and height is associated to the head axis.\nWhen move = true, the turtle will be moved forward by a distance equal to height.\nReturn\nReturns nothing but modifies the turtle as a side effect.\nsource\n# VPL.Geom.HollowCube — Method.\nHollowCube(;length = 1.0, width = 1.0, height = 1.0)\nCreate a hollow cube with dimensions given by length, width and `height, standard location and orientation.\nsource\n# VPL.Geom.HollowCube! — Method.\nHollowCube!(turtle; length = 1.0, width = 1.0, height = 1.0, move = false)\nGenerate a hollow cube in front of the turtle and feed it to a turtle.\nArguments\n\nturtle: The turtle that we feed the hollow cube to.\nlength: Length of the rectangle at the base of the hollow cube.\nwidth: Width of the rectangle at the base of the hollow cube.\nheight: Height of the hollow cube.\nmove: Whether to move the turtle forward or not (true or false).\n\nDetails\nA mesh will be generated of a hollow cube. The cube will be generated in front of the turtle, with the base on the plane defined by the arm and up axes of the turtle, centered at the head axis. The length argument refers to the up axis, whereas width refers to the arm axis and height is associated to the head axis.\nWhen move = true, the turtle will be moved forward by a distance equal to height.\nReturn\nReturns nothing but modifies the turtle as a side effect.\nsource\n\n\n\n\nSolid frustum\n# VPL.Geom.SolidFrustum — Method.\nSolidFrustum(;length = 1.0, width = 1.0, height = 1.0, n = 40)\nCreate a solid frustum with dimensions given by length, width and height, discretized into n triangles and standard location and orientation.\nsource\n# VPL.Geom.SolidFrustum! — Method.\nSolidFrustum!(turtle; length = 1.0, width = 1.0, height = 1.0, n = 80, move = false)\nGenerate a solid frustum in front of the turtle and feed it to a turtle.\nArguments\n\nturtle: The turtle that we feed the solid frustum to.\nlength: Length of the ellipse at the base of the solid frustum.\nwidth: Width of the ellipse at the base of the solid frustum.\nheight: Height of the solid frustum.\nn: Number of triangles in the mesh (must be even).\nmove: Whether to move the turtle forward or not (true or false).\n\nDetails\nA mesh will be generated with n triangles that approximate the solid frustum. The frustum will be generated in front of the turtle, with the base on the plane defined by the arm and up axes of the turtle, centered at the head axis. The length argument refers to the up axis, whereas width refers to the arm axis and height is associated to the head axis.\nWhen move = true, the turtle will be moved forward by a distance equal to height.\nReturn\nReturns nothing but modifies the turtle as a side effect.\nsource\n# VPL.Geom.HollowFrustum — Method.\nHollowFrustum(;length = 1.0, width = 1.0, height = 1.0, n = 40)\nCreate a hollow frustum with dimensions given by length, width and height, discretized into n triangles (must be even) and standard location and orientation.\nsource\n# VPL.Geom.HollowFrustum! — Method.\nHollowFrustum!(turtle; length = 1.0, width = 1.0, height = 1.0, n = 40, move = false)\nGenerate a hollow frustum in front of the turtle and feed it to a turtle.\nArguments\n\nturtle: The turtle that we feed the hollow frustum to.\nlength: Length of the ellipse at the base of the hollow frustum.\nwidth: Width of the ellipse at the base of the hollow frustum.\nheight: Height of the hollow frustum.\nn: Number of triangles in the mesh (must be even).\nmove: Whether to move the turtle forward or not (true or false).\n\nDetails\nA mesh will be generated with n triangles that approximate the hollow frustum. The frustum will be generated in front of the turtle, with the base on the plane defined by the arm and up axes of the turtle, centered at the head axis. The length argument refers to the up axis, whereas width refers to the arm axis and height is associated to the head axis.\nWhen move = true, the turtle will be moved forward by a distance equal to height.\nReturn\nReturns nothing but modifies the turtle as a side effect.\nsource\n\n\n\n\nBounding box\n# VPL.Geom.BBox — Method.\nBBox(m::Mesh)\nBuild a tight axis-aligned bounding box around a Mesh object.\nsource\n# VPL.Geom.BBox — Method.\nBBox(pmin::Vec, pmax::Vec)\nBuild an axis-aligned bounding box given the vector of minimum (pmin) and maximum (pmax) coordinates.\nsource\n\n\n\n\nGeneric mesh\n# VPL.Geom.Mesh! — Method.\nMesh!(turtle, m::Mesh; scale = Vec(1.0, 1.0, 1.0), move = false)\nFeed a pre-existing mesh to a turtle after scaling.\nArguments\n\nturtle: The turtle that we feed the mesh to.\nm: The pre-existing unscaled mesh in standard position and orientation.\nscale: Vector with scaling factors for the x, y and z axes.\nmove: Whether to move the turtle forward or not (true or false).\n\nDetails\nA pre-existing mesh will be scaled (acccording to scale), rotate so that it is oriented in the same direction as the turtle and translated so that the mesh is generated in front of the turtle. A deep copy of the original mesh is made prior to any transformation.\nWhen move = true, the turtle will be moved forward by a distance equal to height.\nReturn\nReturns nothing but modifies the turtle as a side effect.\nsource"
  },
  {
    "objectID": "api/Geometry.html#rotations-scaling-and-translations",
    "href": "api/Geometry.html#rotations-scaling-and-translations",
    "title": "Virtual Plant Laboratory",
    "section": "Rotations, scaling and translations",
    "text": "Rotations, scaling and translations\n# VPL.Geom.scale! — Method.\nscale!(m::Mesh, Vec)\nScale a mesh m along the three axes provided by vec\nsource\n# VPL.Geom.rotatex! — Method.\nrotatex!(m::Mesh, θ)\nRotate a mesh m around the x axis by θ rad.\nsource\n# VPL.Geom.rotatey! — Method.\nrotatey!(m::Mesh, θ)\nRotate a mesh m around the y axis by θ rad.\nsource\n# VPL.Geom.rotatez! — Method.\nrotatez!(m::Mesh, θ)\nRotate a mesh m around the z axis by θ rad.\nsource\n# VPL.Geom.rotate! — Method.\nrotate!(m::Mesh; x::Vec, y::Vec, z::Vec)\nRotate a mesh m to a new coordinate system given by x, y and z\nsource\n# VPL.Geom.translate! — Method.\ntranslate!(m::Mesh, v::Vec)\nTranslate the mesh m by vector v\nsource"
  },
  {
    "objectID": "api/Geometry.html#other-mesh-related-methods",
    "href": "api/Geometry.html#other-mesh-related-methods",
    "title": "Virtual Plant Laboratory",
    "section": "Other mesh-related methods",
    "text": "Other mesh-related methods\n# VPL.Geom.Mesh — Method.\nMesh()\nGenerate an empty triangular dense mesh that represents a primitive or 3D scene. By default a Mesh object will only accept coordinates in double floating precision (Float64) but a lower precision can be generated by specifying the corresponding data type as in Mesh(Float32).\nsource\n# VPL.Geom.Mesh — Method.\nMesh(nt, nv = nt*3)\nGenerate a triangular dense mesh with enough memory allocated to store nt triangles and nv vertices. The behaviour is equivalent to generating an empty mesh but may be computationally more efficient when appending a large number of primitives. If a lower floating precision is required, this may be specified as an optional third argument as in Mesh(10, 30, Float32).\nsource\n# VPL.Geom.ntriangles — Method.\nntriangles(mesh)\nExtract the number of triangles in a mesh.\nsource\n# VPL.Geom.nvertices — Method.\nnvertices(mesh)\nThe number of vertices in a mesh.\nsource\n# VPL.Geom.area — Method.\narea(m::Mesh)\nTotal surface area of a mesh (as the sum of areas of individual triangles).\nsource\n# VPL.Geom.areas — Method.\nareas(m::Mesh)\nA vector with the areas of the different triangles that form a mesh.\nsource\n# VPL.Geom.loadmesh — Method.\nloadmesh(filename)\nImport a mesh from a file given by filename. Supported formats include stl, ply, obj and msh. By default, this will generate a Mesh object that uses double floating-point precision. However, a lower precision can be specified by passing the relevant data type as in loadmesh(filename, Float32).\nsource\n# VPL.Geom.savemesh — Method.\nsavemesh(mesh; fileformat = STL_BINARY, filename)\nSave a mesh into an external file using a variety of formats.\nArguments\n\nmesh: Object of type Mesh.\nfileformat: Format to store the mesh. This is a keyword argument.\nfilename: Name of the file in which to store the mesh.\n\nDetails\nThe fileformat should take one of the following arguments: STL_BINARY, STL_ASCII, PLY_BINARY, PLY_ASCII or OBJ. Note that these names should not be quoted as strings.\nReturn\nThis function does not return anything, it is executed for its side effect.\nsource"
  },
  {
    "objectID": "api/RayTracer.html",
    "href": "api/RayTracer.html",
    "title": "Virtual Plant Laboratory",
    "section": "",
    "text": "Module RayTracing\n\n\n\n\nTurtle\n# VPL.RayTracing.RTTurtle — Type.\nRTTurtle()\nCreate a RTTurtle() object that will parse a Graph object and store the materials associated to the different primitives. This type of turtle is automatically created by calls to RTScene() but the user may want to separately construct the geometry and materials and manually combine them into a RTScene object for performance reasons.\nsource\n# VPL.RayTracing.materials — Function.\nmaterials(turtle)\nExtract the array of materials stored inside a RTTurtle object.\nsource\n# VPL.RayTracing.feedmaterial! — Function.\nfeedmaterial!(turtle::RTTurtle, material::Material)\nGeneral purpose method to feed a material to a RT turtle. This should be used inside user’s defined methods to add the material object with optical properties associated to the primitive.\nsource\nfeedmaterial!(turtle::RTTurtle, node::Node)\nDefault method for feedmaterial!() that does not do anything. Hence, the user can include nodes in a graph withour associated colors (the nodes should not generate geometry either).\nsource\nfeedmaterial!(turtle::RTTurtle, g::Graph)\nProcess a Graph object with a RT turtle and collect the materials defined in the graph, in the same order in which the 3D mesh is created by the corresponding feedgeom!() method.\nsource\nfeedmaterial!(turtle::RTTurtle, collection::AbstractArray)\nfeedmaterial!(turtle::RTTurtle, collection::Tuple)\nFeed a RT turtle an array or tuple of objects (collection) with existing feedmaterial!() methods.\nsource\n\n\n\n\nRTScene\n# VPL.RayTracing.Triangle — Method.\nTriangle(p1, p2, p3)\nCreate a ray tracing Triangle object given the three vertices p1, p2 and p3.\nsource\n# VPL.RayTracing.Triangle — Method.\nTriangle(mesh)\nCreate a vector of ray tracing Triangle objects from a Mesh object.\nsource\n# VPL.RayTracing.RTScene — Type.\nRTScene(triangles, material_ids, materials)\nCreate a ray tracing scene for rendering from a vector of triangles (triangles), a vector of ids that match each triangle to a material (ids) and the vector of material objects (materials). This method will generally not be used by the author unless the components of an RTScene were generated manually.\nsource\n# VPL.add! — Function.\nadd!(scene; mesh, material)\nAdd a 3D mesh with a corresponding material (mesh and material) to an existing RTScene object (scene).\nsource\nadd!(scene; mesh, color)\nManually add a 3D mesh with corresponding colors (mesh and color) to an existing GLScene object (scene).\nsource\n\n\n\n\nRayTracer\n# VPL.RayTracing.get_nw — Function.\nget_nw(s::Source)\nRetrieve the number of wavelengths that rays from a source will contain.\nsource\nget_nw(rt::RayTracer)\nRetrieve the number of wavelengths being simulated by the ray tracer. See VPL documentation for more details on the ray tracer.\nsource\n# VPL.RayTracing.RTSettings — Type.\nRTSettings(;parallel = false, pkill = 0.2, maxiter = 2, sampler = Random.Xoshiro(123456789),\n            nx = 0, ny = 0, nz = 0, dx = 0.0, dy = 0.0, dz = 0.0)\nSettings for the ray tracer: parallel indicates if the raytracer will run on a single core or make use of multiple cores in the machine based on Julia’s multithreading support. pkill is the probably that a ray is terminated by the Russian roulette after it has been scattered a maxiter number of times. sampler is the pseudo-random number generator to be used by the ray tracer. nx and ny are the number of times the scene will be clone by the grid cloner in each direction along the x and y axis (e.g., setting nx = 1 and ny = 1 will generate a grid of 3 x 3 clones of the original scene), whereas dx and dy will be distance at which each new clone will be generated (along the axis). nz is the number of times the scene will be cloned in the vertical direction. Unlike horizontal cloning, the vertical cloning is always done in the positive direction of z axis and the number of clones will be exactly nz. See VPL documentation for more details on the ray tracer.\nsource\n# VPL.RayTracing.RayTracer — Type.\nRayTracer(acceleration, grid, materials, sources, settings)\nCreate a ray tracer object from an acceleration structure built around a 3D mesh (acceleration), a grid cloner structure around the acceleration structure (grid), a vector of materials associated to the mesh (materials), a vector of sources of irradiance (sources) and settings. (as generated by RTSettings()). See VPL documentation for more details on the ray tracer.\nsource\n# VPL.RayTracing.trace! — Function.\ntrace!(rt)\nRun the ray tracing simulations. This function will overwrite the power component of any material object that is included in the scene. It returns the total number of rays being traced (primary and secondary). See VPL documentation for more details on the ray tracer.\nsource\n\n\n\n\nAcceleration structures\n# VPL.RayTracing.Naive — Type.\nNaive\nAllow to run the ray tracer without an acceleration structure. This should be assigned to the argument acceleration in the RayTracer function.\nsource\n# VPL.RayTracing.BVH — Type.\nBVH\nConstruct a Bounding Volume Hierarchy around the triangular meshes to accelerate the ray tracer. This should be assigned to the argument acceleration in the RayTracer function, in combination with a corresponding rule.\nsource\n# VPL.RayTracing.SAH — Type.\nSAH{K}(minN, maxL)\nRule to be used in RayTracer when acceleration = BVH. It will divide each node at the axis and location using the Surface Area Heuristics. To speed up the construction, only K cuts will be tested per axis. These cuts will correspond to the quantiles along each axis. The rule is parameterized by the minimum number of triangles in a leaf node (minN) and the maximum depth of the tree (maxL).\nsource\n# VPL.RayTracing.AvgSplit — Type.\nAvgSplit(minN, maxL)\nRule to be used in RayTracer when acceleration = BVH. It will divide each node along the longest axis through the mean coordinate value. The rule is parameterized by the minimum number of triangles in a leaf node (minN) and the maximum depth of the tree (maxL).\nsource\n\n\n\n\nSources\n# VPL.RayTracing.Source — Type.\nSource(geom, angle, power::Number, nrays)\nSource(geom, angle, power::Tuple, nrays)\nCreaten irradiance source given a source geometry, a source angle, the power per ray and the total number of rays to be generated from this source. When simulating more than one wavelength simultaneously, a tuple of power values should be given, of the same length as in the materials used in the scene. See VPL documentation for details on source geometries and source angles.\nsource\n# VPL.RayTracing.DirectionalSource — Function.\nDirectionalSource(box::AABB, θ, Φ, power, nrays)\nDirectionalSource(scene::RTScene, θ, Φ, power, nrays)\nCreate a Directional source (including geometry and angle components) by providing an axis-aligned bounding box (box) or an RTScene object (scene) as well as the zenith (θ) and azimuth (Φ) angles, the power per ray (as in Source) and the number of rays to be generated. See VPL documentation for details on irradiance sources.\nsource\n# VPL.RayTracing.PointSource — Type.\nPointSource(vec)\nCreate a point irradiance source geometry at given 3D location vec, defined as vector of Cartesian coordinates (Vec(x, y, z)).\nsource\n# VPL.RayTracing.LineSource — Type.\nLineSource(p, line)\nCreate a line irradiance source geometry given an origin (p) and a segment (line) both specified as vector of Cartesian coordinates (Vec(x, y, z)). This will create a line source between the points p and p .+ line.\nsource\n# VPL.RayTracing.AreaSource — Type.\nAreaSource(mesh)\nCreate an area irradiance source geometry given a triangular mesh.\nsource\n# VPL.RayTracing.LambertianSource — Type.\nLambertianSource(x, y, z)\nLambertianSource(axes)\nCreate a Lambertian irradiance source angle by given a local coordinate system as three separate Vec objects representing the axes (x, y, z) or as tuple containing the three axes. Rays will be generated towards the hemisphere defined by the z direction. See VPL documentation for details on irradiance sources.\nsource\n# VPL.RayTracing.FixedSource — Type.\nFixedSource(dir)\nFixedSource(θ, Φ)\nCreate a fixed irradiance source by given a vector with the direction of the rays (dir) or zenith (θ) and azimuth (Φ) angles.\nsource\n\n\n\n\nMaterials\n# VPL.RayTracing.Sensor — Type.\nSensor(nw::Int)\nCreate a sensor material object to store power for nw wavelengths. A sensor material will let rays pass through without altering the direction or irradiance. They will also not count for the total number of ray iterations.\nsource\n# VPL.RayTracing.Black — Type.\nBlack(nw::Int)\nCreate a black material object to store power for nw wavelengths. See VPL documentation for details.\nsource\n# VPL.RayTracing.Lambertian — Type.\nLambertian(;τ = 0.0, ρ = 0.0)\nCreate a Lambertian material object from the values of transmittance (τ) and reflectance (ρ). When more than one wavelength is being simulated, a tuple of values should be passed for each optical property (as in τ = (0.1,0.2)).\nsource\n# VPL.RayTracing.Phong — Type.\nPhong(;τ = 0.0, ρd = 0.0, ρsmax = 0.0, n = 2)\nCreate a Phong material object from the values of transmittance (τ) diffuse reflectance (ρd), maximum Phong specular reflectance (ρsmax) and n is the specular exponent that controls the “Phong reflectance lobe”. When more than one wavelength is being simulated, a tuple of values should be passed for each optical property (as in τ = (0.1, 0.3)).\nsource\n# VPL.RayTracing.power — Function.\npower(material::Material)\nExtract the power stored inside a material.\nsource\n# VPL.RayTracing.reset! — Method.\nreset!(material::Material)\nReset the power stored inside a material back to zero\nsource\n# VPL.RayTracing.tau — Function.\ntau(vals...)\nGenerate values of transmisivity to be used in material object. vals... is a list of one or more comma separted values, corresponding to the different wavelengths/wavebands to be simulated in a ray tracer.\nsource\n# VPL.RayTracing.rho — Function.\nrho(vals...)\nGenerate values of reflectivity to be used in material object. vals... is a list of one or more comma separted values, corresponding to the different wavelengths/wavebands to be simulated in a ray tracer.\nsource"
  },
  {
    "objectID": "api/Render.html#scenes-for-rendering",
    "href": "api/Render.html#scenes-for-rendering",
    "title": "Virtual Plant Laboratory",
    "section": "Scenes for rendering",
    "text": "Scenes for rendering\n# VPL.Render.GLScene — Type.\nGLScene(mesh, colors)\nCreate a 3D scene for rendering from a Mesh object (m) and colors associated to the different primitives (colors). This method is useful when the user has generated separately the 3D mesh and array with colors, as otherwise other methods of GLScene() will be more useful.\nsource\n# VPL.add! — Method.\nadd!(scene; mesh, color)\nManually add a 3D mesh with corresponding colors (mesh and color) to an existing GLScene object (scene).\nsource"
  },
  {
    "objectID": "api/Render.html#rendering-methods",
    "href": "api/Render.html#rendering-methods",
    "title": "Virtual Plant Laboratory",
    "section": "Rendering methods",
    "text": "Rendering methods\n# VPL.Render.GLTurtle — Type.\nGLTurtle(colors, message)\nCreate a GLTurtle() object that will parse a Graph object and store the colors associated to the different primitives. This type of turtle is automatically created by calls to GLScene() and render() but the user may want to separately construct the geometry and colors and manually combine them into a GLScene object for performance reasons. The argument message is any user-defined object.\nsource\n# VPL.Render.colors — Method.\ncolors(turtle)\nExtract the array of colors stored inside an GLTurtle object\nsource\n# VPL.Render.feedcolor! — Function.\nfeedcolor!(turtle::GLTurtle, color::Colorant)\nGeneral purpose method to feed a color to a GL turtle. This should be used inside user’s defined methods to add any color object that inherits from Colorant from the package Color, for example, by using RGB().\nsource\nfeedcolor!(turtle::GLTurtle, node::Node)\nDefault method for feedcolor!() that does not do anything. Hence, the user can include nodes in a graph withour associated colors (the nodes should not generate geometry either).\nsource\nfeedcolor!(turtle::GLTurtle, g::Graph)\nProcess a Graph object with a GL turtle and collect the colors defined in the graph, in the same order in which the 3D mesh is created by the corresponding feedgeom!() method.\nsource\nfeedcolor!(turtle::GLTurtle, collection::AbstractArray)\nfeedcolor!(turtle::GLTurtle, collection::Tuple)\nFeed a GL turtle an array or tuple of objects (collection) with existing feedcolor!() methods.\nsource\n# VPL.Render.render — Function.\nrender(m::Mesh; kwargs...)\nRender a mesh. This will create a new visualization (see Documentation for details). Keyword arguments are passed to the render(scene::GLScene) method and any unmatched keywords will be passed along to Makie.mesh().\nsource\nrender(scene::GLScene; normals::Bool = false, wireframe::Bool = false, kwargs...)\nRender a GLScene object. This will create a new visualization (see Documentation for details). normals = true will draw arrows in the direction of the normal vector for each triangle in the mesh, wireframe = true will draw the edges of each triangle with black lines. Keyword arguments are passed to Makie.mesh().\nsource\nrender(graph::Graph, Float64; normals::Bool = false, message = nothing,\n       wireframe::Bool = false, kwargs...)\nRender the 3D mesh associated to a Graph object. This will create a new visualization (see Documentation for details). normals = true will draw arrows in the direction of the normal vector for each triangle in the mesh, wireframe = true will draw the edges of each triangle with black lines. Keyword arguments are passed to Makie.mesh(). The argument message is any user-defined object that will be stored in the turtles and hence available within the feedgeom! and feedcolor! methods. By default, double floating precision will be used (Float64) but it is possible to generate a version with a different precision by specifying the corresponding type as in render(graph, Float32).\nsource\nrender(graphs::Vector{<:Graph}, Float64; normals::Bool = false, \n       wireframe::Bool = false, messsage = nothing, kwargs...)\nRender the 3D mesh associated to an array of Graph objects. This will create a new visualization (see Documentation for details). normals = true will draw arrows in the direction of the normal vector for each triangle in the mesh, wireframe = true will draw the edges of each triangle with black lines. Keyword arguments are passed to Makie.mesh(). The argument message is any user-defined object that will be stored in the turtles and hence available within the feedgeom! and feedcolor! methods. By default, double floating precision will be used (Float64) but it is possible to generate a version with a different precision by specifying the corresponding type as in render(graphs, Float32).\nsource\n# VPL.Render.render! — Function.\nrender!(source::Source{G, A, nw}; n = 20, alpha = 0.2)\nAdd a mesh representing the light source to a 3D scene. For each type of light source a triangular mesh will be created, where n is the number of triangles (see documentation of geometric primitives for details) and alpha is the transparency to be used for each triangle.\nsource\nrender!(grid::GridCloner; alpha = 0.2)\nAdd a mesh representing the bounding boxes of the grid cloner to a 3D scene, where alpha represents the transparency of each box.\nsource\nrender!(m::Mesh; kwargs...)\nAdd a mesh to the visualization currently active. This will create a new visualization (see Documentation for details). Keyword arguments are passed to the render!(scene::GLScene) method and any unmatched keywords will be passed along to Makie.mesh!().\nsource\n# VPL.Render.export_scene — Method.\nexport_scene(;scene, filename, kwargs...)\nExport a screenshot of the current visualization (stored as scene as output of a call to render) as a PNG file store in the path given by filename (including .png extension). Keyword arguments will be passed along to the corresponding save method from Makie (see VPL documentation for details).\nsource"
  },
  {
    "objectID": "Ecophys/index.html",
    "href": "Ecophys/index.html",
    "title": "Ecophysiological modules",
    "section": "",
    "text": "In development"
  },
  {
    "objectID": "GCIM/index.html",
    "href": "GCIM/index.html",
    "title": "Generic crop interactions model",
    "section": "",
    "text": "In development"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "The Virtual Plant Laboratory",
    "section": "",
    "text": "Important\n\n\n\nThe Virtual Plant Laboratory is in an early developmental stage and it is released for the purposes of testing and early feedback. It is not intended for research or commercial use at this stage."
  },
  {
    "objectID": "index.html#introduction",
    "href": "index.html#introduction",
    "title": "The Virtual Plant Laboratory",
    "section": "Introduction",
    "text": "Introduction\nThe Virtual Plant Laboratory (VPL) is a Julia package that aids in the construction, simulation and visualization of functional-structural plant models (FSPM). VPL is not a standalone solution to all the computational problems relevant to FSPM, but rather it focuses on those algorithms that are specific to FSPM and for which there are no good solutions in the Julia package ecosystem. Furthermore, VPL is 100% written in Julia and therefore VPL will work in any platform and with any code editor where Julia works. Finally, VPL does not offer a domain specific language for FSPM but rather it allows building FSP models by creating user-defined data types and methods.\nThere is no standard definition of what an FSPM is (though these models will always involve some combination of plant structure and function) so VPL may not be useful with every possible FSPM. Instead, VPL focuses on models that represent indivudual plants as graphs of elements (usually organs) that interact with each other and with the environment. In a typical VPL model, each plant is represented by its own graph which can change dynamically through the iterative application of graph rewriting rules. Based on this goal, what VPL offers are data structures and algorithms that allow modelling the dynamic evolution of graphs that represent plants as collections of organs or other morphological elements and modelling the the interaction between plants and their environment by generating 3D structures and simulating capture of different resources (e.g. light).\nIn terms of design, VPL gives priority to performance and simple interfaces as opposed to complex layers of abstraction. This implies that models in VPL may be more verbose and procedural (as opposed to descriptive) than in other FSPM software, though may also make them more transparent and easier to follow."
  },
  {
    "objectID": "index.html#installation",
    "href": "index.html#installation",
    "title": "The Virtual Plant Laboratory",
    "section": "Installation",
    "text": "Installation\nVPL requires using Julia version 1.7 or higher. The installation of VPL is as easy as running the following code:\nusing Pkg\nPkg.add(PackageSpec(url = \"https://github.com/AleMorales/VPL.git\", rev  = \"master\"))\nThis requires an Internet connection such that Julia will download the source code of the VPL package and install it in the local machine."
  },
  {
    "objectID": "index.html#the-vplverse",
    "href": "index.html#the-vplverse",
    "title": "The Virtual Plant Laboratory",
    "section": "The VPLverse",
    "text": "The VPLverse\nThe package VPL contains all the basic functionality to build FSP models but, as indicated earlier, the emphasis is on minimal, simple and transparent interfaces. In order to facilitate the construction of non-trivial FSP models, an ecosystem of packages built around VPL provide additional support to the modeller by offering reusable modules that can be reused in new models.\nThe packages currently planned for VPLverse are:\n\nEcophys - Algorithms and data structures to simulate ecophysiological processes including photosynthesis, transpiration, leaf energy balance, phenology or respiration.\nSky - Algorithms to simulate different sky conditions in terms of the intensity of solar radiation and its spatial distribution.\nGCIM - A generic model that allows simulating multiple types of crops with an emphasis on plant-plant interactions as part of mixed cropping systems."
  },
  {
    "objectID": "index.html#documentation",
    "href": "index.html#documentation",
    "title": "The Virtual Plant Laboratory",
    "section": "Documentation",
    "text": "Documentation\nDocumentation for VPL is provided in this website in four formats:\n\nUser manual\nTutorials and examples\nAPI\nTechnical notes\n\nThe documentation for packages from the VPLverse are included in their respective sections.\nNew users are expected to start with the tutorials and consult the user manual to understand better the different concepts used in VPL and get an overview of the different options available. The API documentation describes each individual function and data type, with an emphasis on inputs and outputs and (in addition to this website) it can be accessed from within Julia with ? (see the section Accessing Documentation in the Julia manual). The technical notes are useful for people who want to understand the internal details of VPL and how different algorithms are implemented (i.e. the technical notes should be seen as a supplementary to the source code of VPL)."
  },
  {
    "objectID": "julia_basics/index.html",
    "href": "julia_basics/index.html",
    "title": "Julia basics for VPL",
    "section": "",
    "text": "This section will include an introduction to Julia with special emphasis on what is needed to build models with VPL (i.e., a deeper understand of the language is needed compared to just doing data analysis or simulations).\nKey ideas:\n\nTypes and methods\nMutability vs immutability\nType redefinition and modules"
  },
  {
    "objectID": "manual/Geometry/Primitives/index.html",
    "href": "manual/Geometry/Primitives/index.html",
    "title": "Geometry primitives",
    "section": "",
    "text": "using VPL\nList of primitives with example of code for direct construction. See API for turtle constructors (the keyword arguments remain the same).\nThe 3D visualizations keep the axes to help understand what the standard location and orientation are (use axes = false to turn off). They also set normals = true and wireframe = true to highlight how the mesh is partitioned into triangles and the normal vectors of each triangle (this is important for the ray tracer and when exporting meshes out of VPL). All meshes are rendered in green assuming 50% transparency (color = RGBA(0,1,0,0.5)). Note that one must use transparency = true to ensure that the transparency is enabled when rendering the mesh."
  },
  {
    "objectID": "manual/Geometry/Primitives/index.html#triangle",
    "href": "manual/Geometry/Primitives/index.html#triangle",
    "title": "Geometry primitives",
    "section": "Triangle",
    "text": "Triangle\n\np = Triangle(length = 1.0, width = 1.0)\nrender(p, wireframe = true, normals = true, color = RGBA(0,1,0,0.5), transparency = true)"
  },
  {
    "objectID": "manual/Geometry/Primitives/index.html#rectangle",
    "href": "manual/Geometry/Primitives/index.html#rectangle",
    "title": "Geometry primitives",
    "section": "Rectangle",
    "text": "Rectangle\n\np = Rectangle(length = 1.0, width = 1.0)\nrender(p, wireframe = true, normals = true, color = RGBA(0,1,0,0.5), transparency = true)"
  },
  {
    "objectID": "manual/Geometry/Primitives/index.html#trapezoid",
    "href": "manual/Geometry/Primitives/index.html#trapezoid",
    "title": "Geometry primitives",
    "section": "Trapezoid",
    "text": "Trapezoid\n\np = Trapezoid(length = 1.0, width = 1.0, ratio = 0.5)\nrender(p, wireframe = true, normals = true, color = RGBA(0,1,0,0.5), transparency = true)"
  },
  {
    "objectID": "manual/Geometry/Primitives/index.html#ellipse",
    "href": "manual/Geometry/Primitives/index.html#ellipse",
    "title": "Geometry primitives",
    "section": "Ellipse",
    "text": "Ellipse\n\np = Ellipse(length = 1.0, width = 1.0, n = 30)\nrender(p, wireframe = true, normals = true, color = RGBA(0,1,0,0.5), transparency = true)"
  },
  {
    "objectID": "manual/Geometry/Primitives/index.html#axis-aligned-bounding-box",
    "href": "manual/Geometry/Primitives/index.html#axis-aligned-bounding-box",
    "title": "Geometry primitives",
    "section": "Axis-aligned bounding box",
    "text": "Axis-aligned bounding box\n\np = BBox(Vec(0.0, 0.0, 0.0), Vec(1.0, 1.0, 1.0))\nrender(p, wireframe = true, normals = true, color = RGBA(0,1,0,0.5), transparency = true)"
  },
  {
    "objectID": "manual/Geometry/Primitives/index.html#cube",
    "href": "manual/Geometry/Primitives/index.html#cube",
    "title": "Geometry primitives",
    "section": "Cube",
    "text": "Cube\nSolid version\n\np = SolidCube(length = 1.0, width = 1.0, height = 1.0)\nrender(p, wireframe = true, normals = true, color = RGBA(0,1,0,0.5), transparency = true)\n\n\n\n\nHollow version\n\np = HollowCube(length = 1.0, width = 1.0, height = 1.0)\nrender(p, wireframe = true, normals = true, color = RGBA(0,1,0,0.5), transparency = true)"
  },
  {
    "objectID": "manual/Geometry/Primitives/index.html#cylinder",
    "href": "manual/Geometry/Primitives/index.html#cylinder",
    "title": "Geometry primitives",
    "section": "Cylinder",
    "text": "Cylinder\nSolid version\n\np = SolidCylinder(length = 1.0, width = 1.0, height = 1.0, n = 80)\nrender(p, wireframe = true, normals = true, color = RGBA(0,1,0,0.5), transparency = true)\n\n\n\n\nHollow version\n\np = HollowCylinder(length = 1.0, width = 1.0, height = 1.0, n = 40)\nrender(p, wireframe = true, normals = true, color = RGBA(0,1,0,0.5), transparency = true)"
  },
  {
    "objectID": "manual/Geometry/Primitives/index.html#frustum",
    "href": "manual/Geometry/Primitives/index.html#frustum",
    "title": "Geometry primitives",
    "section": "Frustum",
    "text": "Frustum\nSolid version\n\np = SolidFrustum(length = 1.0, width = 1.0, height = 1.0, ratio = 0.5, n = 80)\nrender(p, wireframe = true, normals = true, color = RGBA(0,1,0,0.5), transparency = true)\n\n\n\n\nHollow version\n\np = HollowFrustum(length = 1.0, width = 1.0, height = 1.0, ratio = 0.5, n = 40)\nrender(p, wireframe = true, normals = true, color = RGBA(0,1,0,0.5), transparency = true)"
  },
  {
    "objectID": "manual/Geometry/Primitives/index.html#cone",
    "href": "manual/Geometry/Primitives/index.html#cone",
    "title": "Geometry primitives",
    "section": "Cone",
    "text": "Cone\nSolid version\n\np = SolidCone(length = 1.0, width = 1.0, height = 1.0, n = 40)\nrender(p, wireframe = true, normals = true, color = RGBA(0,1,0,0.5), transparency = true)\n\n\n\n\nHollow version\n\np = HollowCone(length = 1.0, width = 1.0, height = 1.0, n = 20)\nrender(p, wireframe = true, normals = true, color = RGBA(0,1,0,0.5), transparency = true)"
  },
  {
    "objectID": "manual/Graphs/index.html",
    "href": "manual/Graphs/index.html",
    "title": "Dynamic graph creation and manipulation",
    "section": "",
    "text": "A model in VPL is a (discrete) dynamical model that describes the time evolution of one or more entities (i.e. objects of type graph). Each graph (usually assumed to be an individual plant) is characterized by a series of nodes (usually organs) that are represented by nodes in a graph. Each node is defined by its own state, including (if applicable) a description of its geometry, color, optical propertes, etc. The dynamic simulation of a graph consists of the creation and destruction of nodes via graph rewriting rules, and changes to the internal state of its nodes with the help of queries.\nThe 3D structure of a graph is generated by processing its nodes using a Turtle procedural geometry approach (i.e. inspired on Logo’s turtle graphs as used in L-systems) and following the topology of the graph. This 3D structure may be used for visualization using a 3D renderer or for simulating spatial processes.\nVPL does not provide a domain-specific language to implement rules and queries. Rather, they are defined by functions which are stored in objects of types Rule and Query, respectively. Similarly, the nodes of a graph can be of any user-defined type, as long as the user defines the necessary methods to support specific functionality (e.g. the feedgeom! method to generate geometry).\nVPL is designed around data types and methods. Building a model in VPL typically requires:\n\nDefining types for the different classes of nodes of a graph\nCreating rules and queries based on these types\nCreating graphs by combining rules and the initial states of the graphs\nCreating additional elements in the scene (e.g. soil)\n\nA simulation in VPL consists of executing rules iteratively and, within each iteration:\n\nUse queries to select subset of nodes and modify their states.\nModify graph-level variables directly.\nUse algorithms in VPL to simulate interactions among nodes or between nodes and their environment.\n\nIn addition, VPL allows visualizing the results of a simulation by: * 3D rendering of the generated scenes * Network graph representing the nodes in the graph\nVPL is designed to facilitate modular model development, such as using different types of graphs in the same simulation, alternative visualizations of the same scene by mapping internal states of nodes to colors, or including multiple ray tracers in the same simulation. Users may also create their own data types that include graphs as fields or to nest graphs within other graphs."
  },
  {
    "objectID": "manual/Graphs/index.html#graph-construction-algebra",
    "href": "manual/Graphs/index.html#graph-construction-algebra",
    "title": "Dynamic graph creation and manipulation",
    "section": "Graph-construction algebra",
    "text": "Graph-construction algebra\nWhen initializing a graph and when specifying a graph rewriting rule it is necessary to indicate the topological relationship between the nodes being added to a graph (i.e. effectively we build graphs by appending sub-graphs). In order to facilitate the description of these relationships, a simple algebra is defined for all objects that inherit from Node.\nThe + operator indicates a linear parent-child dependency between the operands. For example, M() + L() indicates that the object generated by L() is a child of M(). A branching point is introduced by enclosing the children of a node within () and separating the different branches with “,”. For example, (M(1) + (L(2), L(3)) + M(4) + L(5)) creates a tree that starts with M(1), has 3 children (L(2), L(3) and M(4)) and M(4) has a child L(5).\nA graph always keep tracks of two special nodes: the root and the insertion point. The root is the node that has no parent. When you use a graph rewriting rule (see below) to replace a node a with a graph that has a root node b, the result is that node a is replaced by node b and will inherit all the children and parent from node a (plus the children that b already had in the replacement graph).\nAn insertion point is the node of a graph where new nodes will be connected to when using the + operator. Branches do not modify the insertion point of an existing graph, but linear addition of nodes will always update the insertion point to the last node. Thus, these two expressions produce the same tree structure but with different insertion points: M(1) + (L(2), L(3)) + M(4) + L(5) and M(1) + (L(2), L(3), M(4) + L(5)). In the first case, the insertion point becomes the node L(5) but in the second case it remains at M(1). Keeping track of the insertion point of a graph is important when building a graph in several steps."
  },
  {
    "objectID": "manual/Graphs/index.html#matching-relationships-among-nodes",
    "href": "manual/Graphs/index.html#matching-relationships-among-nodes",
    "title": "Dynamic graph creation and manipulation",
    "section": "Matching relationships among nodes",
    "text": "Matching relationships among nodes\nSometimes the lhs function needs to check the relationships between nodes inside a graph (e.g. match all leaves that belong to a particular branch of a graph). In order achieve that, one can use the functions hasParent() and hasChildren() to check for inmediate connections (i.e. effectively to check whether the node is a root or a leaf in the graph) whereas hasAncestor() and hasDescendant() allow traversing the graph and finding any connected node that matches a specific query. If we need to extract the contents of the node, we may use the corresponding functions parent(), children(), ancestor() and descendant(). Note that children() will return all the children nodes as a tuple, but the rest of functions only return one node at a time. All these functions take a Context object as input and return either true or false (for the functions that start with has) or a Context or tuple of Context objects for the functions that extract the actual connected node. These methods may also be used inside the rhs function of rules. However, to avoid code repetition (and for performance reasons), it is recommended to capture the Context objects of connected in the lhs function and pass them to the rhs as described below (see below)."
  },
  {
    "objectID": "manual/Graphs/index.html#capturing-the-context-of-a-node",
    "href": "manual/Graphs/index.html#capturing-the-context-of-a-node",
    "title": "Dynamic graph creation and manipulation",
    "section": "Capturing the context of a node",
    "text": "Capturing the context of a node\nIn some scenarios, knowing the relationship between nodes in the graph is not sufficient, because data stored inside those related nodes is required in the rhs function of a rule. In those cases, an extra argument to the constructor for a Rule is required (captures = true) to indicate that this rule will pass additional data from the lhs to the rhs function. Then, the lhs function should return a tuple, where the first element is still true or false (to indicate whether the rule matches a node) and the second element is a tuple of Context objects associated to the nodes being matched. If no match occurs, it is sufficient to return (false, ()), where () indicates an empty tuple. The rhs function should then be a function that takes as first argument the Context object of the node being replaced, and an additional argument for every Context object being captured on the lhs function and passed to the rhs function."
  },
  {
    "objectID": "manual/Graphs/index.html#execution-of-rules",
    "href": "manual/Graphs/index.html#execution-of-rules",
    "title": "Dynamic graph creation and manipulation",
    "section": "Execution of rules",
    "text": "Execution of rules\nRules are executed in the same order in which they are added to the graph object. Then, the lhs part of each rule is tested against all nodes of the specified type in the same order in which they were added to the graph. Similarly, the rhs part of a rule will be applied to those nodes that matched the lhs part, in the same order as in the matching.\n\nThe lhs part of all the rules are executed first and VPL will check that each node is not matched by more than rule. In case there is more than one match, an error will be generated. After all the lhs pars are executed, then the rhs parts are executed on the matched nodes. Although generating an error may seem restrictive, the reasoning for this approach is as follows:\n\nGraph rewriting is, conceptually, a parallel operation, so two rules cannot replace the same node as that would mean the result depends on the order in which the rules are executed.\nNew nodes will be generated by graph rewriting rules that could be matched by the lhs of other graph rewriting rules. To guarantee that all rules rewrite the same graph, all nodes that need to be replaced are identified before any rhs function is executed.\n\nIn essence, you need to program your model such that it does not rely on any specific order of execution of the graph rewriting rules."
  },
  {
    "objectID": "manual/Visualization/index.html",
    "href": "manual/Visualization/index.html",
    "title": "Backends for visualization",
    "section": "",
    "text": "Warning\n\n\n\nSome of the details may change in the short term due to changes to the Makie package (e.g., inlining of native graphics in Jupyter notebooks)"
  },
  {
    "objectID": "manual/Visualization/index.html#terminal",
    "href": "manual/Visualization/index.html#terminal",
    "title": "Backends for visualization",
    "section": "Terminal",
    "text": "Terminal\nThis means the code is ran from within the Julia REPL inside a terminal or command prompt (i.e., no IDE or notebook environment):\n\nUsing the native backend will trigger an external window (entitled Makie) where an interactive OpenGL visualization will be rendered. The interactivity provided allows zooming and moving the camera around the visualization.\nUsing the web backend will open a browser tab (unless there are some OS settings preventing, in which case a local IP address will be printed to the REPL and the user will have to manually input it into the browser) which an intetactive WebGL version will be rendered. The behaviour will be analogous to the natibe backend but note that this backend is still experimental (at the time of writing this documentation) so one should expect the ocasional bug.\nThe vector backend will not display any visual output in this context. One can still export the resulting figure (see section on Export visualization)."
  },
  {
    "objectID": "manual/Visualization/index.html#live-interactive-notebook",
    "href": "manual/Visualization/index.html#live-interactive-notebook",
    "title": "Backends for visualization",
    "section": "Live interactive notebook",
    "text": "Live interactive notebook\nThis means the code is running withn a Jupyter or Pluto notebook and they an active kernel or Julia session running in the background. Note that a notebook that is stored online will not be live unless it is hosted by a server that can run notebooks such as Binder or Google colab.\n\nThe native backend will produce an inline visualization (i.e., the visualization output shows below the code cell). This will however create a static image of the 2D or 3D with the initial camera settings (not interactive).\nThe web backend will generate the visualization output below the code cell and it will be interactive as long as the kernel or background Julia session keeps running.\nThe vector backend will display the static output next to the code cell (but only if it is using the svg engine, which is the default)."
  },
  {
    "objectID": "manual/Visualization/index.html#visual-studio-code",
    "href": "manual/Visualization/index.html#visual-studio-code",
    "title": "Backends for visualization",
    "section": "Visual Studio Code",
    "text": "Visual Studio Code\nIDEs that support Julia such as Visual Studio Code will generally have a plot pane where visualization output is stored. This can generally be turn off (in which case the behaviour of the IDE will be the same as running from a terminal). VPL has been tested with Visual Studio Code and the Julia extension and, if the plot pane is active, the behaviour will be equivalent to a live interative notebook:\n\nThe native backend will trigger an external window rather than in the plot pane.\nThe web backend will generate the visualization output in the plot pane and it will be interactive.\nThe vector backend will generate the static visualization output in the plot pane."
  },
  {
    "objectID": "manual/Visualization/index.html#document-generation",
    "href": "manual/Visualization/index.html#document-generation",
    "title": "Backends for visualization",
    "section": "Document generation",
    "text": "Document generation\nThis category includes a file that is processed by Quarto, Documenter, Weave or Literate. In all of these cases the final output will remain static while the visualization output should be generated inline (i.e., next to the code chunk). The following behavior has been observed with Quarto (other document generation methods have not been fully tested with VPL but are expected to behave similarly):\n\nFor the native backend, a static snapshot of the visualization will always be inlined. The result would be as in the inline visualization of interactive notebooks.\nThe web backend will not generate any visualization in the final document as this backend always requires interactivity.\nThe vector backend will display the static ouput as in interactive notebooks."
  },
  {
    "objectID": "manual/Visualization/index.html#on-a-headless-server",
    "href": "manual/Visualization/index.html#on-a-headless-server",
    "title": "Backends for visualization",
    "section": "On a headless server",
    "text": "On a headless server\nIt will be possible to use the visualization tools even when running VPL in a headless system (e.g., a high performance computing cluster). The folliowing is based on the documentation on Makie, it has not been tested with VPL:\n\nThe native backend will require X11 forwarding to render on the local machine or use VirtualGL technology.\nThe web backend will work if a Javascript serve is setup to serve the HTML content from the remote system (see here for details).\nThe vector backend will generate the images correctly but the user will have to export them to pdf or svg files."
  },
  {
    "objectID": "Sky/index.html",
    "href": "Sky/index.html",
    "title": "Sky solar radiation",
    "section": "",
    "text": "In development"
  },
  {
    "objectID": "tutorials/algae/index.html",
    "href": "tutorials/algae/index.html",
    "title": "Algae growth",
    "section": "",
    "text": "In this first example, we learn how to create a Graph and update it dynamically with rewriting rules.\nThe model described here is based on the non-branching model of algae growth proposed by Lindermayer as one of the first L-systems.\nFirst, we need to load the VPL metapackage, which will automatically load all the packages in the VPL ecosystem.\n\nusing VPL \n\nThe rewriting rules of the L-system are as follows:\naxiom: A\nrule 1: A \\(\\rightarrow\\) AB\nrule 2: B \\(\\rightarrow\\) A\nIn VPL, this L-system would be implemented as a graph where the nodes can be of type A or B and inherit from the abstract type Node. As indicated in the Julia Basics section, it is advised to include type definitions in a module to avoid having to restart the Julia session whenever we want to redefine them. Because each module is an independent namespace, we need to import Node from the VPL package inside the module:\n\nmodule algae\n    import VPL: Node\n    struct A <: Node end\n    struct B <: Node end\nend\nimport .algae\n\nNote that in this very example we do not need to store any data or state inside the nodes, so types A and B do not require fields.\nThe axiom is simply defined as an instance of type of A:\n\naxiom = algae.A()\n\nMain.algae.A()\n\n\nThe rewriting rules are implemented in VPL as objects of type Rule. In VPL, a rewriting rule substitutes a node in a graph with a new node or subgraph and is therefore composed of two parts:\n\nA condition that is tested against each node in a graph to choose which nodes to rewrite.\n\nA subgraph that will replace each node selected by the condition above.\n\nIn VPL, the condition is split into two components:\n\nThe type of node to be selected (in this example that would be A or B).\n\nA function that is applied to each node in the graph (of the specified type) to indicate whether the node should be selected or not. This function is optional (the default is to select every node of the specified type).\n\nThe replacement subgraph is specified by a function that takes as input the node selected and returns a subgraph defined as a combination of node objects. Subgraphs (which can also be used as axioms) are created by linearly combining objects that inherit from Node. The operation + implies a linear relationship between two nodes and [] indicates branching.\nThe implementation of the two rules of algae growth model in VPL is as follows:\n\nrule1 = Rule(algae.A, rhs = x -> algae.A() + algae.B())\nrule2 = Rule(algae.B, rhs = x -> algae.A())\n\nRule replacing nodes of type Main.algae.B without context capturing.\n\n\nNote that in each case, the argument rhs is being assigned an anonymous (aka lambda) function. This is a function without a name that is defined directly in the assigment to the argument. That is, the Julia expression x -> A() + B() is equivalent to the following function definition:\n\nfunction rule_1(x)\n    algae.A() + algae.B()\nend\n\nrule_1 (generic function with 1 method)\n\n\nFor simple rules (especially if the right hand side is just a line of code) it is easier to just define the right hand side of the rule with an anonymous function rather than creating a standalone function with a meaningful name. However, standalone functions are easier to debug as you can call them directly from the REPL.\nWith the axiom and rules we can now create a Graph object that represents the algae organism. The first argument is the axiom and the second is a tuple with all the rewriting rules:\n\norganism = Graph(axiom = axiom, rules = (rule1, rule2))\n\nDynamic graph with 1 nodes of types Main.algae.A and 2 rewriting rules.\n\n\nIf we apply the rewriting rules iteratively, the graph will grow, in this case representing the growth of the algae organism. The rewriting rules are applied on the graph with the function rewrite!():\n\nrewrite!(organism)\n\nSince there was only one node of type A, the only rule that was applied was rule1, so the graph should now have two nodes of types A and B, respectively. We can confirm this by drawing the graph. We do this with the function draw() which will always generate the same representation of the graph, but different options are available depending on the context where the code is executed. By default, draw() will create a new window where an interactive version of the graph will be drawn and one can zoom and pan with the mouse (in this online document a static version is shown, see Backends for details):\n\ndraw(organism)\n\n\n\n\n\n\nNotice that each node in the network representation is labelled with the type of node (A or B in this case) and a number in parenthesis. This number is a unique identifier associated to each node and it is useful for debugging purposes (this will be explained in more advanced examples).\nApplying multiple iterations of rewriting can be achieved with a simple loop:\n\nfor i in 1:4\n    rewrite!(organism)\nend\n\nANd we can verify that the graph grew as expected:\n\ndraw(organism)\n\n\n\n\n\n\nThe network is rather boring as the system is growing linearly (no branching) but it already illustrates how graphs can grow rapidly in just a few iterations. Remember that the interactive visualization allows adjusting the zoom, which is handy when graphs become large."
  },
  {
    "objectID": "tutorials/binary_tree/index.html",
    "href": "tutorials/binary_tree/index.html",
    "title": "Binary tree",
    "section": "",
    "text": "In this example we build a 3D representation of a binary tree. Although this will not look like a real plant, this example will help introduce additional features of VPL.\nThe model requires three types of nodes:\nMeristem: These are the nodes responsible for growth of new organs in our binary tree. They contain no data or geometry (i.e. they are a point in the 3D structure).\nInternode: The structural elements that make the binary tree, which is a simple tree made of sticks.\nTreeNode: What is left after a meristem produces a new organ. They contain no data or geometry (so also a point) but are required to keep the branching structure of the tree. Note that we cannot call this data type Node as that is a type already defined by VPL.\nIn a similar fashion to the previous example, internodes are represented by prisms, but unlike before, the length of the prism will change in time, emulating the growth of the tree. For that reason, we need to make the type mutable.\nAlso, in order to simulate growth of the 3D binary tree, we need to define a parameter describing the relative rate at which each internode elongate in each iteration of the simulation. Graphs in VPL can store an object of any user-defined type that will me made accessible to graph rewriting rules and queries. Such object is useful to store parameters (in which case we make them immutable) or state variables that cannot be associated to any specific organ (in which case we would make the object mutable). For this example, we define a data type treeparams that holds the relative growth rate (or growth factor) of the internodes of a tree.\n\nusing VPL\n\nmodule btree\n    import VPL\n    # Meristem\n    struct Meristem <: VPL.Node end\n    # Node\n    struct Node <: VPL.Node end\n    # Internode\n    mutable struct Internode <: VPL.Node\n        length::Float64\n    end\n    # Graph-level variables\n    struct treeparams\n        growth::Float64\n    end\nend\n\nMain.btree\n\n\nAs always, the 3D structure and the color of each type of node are implemented with the feedgeom! and feedcolor! methods. In this case, only the internodes have a 3D representation, so these methods are defined for this type only.\n\nfunction VPL.feedgeom!(turtle::MTurtle, i::btree.Internode)\n    HollowCube!(turtle, length = i.length, height = i.length/10, width = i.length/10, move = true)\n    return nothing\nend\nfunction VPL.feedcolor!(turtle::GLTurtle, i::btree.Internode)\n    feedcolor!(turtle, RGB(0,1,0))\n    return nothing\nend\n\nThe growth rule of our binary tree is simple: meristems are replaced a by tree node and two branches that split at specific angles. Each branch is then composed of an internode and ends in a meristem. The two branches are implemented by enclosing with square brackets and separating by commas (like when you create an array of numbers in Julia). Since a binary tree is actually a 2D structure but we want to have it 3D, we add an extra rotation, such that the new branches growing from the apical meristems are not aligned with the preceding internodes. The key is to imagine the turtle in your head and keep track of the different rotations as it moves through the rule. A concept to keep in mind there is that the position and orientation of the turtle is always the same at the beginning of each branch (i.e. essentially, at each branching point, the turtle splits into two clones that move along the tree independently).\n\nrule = Rule(btree.Meristem, rhs = mer -> btree.Node() + \n                (RU(-60.0) + btree.Internode(0.1) + RH(90.0) + btree.Meristem(), \n                 RU(60.0)  + btree.Internode(0.1) + RH(90.0) + btree.Meristem()))\n\nRule replacing nodes of type Main.btree.Meristem without context capturing.\n\n\nA binary tree initializes as a meristem, so the axiom can be constructed simply as:\n\naxiom = btree.Internode(0.1) + btree.Meristem()\n\nVPL.Core.StaticGraph(Dict{Int64, Any}(2 => VPL.Core.GraphNode{Main.btree.Meristem}(Main.btree.Meristem(), Set{Int64}(), 1, 2), 1 => VPL.Core.GraphNode{Main.btree.Internode}(Main.btree.Internode(0.1), Set([2]), missing, 1)), Dict{DataType, Set{Int64}}(Main.btree.Internode => Set([1]), Main.btree.Meristem => Set([2])), 1, 2)\n\n\nAnd the object for the tree can be constructed as before, by passing the axiom and the graph rewriting rules, but in this case also with the object with growth-related parameters.\n\ntree = Graph(axiom = axiom, rules = Tuple(rule), vars = btree.treeparams(0.5))\n\nDynamic graph with 2 nodes of types Main.btree.Internode,Main.btree.Meristem and 1 rewriting rules.\nDynamic graph variables stored in struct of type Main.btree.treeparams\n\n\nNote that so far we have not included any code to simulate growth of the internodes. The reason is that, as elongation of internotes does not change the topology of the graph (it simply changes the data stored in certain nodes), this process does not need to be implemented with graph rewriting rules. Instead, we will use a combination of a query (to identify which nodes need to be altered) and direct modification of these nodes. A Query object is a like a Rule but without a right-hand side. In this case, we just want to identify those nodes of type Internode, so we do not need to specify a left-hand side either. Instead, we simply create the query as:\n\ngetInternode = Query(btree.Internode)\n\nQuery object for nodes of type Main.btree.Internode\n\n\nIf we apply the query to a graph using the apply function, we will get an array of all the nodes that match the query, allow for direct manipulation of their contents. To help organize the code, we will create a function that simulates growth by multiplying the length argument of all internodes in a tree by the growth parameter defined in the above:\n\nfunction elongate!(tree, query)\n    for x in apply(tree, query)\n        x.length = x.length*(1.0 + vars(tree).growth)\n    end\nend\n\nelongate! (generic function with 1 method)\n\n\nNote that we use vars on the Graph object to extract the object that was stored inside of it. Also, as this function will modify the graph which is passed as input, we append an ! to the name (this not a special syntax of the language, its just a convention in the Julia community, which is ). Also, in this case, the query object is kept separate from the graph. We could have also store inside the graph like we did for the parameter grow. We could also have packaged the graph and the query into another type representing an individual tree. This is entirely up to the user and indicates that a model can be implemented in many differences ways with VPL.\nSimulating the growth a tree is a matter of elongating the internodes and applying the rules to create new internodes:\n\nfunction growth!(tree, query)\n    elongate!(tree, query)\n    rewrite!(tree)\nend\n\ngrowth! (generic function with 1 method)\n\n\nand a simulation for n steps is achieved with a simple loop:\n\nfunction simulate(tree, query, nsteps)\n    new_tree = deepcopy(tree)\n    for i in 1:nsteps\n        growth!(new_tree, query)\n    end\n    return new_tree\nend\n\nsimulate (generic function with 1 method)\n\n\nNotice that the simulate function creates a copy of the object to avoid overwriting it. If we run the simulation for a couple of steps\n\nnewtree = simulate(tree, getInternode, 2)\n\nDynamic graph with 26 nodes of types VPL.Geom.RH{Float64},Main.btree.Internode,Main.btree.Meristem,VPL.Geom.RU{Float64},Main.btree.Node and 1 rewriting rules.\nDynamic graph variables stored in struct of type Main.btree.treeparams\n\n\nThe binary tree after two iterations has two branches, as expected:\n\nrender(newtree)\n\n\n\n\nNotice how the lengths of the prisms representing internodes decreases as the branching order increases, as the internodes are younger (i.e. were generated fewer generations ago). Further steps will generate a structure that is more tree-like.\n\nnewtree = simulate(newtree, getInternode, 10)\nrender(newtree)"
  },
  {
    "objectID": "tutorials/random_binary_forest/index.html",
    "href": "tutorials/random_binary_forest/index.html",
    "title": "Forest of binary trees",
    "section": "",
    "text": "In this example we extend the binary tree example into a random binary forest, where each tree is described by a separate graph object and parameters driving the growth of these trees vary across individuals following a predefined distribution.\nThe data types, rendering methods and growth rules are the same as in the binary tree example:\nThe main difference with respect to the binary tree is that the growth parameter will differ across individuals. Also, the starting point of the turtle will differ per individual. To achieve this we need to:\nThe code for elongating the internodes to simulate growth remains the same as for the binary tree example\nLet’s simulate a forest of 10 x 10 binary trees with a distance between (and within) rows of 2 meters. First we generate the original positions of the trees. For the position we just need to pass a Vec object with the x, y, and z coordinates of the location of each tree. The code below will generate a matrix with the coordinates:\nWe now simulate the values of the growth parameter, by sampling values for a normal distribution (in practice you would determine this distribution from experiments). We can implement a function that returns random values with the desired characteristics but take into account that randn implements the standard Normal distribution (so mean = 0 and standard deviation = 1) so we need to scale it\nYou may also use the Distributions Julia package (you will need to install it first) that allows to construct different distributions and sample from them. For now, let’s work with this ad-hoc function but before we use it to generate the growth parameters of the different trees, let’s visualize it using the Plots package (as before, you need to install it first if you have not done so already):\nSo our trees will have, on average, a relative growth rate of 0.5 (like in the binary tree example) but each individual tree can have any value, mostly between 0.2 and 0.8. Let’s generate the growth parameters for the 100 trees in our simulation:\nNow we can create our random forest of binary trees by calling the create_tree function we defined earlier with the correct origins and growth parameter\nThe object forest contains an array of binary trees. Each tree is a different Graph, with its own nodes, rewriting rules and variables. This avoids having to create a large graphs to include all the plants in a simulation. Below we will run a simulation, first using a sequential approach (i.e. using one core) and then using multiple cores in our computers (please check https://docs.julialang.org/en/v1/manual/multi-threading/ if the different cores are not being used as you may need to change some settings in your computer)."
  },
  {
    "objectID": "tutorials/random_binary_forest/index.html#sequential-simulation",
    "href": "tutorials/random_binary_forest/index.html#sequential-simulation",
    "title": "Forest of binary trees",
    "section": "Sequential simulation",
    "text": "Sequential simulation\nWe can simulate the growth of each tree by applying the method simulate to each tree, creating a new version of the forest (the code below is an array comprehension)\n\nnewforest = [simulate(tree, getInternode, 2) for tree in forest];\n\nAnd we can render the forest with the function render as in the binary tree example but passing the whole forest at once\n\nrender(newforest)\n\n\n\n\nIf we iterate 4 more iterations we will start seeing the different individuals diverging in size due to the differences in growth rates\n\nnewforest = [simulate(tree, getInternode, 4) for tree in newforest];\nrender(newforest)"
  },
  {
    "objectID": "tutorials/random_binary_forest/index.html#multithreaded-simulation",
    "href": "tutorials/random_binary_forest/index.html#multithreaded-simulation",
    "title": "Forest of binary trees",
    "section": "Multithreaded simulation",
    "text": "Multithreaded simulation\nIn the previous section, the simulation of growth was done sequentially, one tree after another (since the growth of a tree only depends on its own parameters). However, this can also be executed in multiple threads. In this case we use an explicit loop and execute the iterations of the loop in multiple threads using the macro @threads. Note that the rendering function can also be ran in parallel (i.e. the geometry will be generated separately for each plant and the merge together):\n\nusing Base.Threads\nnewforest = deepcopy(forest)\n@threads for i in 1:length(forest)\n    newforest[i] = simulate(forest[i], getInternode, 6)\nend\nrender(newforest, parallel = true)\n\n\n\n\nAn alternative way to perform the simulation is to have an outer loop for each timestep and an internal loop over the different trees. Although this approach is not required for this simple model, most FSP models will probably need such a scheme as growth of each individual plant will depend on competition for resources with neighbouring plants. In this case, this approach would look as follows:\n\nnewforest = deepcopy(forest)\nfor step in 1:6\n    @threads for i in 1:length(newforest)\n        newforest[i] = simulate(newforest[i], getInternode, 1)\n    end\nend\nrender(newforest, parallel = true)"
  },
  {
    "objectID": "tutorials/relational_queries/index.html",
    "href": "tutorials/relational_queries/index.html",
    "title": "Relational queries",
    "section": "",
    "text": "In this example we illustrate how to test relationships among nodes inside queries. Relational queries allow to establish relationships between nodes in the graph, which generally requires a intimiate knowledge of the graph. For this reason, relational queries are inheretly complex as graphs can become complex and there may be solutions that do not require relational queries in many instances. Nevertheless, they are integral part of VPL and can sometimes be useful. As they can be hard to grasp, this tutorial will illustrate with a relatively simple graph a series of relational queries with increasing complexity with the aim that users will get a better understanding of relational queries. For this purpose, an abstract graph with several branching levels will be used, so that we can focus on the relations among the nodes without being distracted by case-specific details.\nThe graph will be composed of two types of nodes: the inner nodes (A and C) and the leaf nodes (B). Each leaf node will be identified uniquely with an index and the objective is to write queries that can identify a specific subset of the leaf nodes, without using the data stored in the nodes themselves. That is, the queries should select the right nodes based on their relationships to the rest of nodes in the graph. Note that C nodes contain a single value that may be positive or negative, whereas A nodes contain no data.\nAs usual, we start with defining the types of nodes in the graph\nWe generate the graph directly, rather than with rewriting rules. The graph has a motif that is repeated three times (with a small variation), so we can create the graph in a piecewise manner. Note how we can use the function sum to add nodes to the graph (i.e. sum(A() for i in 1:3) is equivalent to A() + A() + A())\nBy default, VPL will use as node label the type of node and the internal ID generated by VPL itself. This ID is useful if we want to extract a particular node from the graph, but it is not controlled by the user. However, the user can specialized the function node_label() to specify exactly how to label the nodes of a particular type. In this case, we want to just print A or C for nodes of type A and C, whereas for nodes of type B we want to use the ID field that was stored inside the node during the graph generation.\nTo clarify, the id argument of the function node_label() refers to the internal id generated by VPL (used by the default method for node_label(), whereas the the first argument is the data stored inside a node (in the case of B nodes, there is a field called ID that will not be modified by VPL as that is user-provided data).\nThe goal of this exercise is then to write queries that retrieve specific B nodes (without using the data stored in the node in the query, that is, we have to identify nodes based on their topological connections to other nodes)."
  },
  {
    "objectID": "tutorials/relational_queries/index.html#all-nodes-of-type-b",
    "href": "tutorials/relational_queries/index.html#all-nodes-of-type-b",
    "title": "Relational queries",
    "section": "All nodes of type B",
    "text": "All nodes of type B\nFirst, we create the query object. In this case, there is no special condition as we want to retrieve all the nodes of type B\n\nQ1 = Query(Q.B)\n\nQuery object for nodes of type Main.Queries.B\n\n\nApplying the query to the graph returns an array with all the B nodes\n\nA1 = apply(graph, Q1)\n\n13-element Vector{Main.Queries.B}:\n Main.Queries.B(7)\n Main.Queries.B(8)\n Main.Queries.B(3)\n Main.Queries.B(10)\n Main.Queries.B(5)\n Main.Queries.B(6)\n Main.Queries.B(2)\n Main.Queries.B(12)\n Main.Queries.B(1)\n Main.Queries.B(11)\n Main.Queries.B(13)\n Main.Queries.B(9)\n Main.Queries.B(4)\n\n\nFor the remainder of this tutorial, the code will be hidden by default to allow users to try on their own."
  },
  {
    "objectID": "tutorials/relational_queries/index.html#node-containing-value-13",
    "href": "tutorials/relational_queries/index.html#node-containing-value-13",
    "title": "Relational queries",
    "section": "Node containing value 13",
    "text": "Node containing value 13\nSince the B node 13 is the leaf node of the main branch of the graph (e.g. this could be the apical meristem of the main stem of a plant), there are no rotations between the root node of the graph and this node. Therefore, the only condition require to single out this node is that it has no ancestor node of type C.\nChecking whether a node has an ancestor that meets a certain condition can be achieved with the function hasAncestor(). Similarly to the condition of the Query object, the hasAncestor() function also has a condition, in this case applied to the parent node of the node being tested, and moving upwards in the graph recursively (until reaching the root node). Note that, in order to access the object stored inside the node, we need to use the data() function, and then we can test if that object is of type C. The B node 13 is the only node for which hasAncestor() should return false:\n\n\nShow the code\nfunction Q2_fun(n)\n    check, steps = hasAncestor(n, condition = x -> data(x) isa Q.C)\n    !check\nend\n\n\nQ2_fun (generic function with 1 method)\n\n\nAs before, we just need to apply the Query object to the graph:\n\n\nShow the code\nQ2 = Query(Q.B, condition = Q2_fun)\nA2 = apply(graph, Q2)\n\n\n1-element Vector{Main.Queries.B}:\n Main.Queries.B(13)"
  },
  {
    "objectID": "tutorials/relational_queries/index.html#nodes-containing-values-1-2-and-3",
    "href": "tutorials/relational_queries/index.html#nodes-containing-values-1-2-and-3",
    "title": "Relational queries",
    "section": "Nodes containing values 1, 2 and 3",
    "text": "Nodes containing values 1, 2 and 3\nThese three nodes belong to one of the branch motifs repeated through the graph. Thus, we need to identify the specific motif they belong to and chose all the B nodes inside that motif. The motif is defined by an A node that has a C child with a negative val and parent node C with positive val. This A node should then be 2 nodes away from the root node to separate it from upper repetitions of the motif. Therefore, we need to test for two conditions, first find those nodes inside a branch motif, then retrieve the root of the branch motif (i.e., the A node described in the above) and then check the distance of that node from the root:\n\n\nShow the code\nfunction branch_motif(p)\n    data(p) isa Q.A && \n    hasDescendent(p, condition = x -> data(x) isa Q.C && data(x).val < 0.0) &&\n    hasAncestor(p, condition = x -> data(x) isa Q.C && data(x).val > 0.0)[1]\nend\n\nfunction Q3_fun(n, nsteps)\n    # Condition 1\n    check, steps = hasAncestor(n, condition = branch_motif)\n    !check && return false\n    # Condition 2\n    p = parent(n, nsteps = steps)\n    check, steps = hasAncestor(p, condition = isRoot)\n    steps != nsteps && return false\n    return true\nend\n\n\nQ3_fun (generic function with 1 method)\n\n\nAnd applying the query to the object results in the required nodes:\n\n\nShow the code\nQ3 = Query(Q.B, condition = n -> Q3_fun(n, 2))\nA3 = apply(graph, Q3)\n\n\n3-element Vector{Main.Queries.B}:\n Main.Queries.B(3)\n Main.Queries.B(2)\n Main.Queries.B(1)"
  },
  {
    "objectID": "tutorials/relational_queries/index.html#node-containing-value-4",
    "href": "tutorials/relational_queries/index.html#node-containing-value-4",
    "title": "Relational queries",
    "section": "Node containing value 4",
    "text": "Node containing value 4\nThe node B with value 4 can be singled-out because there is no branching point between the root node and this node. This means that no ancestor node should have more than one children node except the root node. Remember that hasAncestor() returns two values, but we are only interested in the first value. You do not need to assign the returned object from a Julia function, you can just index directly the element to be selected from the returned tuple:\n\n\nShow the code\nfunction Q4_fun(n)\n    !hasAncestor(n, condition = x -> !isRoot(x) && length(children(x)) > 1)[1]\nend\n\n\nQ4_fun (generic function with 1 method)\n\n\nAnd applying the query to the object results in the required node:\n\n\nShow the code\nQ4 = Query(Q.B, condition = Q4_fun)\nA4 = apply(graph, Q4)\n\n\n1-element Vector{Main.Queries.B}:\n Main.Queries.B(4)"
  },
  {
    "objectID": "tutorials/relational_queries/index.html#node-containing-value-3",
    "href": "tutorials/relational_queries/index.html#node-containing-value-3",
    "title": "Relational queries",
    "section": "Node containing value 3",
    "text": "Node containing value 3\nThis node is the only B node that is four steps from the root node, which we can retrieve from the second argument returned by hasAncestor():\n\n\nShow the code\nfunction Q5_fun(n)\n    check, steps = hasAncestor(n, condition = isRoot)\n    steps == 4\nend\n\nQ5 = Query(Q.B, condition = Q5_fun)\nA5 = apply(graph, Q5)\n\n\n1-element Vector{Main.Queries.B}:\n Main.Queries.B(3)"
  },
  {
    "objectID": "tutorials/relational_queries/index.html#node-containing-value-7",
    "href": "tutorials/relational_queries/index.html#node-containing-value-7",
    "title": "Relational queries",
    "section": "Node containing value 7",
    "text": "Node containing value 7\nNode B 7 belongs to the second lateral branch motif and the second parent node is of type A. Note that we can reuse the Q3_fun from before in the condition required for this node:\n\n\nShow the code\nfunction Q6_fun(n, nA)\n    check = Q3_fun(n, nA)\n    !check && return false\n    p2 = parent(n, nsteps = 2)\n    data(p2) isa Q.A\nend\n\nQ6 = Query(Q.B, condition = n -> Q6_fun(n, 3))\nA6 = apply(graph, Q6)\n\n\n1-element Vector{Main.Queries.B}:\n Main.Queries.B(7)"
  },
  {
    "objectID": "tutorials/relational_queries/index.html#nodes-containing-values-11-and-13",
    "href": "tutorials/relational_queries/index.html#nodes-containing-values-11-and-13",
    "title": "Relational queries",
    "section": "Nodes containing values 11 and 13",
    "text": "Nodes containing values 11 and 13\nThe B nodes 11 and 13 actually have different relationships to the rest of the graph, so we just need to define two different condition functions and combine them. The condition for the B node 11 is similar to the B node 7, whereas the condition for node 13 was already constructed before, so we just need to combined them with an OR operator:\n\n\nShow the code\nQ7 = Query(Q.B, condition = n -> Q6_fun(n, 4) || Q2_fun(n))\nA7 = apply(graph, Q7)\n\n\n2-element Vector{Main.Queries.B}:\n Main.Queries.B(11)\n Main.Queries.B(13)"
  },
  {
    "objectID": "tutorials/relational_queries/index.html#nodes-containing-values-1-5-and-9",
    "href": "tutorials/relational_queries/index.html#nodes-containing-values-1-5-and-9",
    "title": "Relational queries",
    "section": "Nodes containing values 1, 5 and 9",
    "text": "Nodes containing values 1, 5 and 9\nThese nodes play the same role in the three lateral branch motifs. They are the only B nodes preceded by the sequence A C+ A. We just need to check the sequence og types of objects for the the first three parents of each B node:\n\n\nShow the code\nfunction Q8_fun(n)\n    p1 = parent(n)\n    p2 = parent(n, nsteps = 2)\n    p3 = parent(n, nsteps = 3)\n    data(p1) isa Q.A && data(p2) isa Q.C && data(p2).val > 0.0 && data(p3) isa Q.A\nend\n\nQ8 = Query(Q.B, condition = Q8_fun)\nA8 = apply(graph, Q8)\n\n\n3-element Vector{Main.Queries.B}:\n Main.Queries.B(5)\n Main.Queries.B(1)\n Main.Queries.B(9)"
  },
  {
    "objectID": "tutorials/relational_queries/index.html#nodes-contaning-values-2-6-and-10",
    "href": "tutorials/relational_queries/index.html#nodes-contaning-values-2-6-and-10",
    "title": "Relational queries",
    "section": "Nodes contaning values 2, 6 and 10",
    "text": "Nodes contaning values 2, 6 and 10\nThis exercise is similar to the previous one, but the C node has a negative val. The problem is that node 12 would also match the pattern A C- A. We can differentiate between this node and the rest by checking for a fourth ancestor node of class C:\n\n\nShow the code\nfunction Q9_fun(n)\n    p1 = parent(n)\n    p2 = parent(n, nsteps = 2)\n    p3 = parent(n, nsteps = 3)\n    p4 = parent(n, nsteps = 4)\n    data(p1) isa Q.A && data(p2) isa Q.C && data(p2).val < 0.0 && \n       data(p3) isa Q.A && data(p4) isa Q.C\nend\n\nQ9 = Query(Q.B, condition = Q9_fun)\nA9 = apply(graph, Q9)\n\n\n3-element Vector{Main.Queries.B}:\n Main.Queries.B(10)\n Main.Queries.B(6)\n Main.Queries.B(2)"
  },
  {
    "objectID": "tutorials/relational_queries/index.html#nodes-containg-values-6-7-and-8",
    "href": "tutorials/relational_queries/index.html#nodes-containg-values-6-7-and-8",
    "title": "Relational queries",
    "section": "Nodes containg values 6, 7 and 8",
    "text": "Nodes containg values 6, 7 and 8\nWe already came up with a condition to extract node 7. We can also modify the previous condition so that it only node 6. Node 8 can be identified by checking for the third parent node being of type C and being 5 nodes from the root of the graph.\nAs always, we can reusing previous conditions since they are just regular Julia functions:\n\n\nShow the code\nfunction Q10_fun(n)\n    Q6_fun(n, 3) && return true # Check node 7\n    Q9_fun(n) && hasAncestor(n, condition = isRoot)[2] == 6 && return true # Check node 6\n    hasAncestor(n, condition = isRoot)[2] == 5 && data(parent(n, nsteps = 3)) isa Q.C && return true # Check node 8 (and not 4!)\nend\n\nQ10 = Query(Q.B, condition = Q10_fun)\nA10 = apply(graph, Q10)\n\n\n3-element Vector{Main.Queries.B}:\n Main.Queries.B(7)\n Main.Queries.B(8)\n Main.Queries.B(6)"
  },
  {
    "objectID": "tutorials/relational_queries/index.html#nodes-containig-values-3-7-11-and-12",
    "href": "tutorials/relational_queries/index.html#nodes-containig-values-3-7-11-and-12",
    "title": "Relational queries",
    "section": "Nodes containig values 3, 7, 11 and 12",
    "text": "Nodes containig values 3, 7, 11 and 12\nWe already have conditions to select nodes 3, 7 and 11 so we just need a new condition for node 12 (similar to the condition for 8).\n\n\nShow the code\nfunction Q11_fun(n)\n    Q5_fun(n) && return true # 3\n    Q6_fun(n, 3) && return true # 7\n    Q6_fun(n, 4) && return true # 11\n    hasAncestor(n, condition = isRoot)[2] == 5 && data(parent(n, nsteps = 2)) isa Q.C && \n        data(parent(n, nsteps = 4)) isa Q.A && return true # 12\nend\n\nQ11 = Query(Q.B, condition = Q11_fun)\nA11 = apply(graph, Q11)\n\n\n4-element Vector{Main.Queries.B}:\n Main.Queries.B(7)\n Main.Queries.B(3)\n Main.Queries.B(12)\n Main.Queries.B(11)"
  },
  {
    "objectID": "tutorials/relational_queries/index.html#nodes-containing-values-7-and-12",
    "href": "tutorials/relational_queries/index.html#nodes-containing-values-7-and-12",
    "title": "Relational queries",
    "section": "Nodes containing values 7 and 12",
    "text": "Nodes containing values 7 and 12\nWe just need to combine the conditions for the nodes 7 and 12\n\n\nShow the code\nfunction Q12_fun(n)\n    Q6_fun(n, 3) && return true # 7\n    hasAncestor(n, condition = isRoot)[2] == 5 && data(parent(n, nsteps = 2)) isa Q.C && \n        data(parent(n, nsteps = 4)) isa Q.A && return true # 12\nend\n\nQ12 = Query(Q.B, condition = Q12_fun)\nA12 = apply(graph, Q12)\n\n\n2-element Vector{Main.Queries.B}:\n Main.Queries.B(7)\n Main.Queries.B(12)"
  },
  {
    "objectID": "tutorials/snowflakes/index.html",
    "href": "tutorials/snowflakes/index.html",
    "title": "The Koch snowflake",
    "section": "",
    "text": "In this example, we create a Koch snowflake, which is one of the earliest fractals to be described. The Koch snowflake is a closed curve composed on multiple of segments of different lengths. Starting with an equilateral triangle, each segment in the snowflake is replaced by four segments of smaller length arrange in a specific manner. Graphically, the first four iterations of the Koch snowflake construction process result in the following figures (the green segments are shown as guides but they are not part of the snowflake):\n\n\n\nFirst four iterations fo Koch snowflake fractal\n\n\nIn order to implement the construction process of a Koch snowflake in VPL we need to understand how a 3D structure can be generated from a graph of nodes. VPL uses a procedural approach to generate of structure based on the concept of turtle graphics.\nThe idea behind this approach is to imagine a turtle located in space with a particular position and orientation. The turtle then starts consuming the different nodes in the graph (following its topological structure) and generates 3D structures as defined by the user for each type of node. The consumption of a node may also include instructions to move and/or rotate the turtle, which allows to alter the relative position of the different 3D structures described by a graph.\nThe construction process of the Koch snowflake in VPL could then be represented by the following axiom and rewriting rule:\naxiom: E(L) + RU(120) + E(L) + RU(120) + E(L)\nrule: E(L) → E(L/3) + RU(-60) + E(L/3) + RU(120) + E(L/3) + RU(-60) + E(L/3)\nWhere E represent and edge of a given length (given in parenthesis) and RU represents a rotation of the turtle around the upward axis, with angle of rotation given in parenthesis in hexadecimal degrees. The rule can be visualized as follows:\n\n\n\nKoch construction rule\n\n\nNote that VPL already provides several classes for common turtle movements and rotations, so our implementation of the Koch snowflake only needs to define a class to implement the edges of the snowflake. This can be achieved as follows:\n\nusing VPL\nmodule sn\n    import VPL\n    struct E <: VPL.Node\n        length::Float64\n    end\nend\nimport .sn\n\nNote that nodes of type E need to keep track of the length as illustrated in the above. The axiom is straightforward:\n\nconst L = 1.0\naxiom = sn.E(L) + VPL.RU(120.0) + sn.E(L) + VPL.RU(120.0) + sn.E(L)\n\nVPL.Core.StaticGraph(Dict{Int64, Any}(5 => VPL.Core.GraphNode{Main.sn.E}(Main.sn.E(1.0), Set{Int64}(), 4, 5), 4 => VPL.Core.GraphNode{VPL.Geom.RU{Float64}}(VPL.Geom.RU{Float64}(120.0), Set([5]), 3, 4), 2 => VPL.Core.GraphNode{VPL.Geom.RU{Float64}}(VPL.Geom.RU{Float64}(120.0), Set([3]), 1, 2), 3 => VPL.Core.GraphNode{Main.sn.E}(Main.sn.E(1.0), Set([4]), 2, 3), 1 => VPL.Core.GraphNode{Main.sn.E}(Main.sn.E(1.0), Set([2]), missing, 1)), Dict{DataType, Set{Int64}}(Main.sn.E => Set([5, 3, 1]), VPL.Geom.RU{Float64} => Set([4, 2])), 1, 5)\n\n\nThe rule is also straightforward to implement as all the nodes of type E will be replaced in each iteration. However, we need to ensure that the length of the new edges is a calculated from the length of the edge being replaced. In order to extract the data stored in the node being replaced we can simply use the function data. In this case, the replacement function is defined and then added to the rule. This can make the code more readable but helps debugging and testing the replacement function.\n\nfunction Kochsnowflake(x)\n    L = data(x).length\n    sn.E(L/3) + RU(-60.0) + sn.E(L/3) + RU(120.0) + sn.E(L/3) + RU(-60.0) + sn.E(L/3)\n end\n rule = Rule(sn.E, rhs = Kochsnowflake)\n\nRule replacing nodes of type Main.sn.E without context capturing.\n\n\nThe model is then created by constructing the graph\n\nKoch = Graph(axiom = axiom, rules = Tuple(rule))\n\nDynamic graph with 5 nodes of types Main.sn.E,VPL.Geom.RU{Float64} and 1 rewriting rules.\n\n\nIn order to be able to generate a 3D structure we need to define a method for the function VPL.feedgeom! (notice the need to prefix it with VPL. as we are going to define a method for this function). The method needs to two take two arguments, the first one is always an object of type MTurtle and the second is an object of the type for which the method is defined (in this case, E).\nThe body of the method should generate the 3D structures using the geometry primitives provided by VPL and feed them to the turtle that is being passed to the method as first argument. In this case, we are going to represent the edges of the Koch snowflakes with cylinders, which can be generated with the HollowCylinder! function from VPL. Note that the feedgeom! should return nothing, the turtle will be modified in place (hence the use of ! at the end of the function as customary in the VPL community):\n\nfunction VPL.feedgeom!(turtle::MTurtle, e::sn.E)\n    HollowCylinder!(turtle, length = e.length, width = e.length/10, height = e.length/10, move = true)\n    return nothing\nend\n\nNote that the argument move = true indicates that the turtle should move forward as the cylinder is generated a distance equal to the length of the cylinder.\nWith the feedgeom! method defined we can already generate the 3D structure, but we cannot render it yet as we also need to define the color with which to render it. This is achieved by defining the VPL.feedcolor! method that takes a GLTurtle as argument (notice the different data types, MTurtle to collect triangular meshes, GLTurtle to collect colors for rendering). In this case, we just feed a basic RGB color defined by the proportion of red, green and blue. To make the figures more appealing, we can assign random values to each channel of the color to generate random colors.\n\nfunction VPL.feedcolor!(turtle::GLTurtle, e::sn.E)\n    feedcolor!(turtle, RGB(rand(), rand(), rand()))\n    return nothing\nend\n\nAfter defining these two methods, we can now call the function render on the graph to generate a 3D interactive image of the Koch snowflake in the current state\n\nrender(Koch, axes = false)\n\n\n\n\nThis renders the initial triangle of the construction procedure of the Koch snowflake. Let’s execute the rules once to verify that we get the 2nd iteration (check the figure at the beginning of this document):\n\nrewrite!(Koch)\nrender(Koch, axes = false)\n\n\n\n\nAnd two more times\n\nfor i in 1:3\n    rewrite!(Koch)\nend\nrender(Koch, axes = false)\n\n\n\n\n\nOther snowflake fractals\nTo demonstrate the power of this approach, let’s create an alternative snowflake. We will simply invert the rotations of the turtle in the rewriting rule\n\nfunction Kochsnowflake2(x)\n   L = data(x).length\n   sn.E(L/3) + RU(60.0) + sn.E(L/3) + RU(-120.0) + sn.E(L/3) + RU(60.0) + sn.E(L/3)\nend\nrule2 = Rule(sn.E, rhs = Kochsnowflake2)\nKoch2 = Graph(axiom = axiom, rules = Tuple(rule2))\n\nDynamic graph with 5 nodes of types Main.sn.E,VPL.Geom.RU{Float64} and 1 rewriting rules.\n\n\nThe axiom is the same, but now the edges added by the rule will generate the edges towards the inside of the initial triangle. Let’s execute the first three iterations and render the results\n\n# First iteration\nrewrite!(Koch2)\nrender(Koch2, axes = false)\n# Second iteration\nrewrite!(Koch2)\nrender(Koch2, axes = false)\n# Third iteration\nrewrite!(Koch2)\nrender(Koch2, axes = false)\n\n\n\n\nThis is know as Koch antisnowflake. We could also easily generate a Cesàro fractal by also changing the axiom:\n\naxiomCesaro = sn.E(L) + RU(90.0) + sn.E(L) + RU(90.0) + sn.E(L) + RU(90.0) + sn.E(L)\nCesaro = Graph(axiom = axiomCesaro, rules = (rule2,))\nrender(Cesaro, axes = false)\n\n\n\n\nAnd, as before, let’s go through the first three iterations\n\n# First iteration\nrewrite!(Cesaro)\nrender(Cesaro, axes = false)\n# Second iteration\nrewrite!(Cesaro)\nrender(Cesaro, axes = false)\n# Third iteration\nrewrite!(Cesaro)\nrender(Cesaro, axes = false)"
  }
]