[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site!"
  },
  {
    "objectID": "api/Core.html#types",
    "href": "api/Core.html#types",
    "title": "Virtual Plant Laboratory",
    "section": "Types",
    "text": "Types\n# VPL.Core.Graph — Type.\nGraph(;axiom, rules = nothing, vars = nothing)\nCreate a dynamic graph from an axiom, one or more rules and, optionally, graph-level variables.\nArguments\n\naxiom: A single object inheriting from Node or a subgraph generated with\n\nthe graph construction DSL. It should represent the initial state of the dynamic graph.\n\nrules: A single Rule object or a tuple of Rule objects (optional). It\n\nshould include all graph-rewriting rules of the graph.\n\nvars: A single object of any user-defined type (optional). This will be the\n\ngraph-level variable accessible from any rule or query applied to the graph.\n\nFT: Floating-point precision to be used when generating the 3D geometry\n\nassociated to a graph.\nDetails\nAll arguments are assigned by keyword. The axiom and rules are deep-copied when creating the graph but the graph-level variables (if a copy is needed due to mutability, the user needs to care of that).\nReturn\nAn object of type Graph representing a dynamic graph. Printing this object results in a human-readable description of the type of data stored in the graph.\nExamples\nlet\n    struct A0 <: Node end\n    struct B0 <: Node end\n    axiom = A0() + B0()\n    no_rules_graph = Graph(axiom = axiom)\n    rule = Rule(A, rhs = x -> A0() + B0())\n    rules_graph = Graph(axiom = axiom, rules = rule)\nend\nsource\n# VPL.Core.Rule — Type.\nRule(nodetype; lhs = x -> true, rhs = x -> nothing, captures = false)\nCreate a replacement rule for nodes of type nodetype.\nArguments\n\nnodetype: Type of node to be matched.\nlhs: Function or function-like object that takes a Context object and\n\nreturns whether the node should be replaced or not (with true or false).\n\nrhs: Function or function-like object that takes one or more Context\n\nobjects and returns a replacement graph or nothing. If it takes several inputs, the first one will correspond to the node being replaced.\n\ncaptures: Either false or true to indicate whether the left-hand side\n\nof the rule is capturing nodes in the context of the replacement node to be used for the construction of the replace graph.\nDetails\nSee VPL documentation for details on rule-based graph rewriting.\nReturn\nAn object of type Rule.\nExamples\nlet\n    struct A <: Node end\n    struct B <: Node end\n    axiom = A() + B()\n    rule = Rule(A, rhs = x -> A() + B())\n    rules_graph = Graph(axiom = axiom, rules = rule)\n    rewrite!(rules_graph)\nend\nsource\n# VPL.Core.Query — Type.\nQuery(nodetype::DataType; condition = x -> true)\nCreate a query that matches nodes of type nodetype and a condition.\nArguments\n\nnodetype::DataType: Type of node to be matched.\ncondition: Function or function-like object that checks if a node should be\n\nselected. It is assigned as a keyword argument.\nDetails\nIf the nodetype should refer to a concrete type and match one of the types stored inside the graph. Abstract types or types that are not contained in the graph are allowed but the query will never return anything.\nThe condition must be a function or function-like object that takes a Context as input and returns true or false. The default condition always return true such that the query will\nReturn\nIt returns an object of type Query. Use apply() to execute the query on a dynamic graph.\nExample\nstruct A <: Node end\nstruct B <: Node end\naxiom = A() + B()\ngraph = Graph(axiom)\nquery = Query(A)\napply(graph, query)\nsource\n# VPL.Core.Node — Type.\nNode\nAbstract type from which every node in a graph should inherit. This allows using the graph construction DSL.\nExample\nlet\n  struct bar <: Node\n    x::Int\n  end\n  b1 = bar(1)\n  b2 = bar(2)\n  b1 + b2\nend\nsource\n# VPL.Core.Context — Type.\nContext\nData structure than links a node to the rest of the graph.\nFields\n\ngraph: Dynamic graph that contains the node.\nnode: Node inside the graph.\n\nDetails\nA Context object wraps references to a node and its associated graph. The purpose of this structure is to be able to test relationships among nodes within a graph (from with a query or rule), as well as access the data stored in a node (with data()) or the graph (with vars()).\nUsers do not build Context objects directly but they are provided by VPL as inputs to the user-defined functions inside rules and queries.\nsource"
  },
  {
    "objectID": "api/Core.html#graph-dsl",
    "href": "api/Core.html#graph-dsl",
    "title": "Virtual Plant Laboratory",
    "section": "Graph DSL",
    "text": "Graph DSL\n# Base.:+ — Method.\n+(n1::Node, n2::Node)\nCreates a graph with two nodes where n1 is the root and n2 is the insertion point.\nExamples\nlet\n    struct A1 <: Node val::Int end\n    struct B1 <: Node val::Int end\n    axiom = A1(1) + B1(1)\n    draw(axiom)\nend\nsource\n# Base.:+ — Method.\n+(g::StaticGraph, n::Node)\nCreates a graph as the result of appending the node n to the insertion point of graph g.\nExamples\nlet\n    struct A1 <: Node val::Int end\n    struct B1 <: Node val::Int end\n    axiom = A1(1) + B1(1)\n    axiom = axiom + A1(2)\n    draw(axiom)\nend\nsource\n# Base.:+ — Method.\n+(n::Node, g::StaticGraph)\nCreates a graph as the result of appending the static graph g to the node n.\nExamples\nlet\n    struct A1 <: Node val::Int end\n    struct B1 <: Node val::Int end\n    axiom = A1(1) + B1(1)\n    axiom = A1(2) + axiom\n    draw(axiom)\nend\nsource\n# Base.:+ — Method.\n+(g1::StaticGraph, g2::StaticGraph)\nCreates a graph as the result of appending g2 to the insertion point of g1. The insertion point of the final graph corresponds to the insertion point of g2.\nExamples\nlet\n    struct A1 <: Node val::Int end\n    struct B1 <: Node val::Int end\n    axiom1 = A1(1) + B1(1)\n    axiom2 = A1(2) + B1(2)\n    axiom = axiom1 + axiom2\n    draw(axiom)\nend\nsource\n# Base.:+ — Method.\n+(g::StaticGraph, T::Tuple)\n+(n::Node, T::Tuple)\nCreates a graph as the result of appending a tuple of graphs/nodes T to the insertion point of the graph g or node n. Each graph/node in L becomes a branch.\nExamples\nlet\n    struct A1 <: Node val::Int end\n    struct B1 <: Node val::Int end\n    axiom = A1(1) + (B1(1) + A1(3), B1(4))\n    draw(axiom)\nend\nsource"
  },
  {
    "objectID": "api/Core.html#applying-rules-and-queries",
    "href": "api/Core.html#applying-rules-and-queries",
    "title": "Virtual Plant Laboratory",
    "section": "Applying rules and queries",
    "text": "Applying rules and queries\n# VPL.Core.apply — Method.\napply(g::Graph, query::Query)\nReturn an array with all the nodes in the graph that match the query supplied by the user.\nExample\nstruct A <: Node end\nstruct B <: Node end\naxiom = A() + B()\ngraph = Graph(axiom)\nquery = Query(A)\napply(graph, query)\nsource\n# VPL.Core.rewrite! — Method.\nrewrite!(g::Graph)\nApply the graph-rewriting rules stored in the graph.\nArguments\n\ng::Graph: The graph to be rewritten. It will be modified in-place.\n\nDetails\nThis function will match the left-hand sides of all the rules in a graph. If any node is matched by more than one rule this will result in an error. The rules are then applied in order to replaced the matched nodes with the result of executing the right hand side of the rules. The rules are applied in the order in which they are stored in the graph but the order in which the nodes are processed is not defined. Since graph rewriting is semantically a parallel process, the rules should not be rely on any particular order for their functioning.\nReturns\nThis function returns nothing, but the graph passed as input will be modified by the execution of the rules.\nExample\nlet\n    struct A <: Node end\n    struct B <: Node end\n    axiom = A() + B()\n    rule = Rule(A, rhs = x -> A() + B())\n    g = Graph(axiom = axiom, rules = rule)\n    rewrite!(g)\nend\nsource"
  },
  {
    "objectID": "api/Core.html#extracting-information",
    "href": "api/Core.html#extracting-information",
    "title": "Virtual Plant Laboratory",
    "section": "Extracting information",
    "text": "Extracting information\n# VPL.Core.vars — Method.\nvars(g::Graph)\nReturns the graph-level variables.\nExample\nstruct A <: Node end\naxiom = A()\ngraph = Graph(axiom, vars = 2)\nvars(graph)\nsource\n# VPL.Core.rules — Method.\nrules(g::Graph)\nReturns a tuple with all the graph-rewriting rules stored in a dynamic graph\nExamples\nstruct A <: Node end\nstruct B <: Node end\naxiom = A() + B()\nrule = Rule(A, rhs = x -> A() + B())\nrules_graph = Graph(axiom, rules = rule)\nrules(rules_graph)\nsource\n# VPL.Core.vars — Method.\nvars(c::Context)\nReturns the graph-level variables. Intended to be used within a rule or query.\nsource\n# VPL.Core.data — Method.\ndata(c::Context)\nReturns the data stored in a node. Intended to be used within a rule or query.\nsource"
  },
  {
    "objectID": "api/Core.html#node-relations",
    "href": "api/Core.html#node-relations",
    "title": "Virtual Plant Laboratory",
    "section": "Node relations",
    "text": "Node relations\n# VPL.Core.hasParent — Method.\nhasParent(c::Context)\nCheck if a node has a parent and return true or false. Intended to be used within a rule or query.\nsource\n# VPL.Core.isRoot — Method.\nisRoot(c::Context)\nCheck if a node is the root of the graph (i.e., has no parent) and return true or false. Intended to be used within a rule or query.\nsource\n# VPL.Core.hasAncestor — Method.\nhasAncestor(c::Context; condition = x -> true, maxlevel::Int = typemax(Int))\nCheck if a node has an ancestor that matches the condition. Intended to be used within a rule or query.\nArguments\n\nc::Context: Context associated to a node in a dynamic graph.\ncondition: An user-defined function that takes a Context object as input\n\nand returns true or false. It is assigned by the user by keyword.\n\nmaxlevel::Int: Maximum number of steps that the algorithm may take when\n\ntraversing the graph.\nDetails\nThis function traverses the graph from the node associated to c towards the root of the graph until a node is found for which condition returns true. If no node meets the condition, then it will return false. The defaults values for this function are such that the algorithm always returns true after one step (unless it is applied to the root node) in which case it is equivalent to calling hasParent on the node.\nThe number of levels that the algorithm is allowed to traverse is capped by maxlevel (mostly to avoid excessive computation, though the user may want to specify a meaningful limit based on the topology of the graphs being used).\nThe function condition should take an object of type Context as input and return true or false.\nReturn\nReturn a tuple with two values a Bool and an Int, the boolean indicating whether the node has an ancestor meeting the condition, the integer indicating the number of levels in the graph separating the node an its ancestor.\nExamples\nlet\n    struct A1 <: Node val::Int end\n    struct B1 <: Node val::Int end\n    axiom = A1(2) + (B1(1) + A1(3), B1(4))\n    g = Graph(axiom = axiom)\n    function qfun(n)\n        hasAncestor(n, condition = x -> data(x).val == 1)[1]\n    end\n    Q1 = Query(A1, query = qfun)\n    R1 = apply(g, Q1)\n    Q2 = Query(B1, query = qfun)\n    R2 = apply(g, Q2)\n    (R1,R2)\nend\nsource\n# Base.parent — Method.\nparent(c::Context; nsteps::Int)\nReturns the parent of a node that is nsteps away towards the root of the graph. Intended to be used within a rule or query.\nDetails\nIf hasParent() returns false for the same node or the algorithm has reached the root node but nsteps have not been reached, then parent() will return missing, otherwise it returns the Context associated to the matching node.\nReturn\nReturn a Context object or missing.\nExamples\nlet\n    struct A1 <: Node val::Int end\n    struct B1 <: Node val::Int end\n    axiom = A1(2) + (B1(1) + A1(3), B1(4))\n    g = Graph(axiom = axiom)\n    function qfun(n)\n        np = parent(n, nsteps = 2)\n        !ismissing(np) && data(np).val == 2\n    end\n    Q1 = Query(A1, query = qfun)\n    R1 = apply(g, Q1)\n    Q2 = Query(B1, query = qfun)\n    R2 = apply(g, Q2)\n    (R1,R2)\nend\nsource\n# VPL.Core.ancestor — Method.\nancestor(c::Context; condition = x -> true, maxlevel::Int = typemax(Int))\nReturns the first ancestor of a node that matches the condition. Intended to be used within a rule or query.\nDetails\nIf hasAncestor() returns false for the same node and condition, ancestor() will return missing, otherwise it returns the Context associated to the matching node\nReturn\nReturn a Context object or missing.\nExamples\nlet\n    struct A1 <: Node val::Int end\n    struct B1 <: Node val::Int end\n    axiom = A1(1) + (B1(1) + A1(3), B1(4))\n    g = Graph(axiom = axiom)\n    function qfun(n)\n        na = ancestor(n, condition = x -> (data(x).val == 1))\n        if !ismissing(na)\n            data(na) isa B1\n        else\n            false\n        end\n    end\n    Q1 = Query(A1, query = qfun)\n    R1 = apply(g, Q1)\n    Q2 = Query(B1, query = qfun)\n    R2 = apply(g, Q2)\n    (R1,R2)\nend\nsource\n# VPL.Core.hasChildren — Method.\nhasChildren(c::Context)\nCheck if a node has at least one child and return true or false. Intended to be used within a rule or query.\nsource\n# VPL.Core.isLeaf — Method.\nisLeaf(c::Context)\nCheck if a node is a leaf in the graph (i.e., has no children) and return true or false. Intended to be used within a rule or query.\nsource\n# VPL.Core.hasDescendent — Method.\nhasDescendent(c::Context; condition = x -> true, maxlevel::Int = typemax(Int))\nCheck if a node has a descendent that matches the optional condition. Intended to be used within a rule or query.\nArguments\n\nc::Context: Context associated to a node in a dynamic graph.\ncondition: An user-defined function that takes a Context object as input\n\nand returns true or false. It is assigned by the user by keyword.\n\nmaxlevel::Int: Maximum number of steps that the algorithm may take when\n\ntraversing the graph.\nDetails\nThis function traverses the graph from the node associated to c towards the leaves of the graph until a node is found for which condition returns true. If no node meets the condition, then it will return false. The defaults values for this function are such that the algorithm always returns true after one step (unless it is applied to a leaf node) in which case it is equivalent to calling hasChildren on the node.\nThe number of levels that the algorithm is allowed to traverse is capped by maxlevel (mostly to avoid excessive computation, though the user may want to specify a meaningful limit based on the topology of the graphs being used).\nThe function condition should take an object of type Context as input and return true or false.\nReturn\nReturn a tuple with two values a Bool and an Int, the boolean indicating whether the node has an ancestor meeting the condition, the integer indicating the number of levels in the graph separating the node an its ancestor.\nExamples\nlet\n    struct A1 <: Node val::Int end\n    struct B1 <: Node val::Int end\n    axiom = A1(2) + (B1(1) + A1(3), B1(4))\n    g = Graph(axiom = axiom)\n    function qfun(n)\n        hasDescendent(n, condition = x -> data(x).val == 1)[1]\n    end\n    Q1 = Query(A1, query = qfun)\n    R1 = apply(g, Q1)\n    Q2 = Query(B1, query = qfun)\n    R2 = apply(g, Q2)\n    (R1,R2)\nend\nsource\n# VPL.Core.children — Method.\nchildren(c::Context)\nReturns all the children of a node as Context objects.\nsource\n# VPL.Core.descendent — Method.\ndescendent(c::Context; condition = x -> true, maxlevel::Int = typemax(Int))\nReturns the first descendent of a node that matches the condition. Intended to be used within a rule or query.\nDetails\nIf hasDescendent() returns false for the same node and condition, descendent() will return missing, otherwise it returns the Context associated to the matching node.\nReturn\nReturn a Context object or missing.\nExamples\nlet\n    struct A1 <: Node val::Int end\n    struct B1 <: Node val::Int end\n    axiom = A1(1) + (B1(1) + A1(3), B1(4))\n    g = Graph(axiom = axiom)\n    function qfun(n)\n        na = descendent(n, condition = x -> (data(x).val == 1))\n        if !ismissing(na)\n            data(na) isa B1\n        else\n            false\n        end\n    end\n    Q1 = Query(A1, query = qfun)\n    R1 = apply(g, Q1)\n    Q2 = Query(B1, query = qfun)\n    R2 = apply(g, Q2)\n    (R1,R2)\nend\nsource"
  },
  {
    "objectID": "api/Core.html#graph-visualization",
    "href": "api/Core.html#graph-visualization",
    "title": "Virtual Plant Laboratory",
    "section": "Graph visualization",
    "text": "Graph visualization\n# VPL.Core.draw — Method.\ndraw(g::Graph; force = false, backend = \"native\", inline = false, \n     resolution = (1920, 1080), nlabels_textsize = 15, arrow_size = 15, \n     node_size = 5)\nVisualize a graph as network diagram.\nArguments\nAll arguments are assigned by keywords except the graph g.\n\ng::Graph: The graph to be visualized.\nforce = false: Force the creation of a new window to store the network\n\ndiagram.\n\nbackend = \"native\": The graphics backend to render the network diagram. It\n\ncan have the values \"native\", \"web\" and \"vector\". See VPL documentation for details.\n\ninline = false: Currently this argument does not do anything (will change in\n\nfuture versions of VPL).\n\nresolution = (1920, 1080): The resolution of the image to be rendered, in\n\npixels (online relevant for native and web backends). Default resolution is HD.\n\nnlabels_textsize = 15: Customize the size of the labels in the diagram.\narrow_size = 15: Customize the size of the arrows representing edges in the\n\ndiagram.\n\nnode_size = 5: Customize the size of the nodes in the diagram.\n\nDetails\nBy default, nodes are labelled with the type of data stored and their unique ID. See function node_label() to customize the label for different types of data.\nSee export_graph() to export the network diagram as a raster or vector image (depending on the backend). The function calculate_resolution() can be useful to ensure a particular dpi of the exported image (assuming some physical size).\nThe graphics backend will interact with the environment where the Julia code is being executed (i.e., terminal, IDE such as VS Code, interactive notebook such as Jupyter or Pluto). These interactions are all controlled by the graphics package Makie that VPL relies on. Some details on the expected behavior specific to draw() can be found in the general VPL documentation as www.virtualplantlab.com\nReturn\nThis function returns a Makie Figure object, while producing the visualization as a side effect.\nExamples\nlet\n    struct A1 <: Node val::Int end\n    struct B1 <: Node val::Int end\n    axiom = A1(1) + (B1(1) + A1(3), B1(4))\n    g = Graph(axiom = axiom)\n    draw(g)\nend\nsource\n# VPL.Core.draw — Method.\ndraw(g::StaticGraph; force = false, backend = \"native\", inline = false, \n     resolution = (1920, 1080), nlabels_textsize = 15, arrow_size = 15, \n     node_size = 5)\nEquivalent to the method draw(g::Graph; kwargs...) but to visualize static graphs (e.g., the axiom of a graph).\nsource\n# VPL.Core.node_label — Method.\nnode_label(n::Node, id)\nFunction to construct a label for a node to be used by draw() when visualizing. The user can specialize this method for user-defined data types to customize the labels. By default, the type of data stored in the node and the unique ID of the node are used as labels.\nsource\n# VPL.Core.export_graph — Method.\nexport_graph(f; filename, kwargs...)\nSave a network diagram generated by draw() to an external file.\nArguments\n\nf: Object of type Figure return by draw().\nfilename: Name of the file where the diagram will be stored. The extension\n\nwill be used to determined the format of the image (see example below).\nDetails\nInternally, export_graph() calls the save() method from the ImageIO package and its dependencies. Any keyword argument supported by the relevant save method will be passed along by export_graph(). For example, exporting diagrams as PNG allows defining the compression level as compression_level (see PNGFiles package for details).\nReturn\nThe function returns nothing but, if successful, it will generate a new file containing the network diagram in the appropiate format.\nExamples\nExamples\nlet\n    struct A1 <: Node val::Int end\n    struct B1 <: Node val::Int end\n    axiom = A1(1) + (B1(1) + A1(3), B1(4))\n    g = Graph(axiom = axiom)\n    f = draw(g);\n    export_graph(f, filename = \"test.png\")\nend\nsource\n# VPL.Core.calculate_resolution — Method.\ncalculate_resolution(;width = 1024/300*2.54, height = 768/300*2.54, \n                      format = \"raster\", dpi = 300)\nCalculate the resolution required to achieve a specific width and height (in cm) of the exported image, with a particular dpi (for raster formats).\nsource"
  },
  {
    "objectID": "api/Geometry.html#scenes",
    "href": "api/Geometry.html#scenes",
    "title": "Virtual Plant Laboratory",
    "section": "Scenes",
    "text": "Scenes\n# VPL.Geom.Scene — Type.\nScene(graph, Float64)\nCreate a 3D scene from a Graph object (g). By default, double floating precision will be used (Float64) but it is possible to generate a version with a different precision by specifying the corresponding type as in Scene(g, Float32). The Scene object contains a mesh of triangles as well as colors and materials associated to each primitive.\nsource\nScene(scenes)\nMerge multiple Scene objects into one.\nsource\n# VPL.add! — Function.\nadd!(scene; mesh, color = nothing, material = nothing)\nManually add a 3D mesh to an existing Scene object (scene) with optional colors and materials\nsource\n# VPL.Geom.colors — Method.\ncolors(scene::Scene)\nExtract the vector of Colorant objects stored inside a scene (used for rendering)\nsource\n# VPL.Geom.mesh — Method.\nmesh(scene::Scene)\nExtract the triangular mesh stored inside a scene (used for ray tracing & rendering)\nsource\n# VPL.Geom.materials — Method.\nmaterials(scene::Scene)\nExtract the vector of Material objects stored inside a scene (used for ray tracing)\nsource"
  },
  {
    "objectID": "api/Geometry.html#turtle-geometry",
    "href": "api/Geometry.html#turtle-geometry",
    "title": "Virtual Plant Laboratory",
    "section": "Turtle geometry",
    "text": "Turtle geometry\n# VPL.Geom.Turtle — Method.\nTurtle(Float64, message)\nCreate a meshing turtle that can convert a Graph into a 3D mesh using turtle operators, geometry primitives and methods of feed!(). By default, the meshing turtle will generate geometry primitives with double floating precision (Float64) but it is possible to generate a version with lower precision as in Turtle(Float32). The argument message is any user-defined object.\nsource\n# VPL.Geom.head — Method.\nhead(turtle)\nExtract the direction vector (a Vec object) of the head of the turtle.\nsource\n# VPL.Geom.up — Method.\nup(turtle)\nExtract the direction vector (a Vec object) of the back of the turtle.\nsource\n# VPL.Geom.arm — Method.\narm(turtle)\nExtract the direction vector (a Vec object) of the arm of the turtle.\nsource\n# VPL.Geom.pos — Method.\npos(turtle)\nExtract the current position of the turtle (a Vec object).\nsource\n# VPL.Geom.geoms — Method.\ngeoms(turtle)\nExtract the 3D mesh generated by the turtle (a Mesh object).\nsource\n# VPL.Geom.colors — Method.\ncolors(turtle)\nExtract the color objects associated to each geometry primitive that was fed to the turtle.\nsource\n# VPL.Geom.faces — Method.\ngeoms(turtle)\nExtract the faces of the 3D mesh generated by the turtle.\nsource\n# VPL.Geom.materials — Method.\nmaterials(turtle)\nExtract the material objects associated to each geometry primitive that was fed to the turtle.\nsource\n# VPL.Geom.feed! — Function.\nfeed!(turtle::Turtle; mesh::Mesh, color::Colorant = nothing, mat::Material = nothing)\nGeneral purpose method to feed a mesh to a turtle together with color and material. Note that all primitives provided by VPL are implemented as meshes, but this is a generic method for meshes that are constructed directly by the user or imported from external software.\nsource\nfeed!(turtle::Turtle, node::Node, vars = nothing)\nDefault method for feed!() that does not do anything. This allows the user to include nodes in a graph without an associated geometry.\nsource\nfeed!(turtle::Turtle, g::Graph)\nProcess a Graph object with a turtle and generate the corresponding 3D mesh from executing the different feed!() methods associated to the nodes in the graph.\nsource\nfeed!(turtle::Turtle, collection::AbstractArray)\nfeed!(turtle::Turtle, collection::Tuple)\nFeed a turtle an array or tuple of objects (collection) with existing feed!() methods.\nsource\n# VPL.Geom.T — Type.\nT(to::Vec)\nNode that translates a turtle to the new position to (a Vec object).\nsource\n# VPL.Geom.t! — Method.\nt!(turtle; to = O())\nTranslate a turtle to the new position to (a Vec object).\nsource\n# VPL.Geom.OR — Type.\nOR(head::Vec, up::Vec, arm::Vec)\nNode that orients a turtle to a new direction by re-defining the local reference system.\nsource\n# VPL.Geom.or! — Method.\nor!(turtle; head = Z(), up = X(), arm = Y())\nOrient a turtle to a new direction by re-defining the local reference system. The arguments head, up and arm should be of type Vec.\nsource\n# VPL.Geom.SET — Type.\nSET(to, head, up, arm)\nNode that sets the position and orientation of a turtle.\nsource\n# VPL.Geom.set! — Method.\nset!(turtle; to = O(), head = Z(), up = X(), arm = Y())\nSet position and orientation of a turtle. The arguments to, head, up and arm should be of type Vec and be passed as keyword arguments.\nsource\n# VPL.Geom.RU — Type.\nRU(angle)\nNode that rotates a turtle around up axis. Angle must be in hexadecimal degrees and the rotation is clockwise.\nsource\n# VPL.Geom.ru! — Method.\nru!(turtle, angle)\nRotates a turtle around up axis. Angle must be in hexadecimal degrees and the rotation is clockwise.\nsource\n# VPL.Geom.RA — Type.\nRA(angle)\nNode that rotates a turtle around arm axis. Angle must be in hexadecimal degrees and the rotation is clockwise.\nsource\n# VPL.Geom.ra! — Method.\nra!(turtle, angle)\nRotates a turtle around arm axis. Angle must be in hexadecimal degrees and the rotation is clockwise.\nsource\n# VPL.Geom.RH — Type.\nRH(angle)\nNode that rotates a turtle around head axis. Angle must be in hexadecimal degrees and the rotation is clockwise.\nsource\n# VPL.Geom.rh! — Method.\nrh!(turtle, angle)\nRotate turtle around head axis. Angle must be in hexadecimal degrees and the rotation is clockwise.\nsource\n# VPL.Geom.F — Type.\nF(dist)\nMoves a turtle forward a given distance.\nsource\n# VPL.Geom.f! — Method.\nf!(turtle, dist)\nMove turtle forward a given distance.\nsource\n# VPL.Geom.RV — Type.\nRV(strength)\nRotates the turtle towards the Z axis. See documentation for rv! for details.\nsource\n# VPL.Geom.rv! — Method.\nrv!(turtle, strength)\nRotates the turtle towards the Z axis. The angle of rotation is proportional to the cosine of the zenith angle of the turtle (i.e., angle between its head and the vertical axis) with the absolute value of strength being the proportion between the two. strength should vary between -1 and 1. If strength is negative, the turtle rotates downwards (i.e., towards negative values of Z axis), otherwise upwards.\nsource"
  },
  {
    "objectID": "api/Geometry.html#d-vectors",
    "href": "api/Geometry.html#d-vectors",
    "title": "Virtual Plant Laboratory",
    "section": "3D vectors",
    "text": "3D vectors\n# VPL.Geom.Vec — Type.\nVec(x, y, z)\n3D vector or point with coordinates x, y and z.\nsource\n# VPL.Geom.O — Method.\nO()\nReturns the origin of the 3D coordinate system as a Vec object. By default, the coordinates will be in double floating precision (Float64) but it is possible to generate a version with lower floating precision as in O(Float32).\nsource\n# VPL.Geom.X — Method.\nX()\nReturns an unit vector in the direction of the X axis as a Vec object. By default, the coordinates will be in double floating precision (Float64) but it is possible to generate a version with lower floating precision as in X(Float32).\nsource\n# VPL.Geom.Y — Method.\nY()\nReturns an unit vector in the direction of the Y axis as a Vec object. By default, the coordinates will be in double floating precision (Float64) but it is possible to generate a version with lower floating precision as in Y(Float32).\nsource\n# VPL.Geom.Z — Method.\nZ()\nReturns an unit vector in the direction of the Z axis as a Vec object. By default, the coordinates will be in double floating precision (Float64) but it is possible to generate a version with lower floating precision as in Z(Float32).\nsource\n# VPL.Geom.X — Method.\nX(s)\nReturns scaled vector in the direction of the X axis with length s as a Vec object using the same floating point precision as s.\nsource\n# VPL.Geom.Y — Method.\nY(s)\nReturns scaled vector in the direction of the Y axis with length s as a Vec object using the same floating point precision as s.\nsource\n# VPL.Geom.Z — Method.\nZ(s)\nReturns scaled vector in the direction of the Z axis with length s as a Vec object using the same floating point precision as s.\nsource"
  },
  {
    "objectID": "api/Geometry.html#geometry-primitives",
    "href": "api/Geometry.html#geometry-primitives",
    "title": "Virtual Plant Laboratory",
    "section": "Geometry primitives",
    "text": "Geometry primitives\n\n\n\nTriangle\n# VPL.Geom.Triangle — Method.\nTriangle(;length = 1.0, width = 1.0\nCreate a triangle with dimensions given by length and width, standard location and orientation.\nsource\n# VPL.Geom.Triangle! — Method.\nTriangle!(turtle; length = 1.0, width = 1.0, move = false,\n          material = nothing, color = nothing)\nGenerate a triangle in front of the turtle and feed it to a turtle.\nArguments\n\nturtle: The turtle that we feed the triangle to.\nlength: Length of the triangle.\nwidth: Width of the triangle.\nmove: Whether to move the turtle forward or not (true or false).\nmaterial: The material object for the ray tracer (optional).\ncolor: The color of the ellipse for rendering (optional).\n\nDetails\nA triangle mesh will be generated representing the triangle. The triangle will be generated in front of the turtle, on the plane defined by the arm and head axes of the turtle. The argument length refers to the axis of the triangle aligned with the head axis of the turtle, whereas width refers to the orthogonal axis.\nWhen move = true, the turtle will be moved forward by a distance equal to length.\nThe material object must inherit from Material (see ray tracing documentation for detail) and the color can be any type that inherits from Colorant (from ColorTypes.jl).\nReturn\nReturns nothing but modifies the turtle as a side effect.\nsource\n\n\n\n\nRectangle\n# VPL.Geom.Rectangle — Method.\nRectangle(;length = 1.0, width = 1.0)\nCreate a rectangle with dimensions given by length and width, standard location and orientation.\nsource\n# VPL.Geom.Rectangle! — Method.\nRectangle!(turtle; length = 1.0, width = 1.0, move = false,\n           material = nothing, color = nothing)\nGenerate a rectangle in front of the turtle and feed it to a turtle.\nArguments\n\nturtle: The turtle that we feed the rectangle to.\nlength: Length of the rectangle.\nwidth: Width of the rectangle.\nmove: Whether to move the turtle forward or not (true or false).\nmaterial: The material object for the ray tracer (optional).\ncolor: The color of the ellipse for rendering (optional).\n\nDetails\nA triangle mesh will be generated representing the rectangle. The rectangle will be generated in front of the turtle, on the plane defined by the arm and head axes of the turtle. The argument length refers to the axis of the rectangle aligned with the head axis of the turtle, whereas width refers to the orthogonal axis.\nWhen move = true, the turtle will be moved forward by a distance equal to length.\nThe material object must inherit from Material (see ray tracing documentation for detail) and the color can be any type that inherits from Colorant (from ColorTypes.jl).\nReturn\nReturns nothing but modifies the turtle as a side effect.\nsource\n\n\n\n\nTrapezoid\n# VPL.Geom.Trapezoid — Method.\nTrapezoid(;length = 1.0, width = 1.0, ratio = 1.0)\nCreate a trapezoid with dimensions given by length and the larger width and the ratio between the smaller and larger widths. The trapezoid is generted at the standard location and orientation.\nsource\n# VPL.Geom.Trapezoid! — Method.\nTrapezoid!(turtle; length = 1.0, width = 1.0, ratio = 1.0, move = false,\nmaterial = nothing, color = nothing)\nGenerate a trapezoid in front of the turtle and feed it to a turtle.\nArguments\n\nturtle: The turtle that we feed the trapezoid to.\nlength: Length of the trapezoid.\nwidth: Width of the base of the trapezoid.\nratio: Ratio between the width of the top and base of the trapezoid.\nmove: Whether to move the turtle forward or not (true or false).\nmaterial: The material object for the ray tracer (optional).\ncolor: The color of the ellipse for rendering (optional).\n\nDetails\nA triangle mesh will be generated representing the trapezoid. The trapezoid will be generated in front of the turtle, on the plane defined by the arm and head axes of the turtle. The argument length refers to the axis of the trapezoid aligned with the head axis of the turtle, whereas width refers to the orthogonal axis.\nWhen move = true, the turtle will be moved forward by a distance equal to length.\nThe material object must inherit from Material (see ray tracing documentation for detail) and the color can be any type that inherits from Colorant (from ColorTypes.jl).\nReturn\nReturns nothing but modifies the turtle as a side effect.\nsource\n\n\n\n\nEllipse\n# VPL.Geom.Ellipse — Method.\nEllipse(;length = 1.0, width = 1.0, n = 20)\nCreate an ellipse with dimensions given by length and width, discretized into n triangles (must be even) and standard location and orientation.\nsource\n# VPL.Geom.Ellipse! — Method.\nEllipse!(turtle; length = 1.0, width = 1.0, n = 20, move = false,\n         material = nothing, color = nothing)\nGenerate an ellipse in front of a turtle and feed it to a turtle.\nArguments\n\nturtle: The turtle that we feed the ellipse to.\nlength: Length of the ellipse.\nwidth: Width of the ellipse.\nn: Number of triangles of the mesh approximating the ellipse (an integer).\nmove: Whether to move the turtle forward or not (true or false).\nmaterial: The material object for the ray tracer (optional).\ncolor: The color of the ellipse for rendering (optional).\n\nDetails\nA triangle mesh will be generated with n triangles that approximates an ellipse. The ellipse will be generated in front of the turtle, on the plane defined by the arm and head axes of the turtle. The argument length refers to the axis of the ellipse aligned with the head axis of the turtle, whereas width refers to the orthogonal axis.\nWhen move = true, the turtle will be moved forward by a distance equal to length.\nThe material object must inherit from Material (see ray tracing documentation for detail) and the color can be any type that inherits from Colorant (from ColorTypes.jl).\nReturn\nReturns nothing but modifies the turtle as a side effect.\nsource\n\n\n\n\nHollow cylinder\n# VPL.Geom.HollowCylinder — Method.\nHollowCylinder(;length = 1.0, width = 1.0, height = 1.0, n = 40)\nCreate a hollow cylinder with dimensions given by length, width and height, discretized into n triangles (must be even) and standard location and orientation.\nsource\n# VPL.Geom.HollowCylinder! — Method.\nHollowCylinder!(turtle; length = 1.0, width = 1.0, height = 1.0, n = 40, move = false,\nmaterial = nothing, color = nothing)\nGenerate a hollow cylinder in front of the turtle and feed it to a turtle.\nArguments\n\nturtle: The turtle that we feed the hollow cylinder to.\nlength: Length of the ellipse at the base of the hollow cylinder.\nwidth: Width of the ellipse at the base of the hollow cylinder.\nheight: Height of the hollow cylinder.\nn: Number of triangles in the mesh (must be even).\nmove: Whether to move the turtle forward or not (true or false).\nmaterial: The material object for the ray tracer (optional).\ncolor: The color of the ellipse for rendering (optional).\n\nDetails\nA mesh will be generated with n triangles that approximate the hollow cylinder. The cylinder will be generated in front of the turtle, with the base on the plane defined by the arm and up axes of the turtle, centered at the head axis. The length argument refers to the up axis, whereas width refers to the arm axis and height is associated to the head axis.\nWhen move = true, the turtle will be moved forward by a distance equal to height.\nThe material object must inherit from Material (see ray tracing documentation for detail) and the color can be any type that inherits from Colorant (from ColorTypes.jl).\nReturn\nReturns nothing but modifies the turtle as a side effect.\nsource\n# VPL.Geom.SolidCylinder — Method.\nSolidCylinder(;length = 1.0, width = 1.0, height = 1.0, n = 80)\nCreate a solid cylinder with dimensions given by length, width and height, discretized into n triangles (must be even) and standard location and orientation.\nsource\n# VPL.Geom.SolidCylinder! — Method.\nSolidCylinder!(turtle; length = 1.0, width = 1.0, height = 1.0, n = 80, move = false,\nmaterial = nothing, color = nothing)\nGenerate a solid cylinder in front of the turtle and feed it to a turtle.\nArguments\n\nturtle: The turtle that we feed the solid cylinder to.\nlength: Length of the ellipse at the base of the solid cylinder.\nwidth: Width of the ellipse at the base of the solid cylinder.\nheight: Height of the solid cylinder.\nn: Number of triangles in the mesh (must be even).\nmove: Whether to move the turtle forward or not (true or false).\nmaterial: The material object for the ray tracer (optional).\ncolor: The color of the ellipse for rendering (optional).\n\nDetails\nA mesh will be generated with n triangles that approximate the solid cylinder. The cylinder will be generated in front of the turtle, with the base on the plane defined by the arm and up axes of the turtle, centered at the head axis. The length argument refers to the up axis, whereas width refers to the arm axis and height is associated to the head axis.\nWhen move = true, the turtle will be moved forward by a distance equal to height.\nThe material object must inherit from Material (see ray tracing documentation for detail) and the color can be any type that inherits from Colorant (from ColorTypes.jl).\nReturn\nReturns nothing but modifies the turtle as a side effect.\nsource\n\n\n\n\nHollow cone\n# VPL.Geom.HollowCone — Method.\nHollowCone(;length = 1.0, width = 1.0, height = 1.0, n = 20)\nCreate a hollow cone with dimensions given by length, width and height, discretized into n triangles (must be even) and standard location and orientation.\nsource\n# VPL.Geom.HollowCone! — Method.\nHollowCone!(turtle; length = 1.0, width = 1.0, height = 1.0, n = 20, move = false,\nmaterial = nothing, color = nothing)\nGenerate a hollow cone in front of the turtle and feed it to a turtle.\nArguments\n\nturtle: The turtle that we feed the hollow cone to.\nlength: Length of the ellipse at the base of the hollow cone.\nwidth: Width of the ellipse at the base of the hollow cone.\nheight: Height of the hollow cone.\nn: Number of triangles in the mesh.\nmove: Whether to move the turtle forward or not (true or false).\nmaterial: The material object for the ray tracer (optional).\ncolor: The color of the ellipse for rendering (optional).\n\nDetails\nA mesh will be generated with n triangles that approximate the hollow cone. The cone will be generated in front of the turtle, with the base on the plane defined by the arm and up axes of the turtle, centered at the head axis. The length argument refers to the up axis, whereas width refers to the arm axis and height is associated to the head axis.\nWhen move = true, the turtle will be moved forward by a distance equal to height.\nThe material object must inherit from Material (see ray tracing documentation for detail) and the color can be any type that inherits from Colorant (from ColorTypes.jl).\nReturn\nReturns nothing but modifies the turtle as a side effect.\nsource\n# VPL.Geom.SolidCone — Method.\nSolidCone(;length = 1.0, width = 1.0, height = 1.0, n = 40)\nCreate a solid cone with dimensions given by length, width and height, discretized into n triangles (must be even) and standard location and orientation.\nsource\n# VPL.Geom.SolidCone! — Method.\nSolidCone!(turtle; length = 1.0, width = 1.0, height = 1.0, n = 40, move = false,\nmaterial = nothing, color = nothing)\nGenerate a solid frustum in front of the turtle and feed it to a turtle.\nArguments\n\nturtle: The turtle that we feed the solid cone to.\nlength: Length of the ellipse at the base of the solid cone.\nwidth: Width of the ellipse at the base of the solid cone.\nheight: Height of the solid cone.\nn: Number of triangles in the mesh (must be even).\nmove: Whether to move the turtle forward or not (true or false).\nmaterial: The material object for the ray tracer (optional).\ncolor: The color of the ellipse for rendering (optional).\n\nDetails\nA mesh will be generated with n triangles that approximate the solid cone. The cone will be generated in front of the turtle, with the base on the plane defined by the arm and up axes of the turtle, centered at the head axis. The length argument refers to the up axis, whereas width refers to the arm axis and height is associated to the head axis.\nWhen move = true, the turtle will be moved forward by a distance equal to height.\nThe material object must inherit from Material (see ray tracing documentation for detail) and the color can be any type that inherits from Colorant (from ColorTypes.jl).\nReturn\nReturns nothing but modifies the turtle as a side effect.\nsource\n\n\n\n\nCube\n# VPL.Geom.SolidCube — Method.\nSolidCube(;length = 1.0, width = 1.0, height = 1.0)\nCreate a solid cube with dimensions given by length, width and height, standard location and orientation.\nsource\n# VPL.Geom.SolidCube! — Method.\nSolidCube!(turtle; length = 1.0, width = 1.0, height = 1.0, move = false,\nmaterial = nothing, color = nothing)\nGenerate a solid cube in front of the turtle and feed it to a turtle.\nArguments\n\nturtle: The turtle that we feed the solid cube to.\nlength: Length of the rectangle at the base of the solid cube.\nwidth: Width of the rectangle at the base of the solid cube.\nheight: Height of the solid cube.\nmove: Whether to move the turtle forward or not (true or false).\nmaterial: The material object for the ray tracer (optional).\ncolor: The color of the ellipse for rendering (optional).\n\nDetails\nA mesh will be generated of a solid cube. The cube will be generated in front of the turtle, with the base on the plane defined by the arm and up axes of the turtle, centered at the head axis. The length argument refers to the up axis, whereas width refers to the arm axis and height is associated to the head axis.\nWhen move = true, the turtle will be moved forward by a distance equal to height.\nThe material object must inherit from Material (see ray tracing documentation for detail) and the color can be any type that inherits from Colorant (from ColorTypes.jl).\nReturn\nReturns nothing but modifies the turtle as a side effect.\nsource\n# VPL.Geom.HollowCube — Method.\nHollowCube(;length = 1.0, width = 1.0, height = 1.0)\nCreate a hollow cube with dimensions given by length, width and `height, standard location and orientation.\nsource\n# VPL.Geom.HollowCube! — Method.\nHollowCube!(turtle; length = 1.0, width = 1.0, height = 1.0, move = false,\nmaterial = nothing, color = nothing)\nGenerate a hollow cube in front of the turtle and feed it to a turtle.\nArguments\n\nturtle: The turtle that we feed the hollow cube to.\nlength: Length of the rectangle at the base of the hollow cube.\nwidth: Width of the rectangle at the base of the hollow cube.\nheight: Height of the hollow cube.\nmove: Whether to move the turtle forward or not (true or false).\nmaterial: The material object for the ray tracer (optional).\ncolor: The color of the ellipse for rendering (optional).\n\nDetails\nA mesh will be generated of a hollow cube. The cube will be generated in front of the turtle, with the base on the plane defined by the arm and up axes of the turtle, centered at the head axis. The length argument refers to the up axis, whereas width refers to the arm axis and height is associated to the head axis.\nWhen move = true, the turtle will be moved forward by a distance equal to height.\nThe material object must inherit from Material (see ray tracing documentation for detail) and the color can be any type that inherits from Colorant (from ColorTypes.jl).\nReturn\nReturns nothing but modifies the turtle as a side effect.\nsource\n\n\n\n\nSolid frustum\n# VPL.Geom.SolidFrustum — Method.\nSolidFrustum(;length = 1.0, width = 1.0, height = 1.0, n = 40)\nCreate a solid frustum with dimensions given by length, width and height, discretized into n triangles and standard location and orientation.\nsource\n# VPL.Geom.SolidFrustum! — Method.\nSolidFrustum!(turtle; length = 1.0, width = 1.0, height = 1.0, n = 80, move = false,\nmaterial = nothing, color = nothing)\nGenerate a solid frustum in front of the turtle and feed it to a turtle.\nArguments\n\nturtle: The turtle that we feed the solid frustum to.\nlength: Length of the ellipse at the base of the solid frustum.\nwidth: Width of the ellipse at the base of the solid frustum.\nheight: Height of the solid frustum.\nn: Number of triangles in the mesh (must be even).\nmove: Whether to move the turtle forward or not (true or false).\nmaterial: The material object for the ray tracer (optional).\ncolor: The color of the ellipse for rendering (optional).\n\nDetails\nA mesh will be generated with n triangles that approximate the solid frustum. The frustum will be generated in front of the turtle, with the base on the plane defined by the arm and up axes of the turtle, centered at the head axis. The length argument refers to the up axis, whereas width refers to the arm axis and height is associated to the head axis.\nWhen move = true, the turtle will be moved forward by a distance equal to height.\nThe material object must inherit from Material (see ray tracing documentation for detail) and the color can be any type that inherits from Colorant (from ColorTypes.jl).\nReturn\nReturns nothing but modifies the turtle as a side effect.\nsource\n# VPL.Geom.HollowFrustum — Method.\nHollowFrustum(;length = 1.0, width = 1.0, height = 1.0, n = 40)\nCreate a hollow frustum with dimensions given by length, width and height, discretized into n triangles (must be even) and standard location and orientation.\nsource\n# VPL.Geom.HollowFrustum! — Method.\nHollowFrustum!(turtle; length = 1.0, width = 1.0, height = 1.0, n = 40, move = false,\nmaterial = nothing, color = nothing)\nGenerate a hollow frustum in front of the turtle and feed it to a turtle.\nArguments\n\nturtle: The turtle that we feed the hollow frustum to.\nlength: Length of the ellipse at the base of the hollow frustum.\nwidth: Width of the ellipse at the base of the hollow frustum.\nheight: Height of the hollow frustum.\nn: Number of triangles in the mesh (must be even).\nmove: Whether to move the turtle forward or not (true or false).\nmaterial: The material object for the ray tracer (optional).\ncolor: The color of the ellipse for rendering (optional).\n\nDetails\nA mesh will be generated with n triangles that approximate the hollow frustum. The frustum will be generated in front of the turtle, with the base on the plane defined by the arm and up axes of the turtle, centered at the head axis. The length argument refers to the up axis, whereas width refers to the arm axis and height is associated to the head axis.\nWhen move = true, the turtle will be moved forward by a distance equal to height.\nThe material object must inherit from Material (see ray tracing documentation for detail) and the color can be any type that inherits from Colorant (from ColorTypes.jl).\nReturn\nReturns nothing but modifies the turtle as a side effect.\nsource\n\n\n\n\nBounding box\n# VPL.Geom.BBox — Method.\nBBox(m::Mesh)\nBuild a tight axis-aligned bounding box around a Mesh object.\nsource\n# VPL.Geom.BBox — Method.\nBBox(pmin::Vec, pmax::Vec)\nBuild an axis-aligned bounding box given the vector of minimum (pmin) and maximum (pmax) coordinates.\nsource\n\n\n\n\nGeneric mesh\n# VPL.Geom.Mesh! — Method.\nMesh!(turtle, m::Mesh; scale = Vec(1.0, 1.0, 1.0), move = false,\nmaterial = nothing, color = nothing)\nFeed a pre-existing mesh to a turtle after scaling.\nArguments\n\nturtle: The turtle that we feed the mesh to.\nm: The pre-existing unscaled mesh in standard position and orientation.\nscale: Vector with scaling factors for the x, y and z axes.\nmove: Whether to move the turtle forward or not (true or false).\nmaterial: The material object for the ray tracer (optional).\ncolor: The color of the ellipse for rendering (optional).\n\nDetails\nA pre-existing mesh will be scaled (acccording to scale), rotate so that it is oriented in the same direction as the turtle and translated so that the mesh is generated in front of the turtle. A deep copy of the original mesh is made prior to any transformation.\nWhen move = true, the turtle will be moved forward by a distance equal to height.\nThe material object must inherit from Material (see ray tracing documentation for detail) and the color can be any type that inherits from Colorant (from ColorTypes.jl).\nReturn\nReturns nothing but modifies the turtle as a side effect.\nsource"
  },
  {
    "objectID": "api/Geometry.html#rotations-scaling-and-translations",
    "href": "api/Geometry.html#rotations-scaling-and-translations",
    "title": "Virtual Plant Laboratory",
    "section": "Rotations, scaling and translations",
    "text": "Rotations, scaling and translations\n# VPL.Geom.scale! — Method.\nscale!(m::Mesh, Vec)\nScale a mesh m along the three axes provided by vec\nsource\n# VPL.Geom.rotatex! — Method.\nrotatex!(m::Mesh, θ)\nRotate a mesh m around the x axis by θ rad.\nsource\n# VPL.Geom.rotatey! — Method.\nrotatey!(m::Mesh, θ)\nRotate a mesh m around the y axis by θ rad.\nsource\n# VPL.Geom.rotatez! — Method.\nrotatez!(m::Mesh, θ)\nRotate a mesh m around the z axis by θ rad.\nsource\n# VPL.Geom.rotate! — Method.\nrotate!(m::Mesh; x::Vec, y::Vec, z::Vec)\nRotate a mesh m to a new coordinate system given by x, y and z\nsource\n# VPL.Geom.translate! — Method.\ntranslate!(m::Mesh, v::Vec)\nTranslate the mesh m by vector v\nsource"
  },
  {
    "objectID": "api/Geometry.html#other-mesh-related-methods",
    "href": "api/Geometry.html#other-mesh-related-methods",
    "title": "Virtual Plant Laboratory",
    "section": "Other mesh-related methods",
    "text": "Other mesh-related methods\n# VPL.Geom.Mesh — Method.\nMesh()\nGenerate an empty triangular dense mesh that represents a primitive or 3D scene. By default a Mesh object will only accept coordinates in double floating precision (Float64) but a lower precision can be generated by specifying the corresponding data type as in Mesh(Float32).\nsource\n# VPL.Geom.Mesh — Method.\nMesh(nt, nv = nt*3)\nGenerate a triangular dense mesh with enough memory allocated to store nt triangles and nv vertices. The behaviour is equivalent to generating an empty mesh but may be computationally more efficient when appending a large number of primitives. If a lower floating precision is required, this may be specified as an optional third argument as in Mesh(10, 30, Float32).\nsource\n# VPL.Geom.ntriangles — Method.\nntriangles(mesh)\nExtract the number of triangles in a mesh.\nsource\n# VPL.Geom.nvertices — Method.\nnvertices(mesh)\nThe number of vertices in a mesh.\nsource\n# VPL.Geom.area — Method.\narea(m::Mesh)\nTotal surface area of a mesh (as the sum of areas of individual triangles).\nsource\n# VPL.Geom.areas — Method.\nareas(m::Mesh)\nA vector with the areas of the different triangles that form a mesh.\nsource\n# VPL.Geom.loadmesh — Method.\nloadmesh(filename)\nImport a mesh from a file given by filename. Supported formats include stl, ply, obj and msh. By default, this will generate a Mesh object that uses double floating-point precision. However, a lower precision can be specified by passing the relevant data type as in loadmesh(filename, Float32).\nsource\n# VPL.Geom.savemesh — Method.\nsavemesh(mesh; fileformat = STL_BINARY, filename)\nSave a mesh into an external file using a variety of formats.\nArguments\n\nmesh: Object of type Mesh.\nfileformat: Format to store the mesh. This is a keyword argument.\nfilename: Name of the file in which to store the mesh.\n\nDetails\nThe fileformat should take one of the following arguments: STL_BINARY, STL_ASCII, PLY_BINARY, PLY_ASCII or OBJ. Note that these names should not be quoted as strings.\nReturn\nThis function does not return anything, it is executed for its side effect.\nsource"
  },
  {
    "objectID": "api/RayTracer.html",
    "href": "api/RayTracer.html",
    "title": "Virtual Plant Laboratory",
    "section": "",
    "text": "Module RayTracing\n\n\n\n\nMeshes\n# VPL.RayTracing.Triangle — Method.\nTriangle(p1, p2, p3)\nCreate a ray tracing Triangle object given the three vertices p1, p2 and p3.\nsource\n# VPL.RayTracing.Triangle — Method.\nTriangle(mesh)\nCreate a vector of ray tracing Triangle objects from a Mesh object.\nsource\n# VPL.RayTracing.Triangle — Method.\nTriangle(mesh)\nCreate a vector of ray tracing Triangle objects from a Scene object.\nsource\n\n\n\n\nRayTracer\n# VPL.RayTracing.get_nw — Function.\nget_nw(s::Source)\nRetrieve the number of wavelengths that rays from a source will contain.\nsource\nget_nw(rt::RayTracer)\nRetrieve the number of wavelengths being simulated by the ray tracer. See VPL documentation for more details on the ray tracer.\nsource\n# VPL.RayTracing.RTSettings — Type.\nRTSettings(;parallel = false, pkill = 0.2, maxiter = 2, sampler = Random.Xoshiro(123456789),\n            nx = 3, ny = 3, nz = 0, dx = 0.0, dy = 0.0, dz = 0.0)\nSettings for the ray tracer: parallel indicates if the raytracer will run on a single core or make use of multiple cores in the machine based on Julia’s multithreading support. pkill is the probably that a ray is terminated by the Russian roulette after it has been scattered a maxiter number of times. sampler is the pseudo-random number generator to be used by the ray tracer. nx and ny are the number of times the scene will be clone by the grid cloner in each direction along the x and y axis (e.g., setting nx = 1 and ny = 1 will generate a grid of 3 x 3 clones of the original scene), whereas dx and dy will be distance at which each new clone will be generated (along the axis). nz is the number of times the scene will be cloned in the vertical direction. Unlike horizontal cloning, the vertical cloning is always done in the positive direction of z axis and the number of clones will be exactly nz. See VPL documentation for more details on the ray tracer.\nsource\n# VPL.RayTracing.accelerate — Function.\naccelerate(scene::Scene; settings = RTSettings(), acceleration = Naive, rule = nothing)\nCreate an AccScene object from a scene, settings and acceleration function (choose from Naive or BVH). The argument rule is only required for the accelerator BVH and it must be an object of type SAH or AvgSplit (it is ignored for the Naive accelerator). The AccScene object contains the acceleration structure and the grid cloner structure built on top of the original 3D meshes in scene. See VPL documentation for details.\nsource\n# VPL.RayTracing.RayTracer — Type.\nRayTracer(scene, materials, sources, settings)\nCreate a ray tracer object from an acceleration structure built around a 3D mesh, a grid cloner structure around the acceleration structure (scene), a vector of materials associated to the mesh (materials), a vector of sources of irradiance (sources) and settings. (as generated by RTSettings()). See VPL documentation for more details on the ray tracer.\nsource\n# VPL.RayTracing.trace! — Function.\ntrace!(rt)\nRun the ray tracing simulations. This function will overwrite the power component of any material object that is included in the scene. It returns the total number of rays being traced (primary and secondary). See VPL documentation for more details on the ray tracer.\nsource\n\n\n\n\nAcceleration structures\n# VPL.RayTracing.Naive — Type.\nNaive\nAllow to run the ray tracer without an acceleration structure. This should be assigned to the argument acceleration in the RayTracer function.\nsource\n# VPL.RayTracing.BVH — Type.\nBVH\nConstruct a Bounding Volume Hierarchy around the triangular meshes to accelerate the ray tracer. This should be assigned to the argument acceleration in the RayTracer function, in combination with a corresponding rule.\nsource\n# VPL.RayTracing.SAH — Type.\nSAH{K}(minN, maxL)\nRule to be used in RayTracer when acceleration = BVH. It will divide each node at the axis and location using the Surface Area Heuristics. To speed up the construction, only K cuts will be tested per axis. These cuts will correspond to the quantiles along each axis. The rule is parameterized by the minimum number of triangles in a leaf node (minN) and the maximum depth of the tree (maxL).\nsource\n# VPL.RayTracing.AvgSplit — Type.\nAvgSplit(minN, maxL)\nRule to be used in RayTracer when acceleration = BVH. It will divide each node along the longest axis through the mean coordinate value. The rule is parameterized by the minimum number of triangles in a leaf node (minN) and the maximum depth of the tree (maxL).\nsource\n\n\n\n\nSources\n# VPL.RayTracing.Source — Type.\nSource(geom, angle, power::Number, nrays)\nSource(geom, angle, power::Tuple, nrays)\nCreaten irradiance source given a source geometry, a source angle, the power per ray and the total number of rays to be generated from this source. When simulating more than one wavelength simultaneously, a tuple of power values should be given, of the same length as in the materials used in the scene. See VPL documentation for details on source geometries and source angles.\nsource\n# VPL.RayTracing.DirectionalSource — Function.\nDirectionalSource(box::AABB, θ, Φ, radiosity, nrays)\nDirectionalSource(scene::Scene, θ, Φ, radiosity, nrays)\nCreate a Directional source (including geometry and angle components) by providing an axis-aligned bounding box (box) or an Scene object (scene) as well as the zenith (θ) and azimuth (Φ) angles, the radiosity of the source and the number of rays to be generated. Directional sources may generate incorrect results in the absence of a grid cloner that extendes the scenes. This is because the rays are generated from the upper face of the scene’s bounding box. See VPL documentation for details on light sources.\nsource\n# VPL.RayTracing.PointSource — Type.\nPointSource(vec)\nCreate a point irradiance source geometry at given 3D location vec, defined as vector of Cartesian coordinates (Vec(x, y, z)).\nsource\n# VPL.RayTracing.LineSource — Type.\nLineSource(p, line)\nCreate a line irradiance source geometry given an origin (p) and a segment (line) both specified as vector of Cartesian coordinates (Vec(x, y, z)). This will create a line source between the points p and p .+ line.\nsource\n# VPL.RayTracing.AreaSource — Type.\nAreaSource(mesh)\nCreate an area irradiance source geometry given a triangular mesh.\nsource\n# VPL.RayTracing.LambertianSource — Type.\nLambertianSource(x, y, z)\nLambertianSource(axes)\nCreate a Lambertian irradiance source angle by given a local coordinate system as three separate Vec objects representing the axes (x, y, z) or as tuple containing the three axes. Rays will be generated towards the hemisphere defined by the z direction. See VPL documentation for details on irradiance sources.\nsource\n# VPL.RayTracing.FixedSource — Type.\nFixedSource(dir)\nFixedSource(θ, Φ)\nCreate a fixed irradiance source by given a vector with the direction of the rays (dir) or zenith (θ) and azimuth (Φ) angles.\nsource\n\n\n\n\nMaterials\n# VPL.RayTracing.Sensor — Type.\nSensor(nw::Int)\nCreate a sensor material object to store power for nw wavelengths. A sensor material will let rays pass through without altering the direction or irradiance. They will also not count for the total number of ray iterations.\nsource\n# VPL.RayTracing.Black — Type.\nBlack(nw::Int)\nCreate a black material object to store power for nw wavelengths. See VPL documentation for details.\nsource\n# VPL.RayTracing.Lambertian — Type.\nLambertian(;τ = 0.0, ρ = 0.0)\nCreate a Lambertian material object from the values of transmittance (τ) and reflectance (ρ). When more than one wavelength is being simulated, a tuple of values should be passed for each optical property (as in τ = (0.1,0.2)).\nsource\n# VPL.RayTracing.Phong — Type.\nPhong(;τ = 0.0, ρd = 0.0, ρsmax = 0.0, n = 2)\nCreate a Phong material object from the values of transmittance (τ) diffuse reflectance (ρd), maximum Phong specular reflectance (ρsmax) and n is the specular exponent that controls the “Phong reflectance lobe”. When more than one wavelength is being simulated, a tuple of values should be passed for each optical property (as in τ = (0.1, 0.3)).\nsource\n# VPL.RayTracing.power — Function.\npower(material::Material)\nExtract the power stored inside a material.\nsource\n# VPL.RayTracing.reset! — Method.\nreset!(material::Material)\nReset the power stored inside a material back to zero\nsource\n# VPL.RayTracing.tau — Function.\ntau(vals...)\nGenerate values of transmisivity to be used in material object. vals... is a list of one or more comma separted values, corresponding to the different wavelengths/wavebands to be simulated in a ray tracer.\nsource\n# VPL.RayTracing.rho — Function.\nrho(vals...)\nGenerate values of reflectivity to be used in material object. vals... is a list of one or more comma separted values, corresponding to the different wavelengths/wavebands to be simulated in a ray tracer.\nsource"
  },
  {
    "objectID": "api/Render.html#rendering-methods",
    "href": "api/Render.html#rendering-methods",
    "title": "Virtual Plant Laboratory",
    "section": "Rendering methods",
    "text": "Rendering methods\n# VPL.Render.render — Function.\nrender(m::Mesh; kwargs...)\nRender a mesh. This will create a new visualization (see Documentation for details). Keyword arguments are passed to the render(scene::Geom.Scene) method and any unmatched keywords will be passed along to Makie.mesh().\nsource\nrender(scene::Geom.Scene; normals::Bool = false, wireframe::Bool = false, kwargs...)\nRender a Geom.Scene object. This will create a new visualization (see Documentation for details). normals = true will draw arrows in the direction of the normal vector for each triangle in the mesh, wireframe = true will draw the edges of each triangle with black lines. Keyword arguments are passed to Makie.mesh().\nsource\nrender(graph::Graph, Float64; normals::Bool = false, message = nothing,\n       wireframe::Bool = false, kwargs...)\nRender the 3D mesh associated to a Graph object. This will create a new visualization (see Documentation for details). normals = true will draw arrows in the direction of the normal vector for each triangle in the mesh, wireframe = true will draw the edges of each triangle with black lines. Keyword arguments are passed to Makie.mesh(). The argument message is any user-defined object that will be stored in the turtles and hence available within the feed! and feedcolor! methods. By default, double floating precision will be used (Float64) but it is possible to generate a version with a different precision by specifying the corresponding type as in render(graph, Float32).\nsource\nrender(graphs::Vector{<:Graph}, Float64; normals::Bool = false, \n       wireframe::Bool = false, messsage = nothing, kwargs...)\nRender the 3D mesh associated to an array of Graph objects. This will create a new visualization (see Documentation for details). normals = true will draw arrows in the direction of the normal vector for each triangle in the mesh, wireframe = true will draw the edges of each triangle with black lines. Keyword arguments are passed to Makie.mesh(). The argument message is any user-defined object that will be stored in the turtles and hence available within the feed! and feedcolor! methods. By default, double floating precision will be used (Float64) but it is possible to generate a version with a different precision by specifying the corresponding type as in render(graphs, Float32).\nsource\n# VPL.Render.render! — Function.\nrender!(source::Source{G, A, nw}; n = 20, alpha = 0.2, point = false,\n        scale = 0.2)\nAdd a mesh representing the light source to a 3D scene (if point = false) or a series of points representing the center of the light sources (if point = true). When point = false, for each type of light source a triangular mesh will be created, where n is the number of triangles (see documentation of geometric primitives for details) and alpha is the transparency to be used for each triangle. When point = true, only the center of the light source is rendered along with the normal vector at that point (representative of the direction at which rays are generated). In the current version, point = true is only possible for directional light sources.\nsource\nrender!(grid::GridCloner; alpha = 0.2)\nAdd a mesh representing the bounding boxes of the grid cloner to a 3D scene, where alpha represents the transparency of each box.\nsource\nrender!(m::Mesh; kwargs...)\nAdd a mesh to the visualization currently active. This will create a new visualization (see Documentation for details). Keyword arguments are passed to the render!(scene::Geom.Scene) method and any unmatched keywords will be passed along to Makie.mesh!().\nsource\n# VPL.Render.export_scene — Method.\nexport_scene(;scene, filename, kwargs...)\nExport a screenshot of the current visualization (stored as scene as output of a call to render) as a PNG file store in the path given by filename (including .png extension). Keyword arguments will be passed along to the corresponding save method from Makie (see VPL documentation for details).\nsource"
  },
  {
    "objectID": "Ecophys/index.html",
    "href": "Ecophys/index.html",
    "title": "Ecophys.jl",
    "section": "",
    "text": "This package contains modules describing different ecophysiological functions of plants, including processes such as photosynthesis, respiration, transpiration or phenology. They may be used as standalone or as a component of a plant growth model.\n\n\nThe package Ecophys is not in the Julia registry. To install it, you can use the following command:\nPkg.add(url = \"https://github.com/AleMorales/Ecophys.jl.git\")\n\n\n\nThe module Photosynthesis contains functions to calculate leaf CO2 assimilation and stomatal conductance for C3 and C4 species, based on the work by Yin & Struik (2009, NJAS). To create a model, use the corresponding function (C3() or C4()) and pass the parameters as keyword arguments (they all have default values that correspond to Tables 2 the original publication):\nusing Ecophys\nc3 = C3(Vcmax25 = 140.0)\nc4 = C4(Vcmax25 = 140.0)\nTo compute CO2 assimilation and stomatal conductance, use the photosynthesis() function, passing the photosynthesis model and the environmental conditions as inputs (with defaults):\nA_c3, gs_c3  = photosynthesis(c3, PAR = 100.0)\nA_c4, gs_c4  = photosynthesis(c4, PAR = 100.0)\nIt is also possible to work with physical units using the Unitful.jl package. In such case, the functions C3Q() and C4Q should be used to create the model but now the parameters are stored as Quantity objects:\nusing Unitful.DefaultSymbols # import symbols for units\nc3Q = C3Q(Vcmax25 = 140.0μmol/m^2/s)\nc4Q = C4Q(Vcmax25 = 140.0μmol/m^2/s)\nAnd the environmental conditions should be passed as Quantity objects (defaults are updated accordingly, see Unitful.jl documentation for details on how to create Quantity objects):\nA_c3, gs_c3  = photosynthesis(c3Q, PAR = 100.0μmol/m^2/s)\nA_c4, gs_c4  = photosynthesis(c4Q, PAR = 100.0μmol/m^2/s)\n\n\n\nEcophys may also compute the leaf energy balance to couple photosynthesis, transpiration and leaf temperature. In addition to the models of photosynthesis and stomatal conductance mentioned in the above, additional models of boundary layer conductance and leaf optical properties are required.\nCurrently, only a simple model of optical properties is avaiable that defines the leaf absorptance in PAR and NIR and its emmisivity in the thermal domain. This model is created using the SimpleOptical() function (defaults are provided):\nusing Ecophys\nopt = SimpleOptical(αPAR = 0.80)\nTwo models to compute the boundary layer conductance are available. They differ in the amount of information used regarding the geometry of the leaf. A simple model only accounts for the leaf characteristic length and is the most common approach (as before, a version that supports Quantity objects is also available):\ngb = simplegb(d = 0.1)\ngbQ = simplegbQ(d = 0.1m)\nThe second model is more complex as it takes into account the aspect ratio (length/width) of the leaf as well as its inclination angle. It will also distinguish between the boundary layer conductance of the front and back side of the leaf. This model relies on unpublished equations fitted to the data reviewed by Schuepp (1993, New Phyto):\ngbang = gbAngle(d = 0.1, ang = π/4, ar = 0.1)\ngbangQ = gbAngleQ(d = 0.1m, ang = π/4, ar = 0.1)\nThe leaf energy balance is then computed using solve_energy_balance() which will compute the leaf temperature that closes the energy balance as well as the corresponding CO2 assimilationa and transpiration:\nTleaf, A, Tr = solve_energy_balance(c3; gb = gb, opt = opt, PAR = 100.0, ws = 5.0)\nTleafangQ, AangQ, TrangQ = solve_energy_balance(c3Q; gb = gbangQ, opt = opt, PAR = 100.0μmol/m^2/s, ws = 5.0m/s)"
  },
  {
    "objectID": "Ecophys/Photosynthesis.html#co2-assimilation-and-stomatal-conductance",
    "href": "Ecophys/Photosynthesis.html#co2-assimilation-and-stomatal-conductance",
    "title": "Virtual Plant Laboratory",
    "section": "CO2 assimilation and stomatal conductance",
    "text": "CO2 assimilation and stomatal conductance\n# Ecophys.Photosynthesis.C3 — Type.\nC3(Sco25 = 2800.0, E_Sco = -24.46e3, Kmc25 = 270.0, E_Kmc = 80.99e3, \n    Kmo25 = 165.0e3, E_Kmo = 23.72e3, Vcmax25 = 120.0, E_Vcmax = 65.33e3, \n    theta = 0.7, Phi2 = 0.82, sigma2 = 0.5, beta = 0.85, fcyc = 0.1, \n    fpseudo = 0.05, Jmax25 = 230.0, E_Jmax = 30.0e3, D_Jmax = 200.0e3, \n    Topt_Jmax = 300.5, TPU25 = 12.0, E_TPU = 53.1e3, D_TPU = 20.18e3)\nData structure to store all the parameters for the C3 photosynthesis model.\nArguments\n\nSco25: Sc/o parameter at 25 C\nE_Sco: Apparent activation energy of Sc/o (J/mol)\nKmc25: Km for CO2 at 25 C (μmol/mol)\nE_Kmc: Activation energy of Kmc (J/mol)\nKmo25: Km for O2 at 25 C (umol/mol)\nE_Kmo: Activation energy of Kmo (J/mol)\nVcmax25: Maximum rate of carboxylation at 25 C (μmol/m2/s)\nE_Vcmax: Activation energy of Vcmax (J/mol)\ntheta: Curvature parameter\nPhi2: Low-light PSII quantum yield\nsigma2: Partitioning of excitation between PSII and PSI\nbeta: Leaf absorptance of PAR\nfcyc: Fraction of electrons at PSI that follow cyclic transport around PSI\nfpseudo: Fraction of electrons at PSI that are used by alternative electron sinks\nJmax25: Maximum rate of electron transport (μmol/m2/s)\nE_Jmax: Activation energy Jmax (J/mol)\nD_Jmax: Deactivation energy of Jmax (J/mol)\nTopt_Jmax: Optimal temperature for Jmax (K)\nTPU25: Maximum rate of triose phosphate utilisation (μmol/m2/s)\nE_TPU: Activation energy TPU (J/mol)\nD_TPU: Deactivation energy of TPU (J/mol)\n\nsource\n# Ecophys.Photosynthesis.C3Q — Type.\nC3Q(Sco25 = 2800.0, E_Sco = -24.46e3J/mol, Kmc25 = 270.0μmol/mol, E_Kmc = 80.99e3J/mol,\n     Kmo25 = 165.0e3μmol/mol, E_Kmo = 23.72e3J/mol, Vcmax25 = 120.0μmol/m^2/s, E_Vcmax = 65.33e3J/mol,\n     theta = 0.7, Phi2 = 0.82, sigma2 = 0.5, beta = 0.85, fcyc = 0.1, fpseudo = 0.05, \n     Jmax25 = 230.0μmol/m^2/s, E_Jmax = 30.0e3J/mol, D_Jmax = 200.0e3J/mol, Topt_Jmax = 300.5K, \n     TPU25 = 12.0μmol/m^2/s, E_TPU = 53.1e3J/mol, D_TPU = 201.8e3J/mol, Topt_TPU = 306.5K, \n     Rd25 = 1.2μmol/m^2/s, E_Rd = 46.39e3J/mol, gm25 = 0.4mol/m^2/s, E_gm = 49.6e3J/mol, \n     D_gm = 437.4e3J/mol, Topt_gm = 308.6K, gso = 0.01mol/m^2/s, a1 = 0.85, b1 = 0.14e-3/Pa)\nData structure to store all the parameters for the C3 photosynthesis model using Quantity objects from Unitful.jl.\nArguments\n\nSco25: Sc/o parameter at 25 C\nE_Sco: Apparent activation energy of Sc/o (J/mol)\nKmc25: Km for CO2 at 25 C (μmol/mol)\nE_Kmc: Activation energy of Kmc (J/mol)\nKmo25: Km for O2 at 25 C (umol/mol)\nE_Kmo: Activation energy of Kmo (J/mol)\nVcmax25: Maximum rate of carboxylation at 25 C (μmol/m2/s)\nE_Vcmax: Activation energy of Vcmax (J/mol)\ntheta: Curvature parameter\nPhi2: Low-light PSII quantum yield\nsigma2: Partitioning of excitation between PSII and PSI\nbeta: Leaf absorptance of PAR\nfcyc: Fraction of electrons at PSI that follow cyclic transport around PSI\nfpseudo: Fraction of electrons at PSI that are used by alternative electron sinks\nJmax25: Maximum rate of electron transport (μmol/m2/s)\nE_Jmax: Activation energy Jmax (J/mol)\nD_Jmax: Deactivation energy of Jmax (J/mol)\nTopt_Jmax: Optimal temperature for Jmax (K)\nTPU25: Maximum rate of triose phosphate utilisation (μmol/m2/s)\nE_TPU: Activation energy TPU (J/mol)\nD_TPU: Deactivation energy of TPU (J/mol)\n\nsource\n# Ecophys.Photosynthesis.C4 — Type.\nC4(Sco25 = 2590.0, E_Sco = -24.46e3, Kmc25 = 650.0, E_Kmc = 79.43e3, Kmo25 = 450e3, \n   E_Kmo = 36380.0, Vcmax25 = 120.0, E_Vcmax = 65.33, theta = 0.7, Phi2 = 0.83, sigma2 = 0.5, \n   beta = 0.85, fQ = 1.0, fpseudo = 0.1, h = 4.0, Jmax25 = 230.0, E_Jmax = 48e3, D_Jmax = 200e3, \n   Topt_Jmax = 300.5, x = 0.4, alpha = 0.1, kp25 = 0.7, E_kp = 46.39e3, gbs = 0.003, Rd25 = 1.2, \n   E_Rd = 46.39e3, gso = 0.01, a1 = 0.9, b1 = 0.15e-3)\nData structure to store all the parameters for the C3 photosynthesis model.\nArguments\n\nSco25: Sc/o parameter at 25 C\nE_Sco: Apparent activation energy of Sc/o (J/mol)\nKmc25: Km for CO2 at 25 C (μmol/mol)\nE_Kmc3: Activation energy of Kmc (J/mol)\nKmo25: Km for O2 at 25 C (umol/mol)\nE_Kmo: Activation energy of Kmo (J/mol)\nVcmax25: Maximum rate of carboxylation at 25 C (μmol/m2/s)\nE_Vcmax: Activation energy of Vcmax (J/mol)\ntheta: Curvature parameter\nPhi2: Low-light PSII quantum yield\nsigma2: Partitioning of excitation between PSII and PSI\nbeta: Leaf absorptance of PAR\nfQ: Fraction of electrons at reduced plastoquinone that follow the Q-cycle\nfpseudo: Fraction of electrons at PSI that follow cyclic transport around PSI\nh: Number of protons required to produce one ATP\nJmax25: Maximum rate of electron transport (μmol/m2/s)\nE_Jmax: Activation energy Jmax (J/mol)\nD_Jmax: Deactivation energy of Jmax (J/mol)\nTopt_Jmax: Entropy coefficient of Jmax (J/mol/K)\nx: Fraction of electron transport partitioned to mesophyll cells\nalpha: Fraction of O2 evolution occuring in the bundle sheath\nkp25: Initial carboxylation efficiency of the PEP carboxylase (mol/m2/s)\nE_kp: Activation energy of kp (J/mol)\ngbs: Bundle sheath conductance (mol/m^2/s)\nRd25:: Respiration rate at 25 C (μmol/m2/s)\nE_Rd: Activation energy of Rd (J/mol)\ngso: Minimum stomatal conductance to fluxes of CO2 in darkness (mol/m2/s)\na1: Empirical parameter in gs formula\nb1: Empirical parameter in gs formula (1/kPa)\n\nsource\n# Ecophys.Photosynthesis.C4Q — Type.\nC4(Sco25 = 2590.0, E_Sco = -24.46e3J/mol, Kmc25 = 650.0μmol/mol, E_Kmc = 79.43e3J/mol,\n   Kmo25 = 450e3μmol/mol, E_Kmo = 36380.0J/mol, Vcmax25 = 120.0μmol/m^2/s, E_Vcmax = 65.33J/mol,\n   theta = 0.7, Phi2 = 0.83, sigma2 = 0.5, beta = 0.85, fQ = 1.0, fpseudo = 0.1, h = 4.0, \n   Jmax25 = 230.0μmol/m^2/s, E_Jmax = 48e3J/mol, D_Jmax = 200e3J/mol, Topt_Jmax = 300.5K, \n   x = 0.4, alpha = 0.1, kp25 = 0.7mol/m^2/s, E_kp = 46.39e3J/mol, gbs = 0.003mol/m^2/s, \n   Rd25 = 1.2μmol/m^2/s, E_Rd = 46.39e3J/mol, gso = 0.01mol/m^2/s, a1 = 0.9, b1 = 0.15e-3/Pa)\nData structure to store all the parameters for the C4 photosynthesis model using Quantity objects from Unitful.jl.\nArguments\n\nSco25: Sc/o parameter at 25 C\nE_Sco: Apparent activation energy of Sc/o (J/mol)\nKmc25: Km for CO2 at 25 C (μmol/mol)\nE_Kmc3: Activation energy of Kmc (J/mol)\nKmo25: Km for O2 at 25 C (umol/mol)\nE_Kmo: Activation energy of Kmo (J/mol)\nVcmax25: Maximum rate of carboxylation at 25 C (μmol/m2/s)\nE_Vcmax: Activation energy of Vcmax (J/mol)\ntheta: Curvature parameter\nPhi2: Low-light PSII quantum yield\nsigma2: Partitioning of excitation between PSII and PSI\nbeta: Leaf absorptance of PAR\nfQ: Fraction of electrons at reduced plastoquinone that follow the Q-cycle\nfpseudo: Fraction of electrons at PSI that follow cyclic transport around PSI\nh: Number of protons required to produce one ATP\nJmax25: Maximum rate of electron transport (μmol/m2/s)\nE_Jmax: Activation energy Jmax (J/mol)\nD_Jmax: Deactivation energy of Jmax (J/mol)\nTopt_Jmax: Entropy coefficient of Jmax (J/mol/K)\nx: Fraction of electron transport partitioned to mesophyll cells\nalpha: Fraction of O2 evolution occuring in the bundle sheath\nkp25: Initial carboxylation efficiency of the PEP carboxylase (mol/m2/s)\nE_kp: Activation energy of kp (J/mol)\ngbs: Bundle sheath conductance (mol/m^2/s)\nRd25:: Respiration rate at 25 C (μmol/m2/s)\nE_Rd: Activation energy of Rd (J/mol)\ngso: Minimum stomatal conductance to fluxes of CO2 in darkness (mol/m2/s)\na1: Empirical parameter in gs formula\nb1: Empirical parameter in gs formula (1/kPa)\n\nsource\n# Ecophys.Photosynthesis.photosynthesis — Function.\nphotosynthesis(par::C3, PAR = 1000.0, RH = 0.75, Tleaf = 298.0, Ca = 400.0, O2 = 210e3, gb = 0.5)\nphotosynthesis(par::C4, PAR = 1000.0, RH = 0.75, Tleaf = 298.0, Ca = 400.0, O2 = 210e3, gb = 0.5)\nphotosynthesis(par::C3Q, PAR = 1000.0μmol/m^2/s, RH = 0.75, Tleaf = 298.0K, Ca = 400.0μmol/mol, O2 = 210e3μmol/mol, gb = 0.5mol/m^2/s)\nphotosynthesis(par::C4Q, PAR = 1000.0μmol/m^2/s, RH = 0.75, Tleaf = 298.0K, Ca = 400.0μmol/mol, O2 = 210e3μmol/mol, gb = 0.5mol/m^2/s)\nCalculate net CO2 assimilation (umol/m2/s), transpiration (mmol/m2/s) and stomatal condutance to fluxes of CO2 (mol/m2/s) as a function of photosynthetically active radiation (PAR, umol/m2/s), relative humidity (RH), leaf temperature (Tleaf, K), air CO2 partial pressure (Ca, μmol/mol), oxygen (O2, μmol/mol) and boundary layer conductance to CO2 (gb, mol/m2/s). Environmental inputs must be scalar.\nsource"
  },
  {
    "objectID": "Ecophys/Photosynthesis.html#boundary-layer-conductance",
    "href": "Ecophys/Photosynthesis.html#boundary-layer-conductance",
    "title": "Virtual Plant Laboratory",
    "section": "Boundary layer conductance",
    "text": "Boundary layer conductance\n# Ecophys.Photosynthesis.gb — Function.\ngb(p::gbType, ws, Tleaf, Tair, P)\nCompute boundary layer conductance for heat, water vapor and CO2.\nArguments\n\np: Model of boundary layer conductance\nws: Wind speed (m/s)\nTleaf: Leaf temperature (K)\nTair: Air temperature (K)\nP: Air pressure (Pa)\n\nReturns\n\ngbh: Boundary layer conductance for heat (W/m²/K)\ngbw: Boundary layer conductance for water vapor (mol/m²/s)\ngbc: Boundary layer conductance for CO2 (mol/m²/s)\n\nsource\n# Ecophys.Photosynthesis.simplegb — Type.\nsimplegb(; d = 0.01)\nSimple model of boundary layer conductance.\nArguments\n\nd: Characteristic leaf length (m)\n\nsource\n# Ecophys.Photosynthesis.simplegbQ — Type.\nsimplegbQ(; d = 0.01m)\nSimple model of boundary layer conductance using Quantity from Unitful.jl.\nArguments\n\nd: Characteristic leaf length (m)\n\nsource\n# Ecophys.Photosynthesis.gbAngle — Type.\ngbAngle(; d = 0.01, ang = 0.0, ar = 1.0, fangm = 1.381, fangk = 0.034, \nα = 2.738, b0_0 = 0.455, d_b0 = 2.625, b0_n = 0.373, b0_KAR = 28.125,  db_0 = 0.085, \nd_db = 0.437, db_n = 5.175, db_KAR = 0.884,  β_0 = 3.362, d_β = 17.664, β_n = 4.727, \nβ_KAR = 0.677)\nModel of boundary layer conductance that accounts for inclination angle and leaf aspect ratio (see documentation for details).\nArguments\n\nd: Characteristic leaf length (m)\nang: Leaf inclination angle (°)\nar: Leaf aspect ratio (length/width)\nfangm: Maximum enhancement factor due to inclination angle\nfangk: Exponent in response to inclination angle\nα: Effect on back boundary layer conductance due to leaf inclination angle and aspect ratio\nb0_0: Parameter in the effect of aspect ratio (see documentation)\nd_b0: Parameter in the effect of aspect ratio (see documentation)\nb0_n: Parameter in the effect of aspect ratio (see documentation)\nb0_KAR: Parameter in the effect of aspect ratio (see documentation)\ndb_0: Parameter in the effect of aspect ratio (see documentation)\nd_db: Parameter in the effect of aspect ratio (see documentation)\ndb_n: Parameter in the effect of aspect ratio (see documentation)\ndb_KAR: Parameter in the effect of aspect ratio (see documentation)\nβ_0: Parameter in the effect of aspect ratio (see documentation)\nd_β: Parameter in the effect of aspect ratio (see documentation)\nβ_n: Parameter in the effect of aspect ratio (see documentation)\nβ_KAR: Parameter in the effect of aspect ratio (see documentation)\n\nsource\n# Ecophys.Photosynthesis.gbAngleQ — Type.\ngbAngleQ(; d = 0.01m, ang = 0.0, ar = 1.0, fangm = 1.381, fangk = 0.034, \nα = 2.738, b0_0 = 0.455, d_b0 = 2.625, b0_n = 0.373, b0_KAR = 28.125,  db_0 = 0.085, \nd_db = 0.437, db_n = 5.175, db_KAR = 0.884,  β_0 = 3.362, d_β = 17.664, β_n = 4.727, \nβ_KAR = 0.677)\nModel of boundary layer conductance that accounts for inclination angle and leaf aspect ratio (see documentation for details) using Quantity for Unitful.jl.\nArguments\n\nd: Characteristic leaf length (m)\nang: Leaf inclination angle (°)\nar: Leaf aspect ratio (length/width)\nfangm: Maximum enhancement factor due to inclination angle\nfangk: Exponent in response to inclination angle\nα: Effect on back boundary layer conductance due to leaf inclination angle and aspect ratio\nb0_0: Parameter in the effect of aspect ratio (see documentation)\nd_b0: Parameter in the effect of aspect ratio (see documentation)\nb0_n: Parameter in the effect of aspect ratio (see documentation)\nb0_KAR: Parameter in the effect of aspect ratio (see documentation)\ndb_0: Parameter in the effect of aspect ratio (see documentation)\nd_db: Parameter in the effect of aspect ratio (see documentation)\ndb_n: Parameter in the effect of aspect ratio (see documentation)\ndb_KAR: Parameter in the effect of aspect ratio (see documentation)\nβ_0: Parameter in the effect of aspect ratio (see documentation)\nd_β: Parameter in the effect of aspect ratio (see documentation)\nβ_n: Parameter in the effect of aspect ratio (see documentation)\nβ_KAR: Parameter in the effect of aspect ratio (see documentation)\n\nsource"
  },
  {
    "objectID": "Ecophys/Photosynthesis.html#energy-balance",
    "href": "Ecophys/Photosynthesis.html#energy-balance",
    "title": "Virtual Plant Laboratory",
    "section": "Energy balance",
    "text": "Energy balance\n# Ecophys.Photosynthesis.SimpleOptical — Type.\nSimpleOptical(; αPAR = 0.85, αNIR = 0.20, ϵ = 0.95)\nSimple optical properties of a leaf.\nArguments\n\nαPAR: Absorption coefficient of PAR\nαNIR: Absorption coefficient of NIR\nϵ: Emissivity for thermal radiation\n\nsource\n# Ecophys.Photosynthesis.energybalance — Function.\nenergybalance(pgb, pAgs, pEb, PAR, NIR, ws, RH, Tair, Ca, P, O2)\nCalculate the energy balance of a leaf.\nArguments\n\npgb: Boundary layer conductance model\npAgs: Photosynthesis and stomatal conductance model\npEb: Optical properties of the leaf\nPAR: Photosynthetically active radiation (umol/m2/s)\nNIR: Near-infrared radiation (W/m2)\nws: Wind speed (m/s)\nRH: Relative humidity\nTair: Air temperature (K)\nCa: Atmospheric CO2 concentration (μmol/mol)\nP: Air pressure (kPa)\nO2: Atmospheric O2 concentration (μmol/mol)\n\nDetails\nInputs maybe be either Real or Quantity types (i.e., with physical units). If Quantity types are used, the output will be a Quantity type.\nsource\n# Ecophys.Photosynthesis.solve_energy_balance — Function.\nsolve_energy_balance(Ags::Union{C3Q, C4Q}; gb = simplegbQ(), \n                     opt = SimpleOptical(), PAR = 1000.0μmol/m^2/s, \n                     NIR = 250.0W/m^2, ws = 1.0m/s, RH = 0.75, \n                     Tair = 298.0K, Ca = 400.0μmol/mol, P = 101.0kPa, \n                     O2 = 210.0mmol/mol, order = Order2(), xatol = 0.01, \n                     maxfnevals = 100)\nsolve_energy_balance(Ags::Union{C3, C4}; gb = simplegb(), \n                     opt = SimpleOptical(), PAR = 1000.0, NIR = 250.0, \n                     ws = 1.0, RH = 0.75, Tair = 298.0, Ca = 400.0, \n                     P = 101.0e3, O2 = 210.0e3, order = Order2(), xatol = 0.01, \n                     maxfnevals = 100)\nSolve the leaf energy balance coupled to photosynthesis and transpiration.\nArguments\n\nAgs: Photosynthesis and stomatal conductance model\ngb: Boundary layer conductance model\nopt: Optical properties of the leaf\nPAR: Photosynthetically active radiation (umol/m2/s)\nNIR: Near-infrared radiation (W/m2)\nws: Wind speed (m/s)\nRH: Relative humidity\nTair: Air temperature (K)\nCa: Atmospheric CO2 concentration (μmol/mol)\nP: Air pressure (Pa)\nO2: Atmospheric O2 concentration (μmol/mol)\norder: Order of the root solving algorithm that finds leaf temperature (see Roots.jl package for more information).\nxatol: Absolute tolerance of the root solving algorithm (see Roots.jl package for more information),\nmaxfnevals: Maximum number of function evaluations of the root solving algorithm (see Roots.jl package for more information).\n\nDetails\nInputs maybe be either Real or Quantity types from Unitful.jl (i.e., with physical units). If Quantity types are used, the output will be a Quantity type.\nReturns\nA named tuple with net CO2 assimilation (A, μmol/m^2/s), transpiration (Tr, mol/m^2/s) and leaf temperature (Tleaf, K).\nsource\n# Ecophys.Photosynthesis.transpiration — Function.\ntranspiration(;gsw = 0.1, gbw = 1.0, Tleaf = 300.0, Tair = 298.0, P = 101e3,\n               RH = 0.75)\nCompute transpiration rate (mol/m^2/s) from conductance to water vapor and environmental variables.\nArguments\n\ngsw: Stomatal conductance to water vapor (mol/m^2/s)\ngbw: Boundary layer conductance to water vapor (mol/m^2/s)\nTleaf: Leaf temperature (K)\nTair: Air temperature (K)\nP: Air pressure (Pa)\nRH: Relative humidity\n\nsource"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "The Virtual Plant Laboratory",
    "section": "",
    "text": "Important\n\n\n\nThe Virtual Plant Laboratory is in an early developmental stage and it is released for the purposes of early testing and user feedback. Please contact me if you intend to use it for research or commercial purposes at this stage."
  },
  {
    "objectID": "index.html#introduction",
    "href": "index.html#introduction",
    "title": "The Virtual Plant Laboratory",
    "section": "Introduction",
    "text": "Introduction\nThe Virtual Plant Laboratory (VPL) is a Julia package that aids in the construction, simulation and visualization of functional-structural plant models (FSPM). VPL is not a standalone solution to all the computational problems relevant to FSPM, but rather it focuses on those algorithms that are specific to FSPM and for which there are no good solutions in the Julia package ecosystem. Furthermore, VPL is 100% written in Julia and therefore VPL will work in any platform and with any code editor where Julia works. Finally, VPL does not offer a domain specific language for FSPM but rather it allows building FSP models by creating user-defined data types and methods.\nThere is no standard definition of what an FSPM is (though these models will always involve some combination of plant structure and function) so VPL may not be useful with every possible FSPM. Instead, VPL focuses on models that represent indivudual plants as graphs of elements (usually organs) that interact with each other and with the environment. In a typical VPL model, each plant is represented by its own graph which can change dynamically through the iterative application of graph rewriting rules. Based on this goal, what VPL offers are data structures and algorithms that allow modelling the dynamic evolution of graphs that represent plants as collections of organs or other morphological elements and modelling the the interaction between plants and their environment by generating 3D structures and simulating capture of different resources (e.g. light).\nIn terms of design, VPL gives priority to performance and simple interfaces as opposed to complex layers of abstraction. This implies that models in VPL may be more verbose and procedural (as opposed to descriptive) than in other FSPM software, though may also make them more transparent and easier to follow."
  },
  {
    "objectID": "index.html#installation",
    "href": "index.html#installation",
    "title": "The Virtual Plant Laboratory",
    "section": "Installation",
    "text": "Installation\nVPL requires using Julia version 1.7 or higher. The installation of VPL is as easy as running the following code:\nusing Pkg\nPkg.add(PackageSpec(url = \"https://github.com/AleMorales/VPL.git\", rev  = \"master\"))\nThis requires an Internet connection such that Julia will download the source code of the VPL package and install it in the local machine."
  },
  {
    "objectID": "index.html#the-vplverse",
    "href": "index.html#the-vplverse",
    "title": "The Virtual Plant Laboratory",
    "section": "The VPLverse",
    "text": "The VPLverse\nThe package VPL contains all the basic functionality to build FSP models but, as indicated earlier, the emphasis is on minimal, simple and transparent interfaces. In order to facilitate the construction of non-trivial FSP models, an ecosystem of packages built around VPL provide additional support to the modeller by offering reusable modules that can be reused in new models.\nThe packages currently planned for VPLverse are:\n\nEcophys - Algorithms and data structures to simulate ecophysiological processes including photosynthesis, transpiration, leaf energy balance, phenology or respiration.\nSky - Algorithms to simulate different sky conditions in terms of the intensity of solar radiation and its spatial distribution.\n\nIn addition, all the tutorials on this website can be found at the VPLTutorials package."
  },
  {
    "objectID": "index.html#documentation",
    "href": "index.html#documentation",
    "title": "The Virtual Plant Laboratory",
    "section": "Documentation",
    "text": "Documentation\nDocumentation for VPL is provided in this website in four formats:\n\nUser manual\nTutorials and examples\nAPI\nTechnical notes\n\nThe documentation for packages from the VPLverse are included in their respective sections.\nNew users are expected to start with the tutorials and consult the user manual to understand better the different concepts used in VPL and get an overview of the different options available. The API documentation describes each individual function and data type, with an emphasis on inputs and outputs and (in addition to this website) it can be accessed from within Julia with ? (see the section Accessing Documentation in the Julia manual). The technical notes are useful for people who want to understand the internal details of VPL and how different algorithms are implemented (i.e. the technical notes should be seen as a supplementary to the source code of VPL)."
  },
  {
    "objectID": "manual/Geometry/Primitives/index.html",
    "href": "manual/Geometry/Primitives/index.html",
    "title": "Geometry primitives",
    "section": "",
    "text": "using VPL\nVPL offers several functions to created 3D meshes that correspond to common geometric shapes (i.e., primitives). They are meant to represent simple geometry elements or to build more complex geometries through the use of turtle-based procedural geometry. For that reason, there are two versions of each primitive constructor: one that constructs the mesh directly (with a standard location and orientation) and one that feeds the mesh to a turtle. The former is meant to be used when manually adding geometries to am existing scene (e.g., soil, structural elements) whereas the latter is mean to be used within the feed methods associated to nodes in a graph. Additional functions are able to translate and rotate these meshes to the desired location and orientation (see API of the Geometry module for details).\nBelow, the functions for direct construction of the meshes are listed. The turtle-based constructor have the same argument plus the turtle arugment itself as well as optional arguments for color and optical materias (see API of the Geometry module for more details).\nEach primitive is visualized using the render function form VPL. These 3D visualizations keep the axes to help understand what the standard location and orientation are (use axes = false to turn off). They also set normals = true and wireframe = true to highlight how the mesh is partitioned into triangles and the normal vectors of each triangle (this is important for the ray tracer and when exporting meshes out of VPL). All meshes are rendered in green assuming 50% transparency (color = RGBA(0,1,0,0.5)). Note that one must use transparency = true to ensure that the transparency is enabled when rendering the mesh."
  },
  {
    "objectID": "manual/Geometry/Primitives/index.html#triangle",
    "href": "manual/Geometry/Primitives/index.html#triangle",
    "title": "Geometry primitives",
    "section": "Triangle",
    "text": "Triangle\n\np = Triangle(length = 1.0, width = 1.0)\nrender(p, wireframe = true, normals = true, color = RGBA(0,1,0,0.5), transparency = true)"
  },
  {
    "objectID": "manual/Geometry/Primitives/index.html#rectangle",
    "href": "manual/Geometry/Primitives/index.html#rectangle",
    "title": "Geometry primitives",
    "section": "Rectangle",
    "text": "Rectangle\n\np = Rectangle(length = 1.0, width = 1.0)\nrender(p, wireframe = true, normals = true, color = RGBA(0,1,0,0.5), transparency = true)"
  },
  {
    "objectID": "manual/Geometry/Primitives/index.html#trapezoid",
    "href": "manual/Geometry/Primitives/index.html#trapezoid",
    "title": "Geometry primitives",
    "section": "Trapezoid",
    "text": "Trapezoid\n\np = Trapezoid(length = 1.0, width = 1.0, ratio = 0.5)\nrender(p, wireframe = true, normals = true, color = RGBA(0,1,0,0.5), transparency = true)"
  },
  {
    "objectID": "manual/Geometry/Primitives/index.html#ellipse",
    "href": "manual/Geometry/Primitives/index.html#ellipse",
    "title": "Geometry primitives",
    "section": "Ellipse",
    "text": "Ellipse\n\np = Ellipse(length = 1.0, width = 1.0, n = 30)\nrender(p, wireframe = true, normals = true, color = RGBA(0,1,0,0.5), transparency = true)"
  },
  {
    "objectID": "manual/Geometry/Primitives/index.html#axis-aligned-bounding-box",
    "href": "manual/Geometry/Primitives/index.html#axis-aligned-bounding-box",
    "title": "Geometry primitives",
    "section": "Axis-aligned bounding box",
    "text": "Axis-aligned bounding box\n\np = BBox(Vec(0.0, 0.0, 0.0), Vec(1.0, 1.0, 1.0))\nrender(p, wireframe = true, normals = true, color = RGBA(0,1,0,0.5), transparency = true)"
  },
  {
    "objectID": "manual/Geometry/Primitives/index.html#cube",
    "href": "manual/Geometry/Primitives/index.html#cube",
    "title": "Geometry primitives",
    "section": "Cube",
    "text": "Cube\nSolid version\n\np = SolidCube(length = 1.0, width = 1.0, height = 1.0)\nrender(p, wireframe = true, normals = true, color = RGBA(0,1,0,0.5), transparency = true)\n\n\n\n\nHollow version\n\np = HollowCube(length = 1.0, width = 1.0, height = 1.0)\nrender(p, wireframe = true, normals = true, color = RGBA(0,1,0,0.5), transparency = true)"
  },
  {
    "objectID": "manual/Geometry/Primitives/index.html#cylinder",
    "href": "manual/Geometry/Primitives/index.html#cylinder",
    "title": "Geometry primitives",
    "section": "Cylinder",
    "text": "Cylinder\nSolid version\n\np = SolidCylinder(length = 1.0, width = 1.0, height = 1.0, n = 80)\nrender(p, wireframe = true, normals = true, color = RGBA(0,1,0,0.5), transparency = true)\n\n\n\n\nHollow version\n\np = HollowCylinder(length = 1.0, width = 1.0, height = 1.0, n = 40)\nrender(p, wireframe = true, normals = true, color = RGBA(0,1,0,0.5), transparency = true)"
  },
  {
    "objectID": "manual/Geometry/Primitives/index.html#frustum",
    "href": "manual/Geometry/Primitives/index.html#frustum",
    "title": "Geometry primitives",
    "section": "Frustum",
    "text": "Frustum\nSolid version\n\np = SolidFrustum(length = 1.0, width = 1.0, height = 1.0, ratio = 0.5, n = 80)\nrender(p, wireframe = true, normals = true, color = RGBA(0,1,0,0.5), transparency = true)\n\n\n\n\nHollow version\n\np = HollowFrustum(length = 1.0, width = 1.0, height = 1.0, ratio = 0.5, n = 40)\nrender(p, wireframe = true, normals = true, color = RGBA(0,1,0,0.5), transparency = true)"
  },
  {
    "objectID": "manual/Geometry/Primitives/index.html#cone",
    "href": "manual/Geometry/Primitives/index.html#cone",
    "title": "Geometry primitives",
    "section": "Cone",
    "text": "Cone\nSolid version\n\np = SolidCone(length = 1.0, width = 1.0, height = 1.0, n = 40)\nrender(p, wireframe = true, normals = true, color = RGBA(0,1,0,0.5), transparency = true)\n\n\n\n\nHollow version\n\np = HollowCone(length = 1.0, width = 1.0, height = 1.0, n = 20)\nrender(p, wireframe = true, normals = true, color = RGBA(0,1,0,0.5), transparency = true)"
  },
  {
    "objectID": "manual/Geometry/Turtle/index.html",
    "href": "manual/Geometry/Turtle/index.html",
    "title": "Turtle graphics and scenes",
    "section": "",
    "text": "Turtle graphics\nGeneral concepts\nMovement operators\nMeshes, include I/O\n\n\nScenes\nfeed!()\nPrimitive constructors\nMerging multiple scenes\nParallel construction of scenes\nManually adding elements to an existing scene"
  },
  {
    "objectID": "manual/Graphs/index.html",
    "href": "manual/Graphs/index.html",
    "title": "Dynamic graph creation and manipulation",
    "section": "",
    "text": "A model in VPL is a (discrete) dynamical model that describes the time evolution of one or more entities (i.e. objects of type graph). Each graph (usually assumed to be an individual plant) is characterized by a series of nodes (usually organs) that are represented by nodes in a graph. Each node is defined by its own state, including (if applicable) a description of its geometry, color, optical propertes, etc. The dynamic simulation of a graph consists of the creation and destruction of nodes via graph rewriting rules, and changes to the internal state of its nodes with the help of queries.\nThe 3D structure of a graph is generated by processing its nodes using a Turtle procedural geometry approach (i.e. inspired on Logo’s turtle graphs as used in L-systems) and following the topology of the graph. This 3D structure may be used for visualization using a 3D renderer or for simulating spatial processes.\nVPL does not provide a domain-specific language to implement rules and queries. Rather, they are defined by functions which are stored in objects of types Rule and Query, respectively. Similarly, the nodes of a graph can be of any user-defined type, as long as the user defines the necessary methods to support specific functionality (e.g. the feed! method to generate geometry).\nVPL is designed around data types and methods. Building a model in VPL typically requires:\n\nDefining types for the different classes of nodes of a graph\nCreating rules and queries based on these types\nCreating graphs by combining rules and the initial states of the graphs\nCreating additional elements in the scene (e.g. soil)\n\nA simulation in VPL consists of executing rules iteratively and, within each iteration:\n\nUse queries to select subset of nodes and modify their states.\nModify graph-level variables directly.\nUse algorithms in VPL to simulate interactions among nodes or between nodes and their environment.\n\nIn addition, VPL allows visualizing the results of a simulation by: * 3D rendering of the generated scenes * Network graph representing the nodes in the graph\nVPL is designed to facilitate modular model development, such as using different types of graphs in the same simulation, alternative visualizations of the same scene by mapping internal states of nodes to colors, or including multiple ray tracers in the same simulation. Users may also create their own data types that include graphs as fields or to nest graphs within other graphs."
  },
  {
    "objectID": "manual/Graphs/index.html#graph-construction-algebra",
    "href": "manual/Graphs/index.html#graph-construction-algebra",
    "title": "Dynamic graph creation and manipulation",
    "section": "Graph-construction algebra",
    "text": "Graph-construction algebra\nWhen initializing a graph and when specifying a graph rewriting rule it is necessary to indicate the topological relationship between the nodes being added to a graph (i.e. effectively we build graphs by appending sub-graphs). In order to facilitate the description of these relationships, a simple algebra is defined for all objects that inherit from Node.\nThe + operator indicates a linear parent-child dependency between the operands. For example, M() + L() indicates that the object generated by L() is a child of M(). A branching point is introduced by enclosing the children of a node within () and separating the different branches with “,”. For example, (M(1) + (L(2), L(3)) + M(4) + L(5)) creates a tree that starts with M(1), has 3 children (L(2), L(3) and M(4)) and M(4) has a child L(5).\nA graph always keep tracks of two special nodes: the root and the insertion point. The root is the node that has no parent. When you use a graph rewriting rule (see below) to replace a node a with a graph that has a root node b, the result is that node a is replaced by node b and will inherit all the children and parent from node a (plus the children that b already had in the replacement graph).\nAn insertion point is the node of a graph where new nodes will be connected to when using the + operator. Branches do not modify the insertion point of an existing graph, but linear addition of nodes will always update the insertion point to the last node. Thus, these two expressions produce the same tree structure but with different insertion points: M(1) + (L(2), L(3)) + M(4) + L(5) and M(1) + (L(2), L(3), M(4) + L(5)). In the first case, the insertion point becomes the node L(5) but in the second case it remains at M(1). Keeping track of the insertion point of a graph is important when building a graph in several steps."
  },
  {
    "objectID": "manual/Graphs/index.html#matching-relationships-among-nodes",
    "href": "manual/Graphs/index.html#matching-relationships-among-nodes",
    "title": "Dynamic graph creation and manipulation",
    "section": "Matching relationships among nodes",
    "text": "Matching relationships among nodes\nSometimes the lhs function needs to check the relationships between nodes inside a graph (e.g. match all leaves that belong to a particular branch of a graph). In order achieve that, one can use the functions hasParent() and hasChildren() to check for inmediate connections (i.e. effectively to check whether the node is a root or a leaf in the graph) whereas hasAncestor() and hasDescendant() allow traversing the graph and finding any connected node that matches a specific query. If we need to extract the contents of the node, we may use the corresponding functions parent(), children(), ancestor() and descendant(). Note that children() will return all the children nodes as a tuple, but the rest of functions only return one node at a time. All these functions take a Context object as input and return either true or false (for the functions that start with has) or a Context or tuple of Context objects for the functions that extract the actual connected node. These methods may also be used inside the rhs function of rules. However, to avoid code repetition (and for performance reasons), it is recommended to capture the Context objects of connected in the lhs function and pass them to the rhs as described below (see below)."
  },
  {
    "objectID": "manual/Graphs/index.html#capturing-the-context-of-a-node",
    "href": "manual/Graphs/index.html#capturing-the-context-of-a-node",
    "title": "Dynamic graph creation and manipulation",
    "section": "Capturing the context of a node",
    "text": "Capturing the context of a node\nIn some scenarios, knowing the relationship between nodes in the graph is not sufficient, because data stored inside those related nodes is required in the rhs function of a rule. In those cases, an extra argument to the constructor for a Rule is required (captures = true) to indicate that this rule will pass additional data from the lhs to the rhs function. Then, the lhs function should return a tuple, where the first element is still true or false (to indicate whether the rule matches a node) and the second element is a tuple of Context objects associated to the nodes being matched. If no match occurs, it is sufficient to return (false, ()), where () indicates an empty tuple. The rhs function should then be a function that takes as first argument the Context object of the node being replaced, and an additional argument for every Context object being captured on the lhs function and passed to the rhs function."
  },
  {
    "objectID": "manual/Graphs/index.html#execution-of-rules",
    "href": "manual/Graphs/index.html#execution-of-rules",
    "title": "Dynamic graph creation and manipulation",
    "section": "Execution of rules",
    "text": "Execution of rules\nRules are executed in the same order in which they are added to the graph object. Then, the lhs part of each rule is tested against all nodes of the specified type in the same order in which they were added to the graph. Similarly, the rhs part of a rule will be applied to those nodes that matched the lhs part, in the same order as in the matching.\n\nThe lhs part of all the rules are executed first and VPL will check that each node is not matched by more than rule. In case there is more than one match, an error will be generated. After all the lhs pars are executed, then the rhs parts are executed on the matched nodes. Although generating an error may seem restrictive, the reasoning for this approach is as follows:\n\nGraph rewriting is, conceptually, a parallel operation, so two rules cannot replace the same node as that would mean the result depends on the order in which the rules are executed.\nNew nodes will be generated by graph rewriting rules that could be matched by the lhs of other graph rewriting rules. To guarantee that all rules rewrite the same graph, all nodes that need to be replaced are identified before any rhs function is executed.\n\nIn essence, you need to program your model such that it does not rely on any specific order of execution of the graph rewriting rules."
  },
  {
    "objectID": "manual/Graphs/index.html#direct-access-to-nodes",
    "href": "manual/Graphs/index.html#direct-access-to-nodes",
    "title": "Dynamic graph creation and manipulation",
    "section": "Direct access to nodes",
    "text": "Direct access to nodes\nIt is possible to access nodes directly by their internal ID. This should be done carefully as the internal ID depends on the internal state of VPL and may not be reproducible across different runs, so only use it for interactive exploration of a model. It is possible to identify the internal ID of a node by using the method draw() with the default node_label method (see section on Visualization).\nThe internal ID is generated by a counter inside VPL which can be reset by using VPL.Core.resetID(). Once the ID of a node is known, it is possible to access using bracket notation [] on a Graph object or any subgraph generated with the graph construction algebra.\n\nmodule L\n    using VPL\n\n    struct N <: Node \n        val::Int\n    end\nend\nimport .L\nusing VPL\nVPL.Core.resetID()\naxiom = L.N(1) + (L.N(3), L.N(4)) + L.N(2) + (L.N(5), L.N(6))\ndata(axiom[2])\n\nThe bracket notation will return the Node object that wraps the data stored by the user. Notice how the internal ID does not match the value stored in the node, but rather the order in which the nodes were processed during the construction of the axiom. In this case that order coincides with reading the code left-to-right but that will not always be the case. If we create the Graph object that contains the axiom, we can access the node with the same syntax.\n\ngraph = Graph(axiom = axiom)\ndata(graph[2])"
  },
  {
    "objectID": "manual/Introduction/index.html#what-is-vpl",
    "href": "manual/Introduction/index.html#what-is-vpl",
    "title": "What is VPL?",
    "section": "What is VPL?",
    "text": "What is VPL?\n\nA package written in the Julia language\n\nThe API offers data structures and algorithms to help you build, simulate and visualize FSP models\n\nDevelopment is driven by the needs of our research\n\nPlant-level models where functionality is defined at the organ and plant level\n\nEmphasis on plant-plant and plant-environment interactions\nCrop systems (vertical farming, greenhouse, mono- and intercropping, perennials)"
  },
  {
    "objectID": "manual/Introduction/index.html#what-is-the-vplverse",
    "href": "manual/Introduction/index.html#what-is-the-vplverse",
    "title": "What is VPL?",
    "section": "What is the VPLverse?",
    "text": "What is the VPLverse?\n\nVPL + website + other packages\nOptional packages to help build FSP models:\n\nSky.jl to solar radiation and generate light sources for ray tracing\n\nEcophys.jl that contains modules for ecophysiological processes\n\nVPLTutorials.jl with examples and tutorials on how to use VPL\n\nA website with all the documentation and tutorials on VPLverse"
  },
  {
    "objectID": "manual/Introduction/index.html#what-vpl-will-never-be",
    "href": "manual/Introduction/index.html#what-vpl-will-never-be",
    "title": "What is VPL?",
    "section": "What VPL will never be",
    "text": "What VPL will never be\n\nA Julia implementation of other FSPM software\nA modelling language\nA standalone modelling studio/platform\nAn attempt to support every possible FSP model"
  },
  {
    "objectID": "manual/Introduction/index.html#why-not-a-standalone-studio",
    "href": "manual/Introduction/index.html#why-not-a-standalone-studio",
    "title": "What is VPL?",
    "section": "Why not a standalone studio?",
    "text": "Why not a standalone studio?\nWhen building an studio/platform you are responsible for:\n\nPlatform compatibility (Windows, Mac, Linux…)\n\nVisualization (3D rendering, graphs)\n\nInput (text editor)\n\nCode organization (projects)\n\nGraphical user interface to organize input/output (GUI)\n\nSince VPL is just a Julia package we get (most of) this for “free”\nHow do I do X in VPL = How do I do X in Julia (in most cases)"
  },
  {
    "objectID": "manual/Introduction/index.html#why-not-a-modelling-language",
    "href": "manual/Introduction/index.html#why-not-a-modelling-language",
    "title": "What is VPL?",
    "section": "Why not a modelling language?",
    "text": "Why not a modelling language?\nDomain specific languages have advantages:\n\nSuccinct and powerful in describing elaborate computations\nCan generate optimized code\n\nThe user can avoid learning technical details or even progranming\n\nAnd disadvantages:\n\nIt can be more limiting than an API-based approach\nThe code being executed is not visible to the user\n\nA new language requires its own IDE support (syntax highlighting, code completion, etc.)\n\nThe user needs to learn the domain specific language"
  },
  {
    "objectID": "manual/Introduction/index.html#what-is-julia",
    "href": "manual/Introduction/index.html#what-is-julia",
    "title": "What is VPL?",
    "section": "What is Julia?",
    "text": "What is Julia?\n\nA dynamic JIT compiled programming language\nJulia 0.0 beta released in 2012 by 4 people @ MIT\nJulia 1.0 in 2018 (stable since then)\nReads like Matlab-Python, feels like R, runs like C\nIt is very easy to integrate with R and Python, native support for C/C++"
  },
  {
    "objectID": "manual/Introduction/index.html#why-julia",
    "href": "manual/Introduction/index.html#why-julia",
    "title": "What is VPL?",
    "section": "Why Julia?",
    "text": "Why Julia?\n\nClassic dynamic languages (R, Python, Matlab)\n\nRapid development\nEasy to learn\nCode runs slow\n\nTwo language problem: Bottlenecks lowered to classic static languages (C/C++/Fortran)\n\nNeed to maintain code in two languages, plus the interface\nTo really benefit, most of the FSPM would have to be lowered\n\nJulia was designed to solve the two language problem\n\nWrite all the code in a single language\nAchieve performance by incrementally improving the code"
  },
  {
    "objectID": "manual/Introduction/index.html#vpl-overview",
    "href": "manual/Introduction/index.html#vpl-overview",
    "title": "What is VPL?",
    "section": "VPL overview",
    "text": "VPL overview\nVPL addresses four main components in FSPM:\n\nGraphs to represent the topology of the plants\n\nInspired by Relational Growth Grammars (GroIMP) but procedural\n\n\nGeometry to represent the 3D structure of the plants plus other scene elements\n\nInspired by turtle graphics and based on triangular meshes compatible with other Julia packages\n\n\nInteractive 3D visualization of the structure\n\nBased on Makie.jl (support OpenGL and WebGL)\n\nRadiation transport within the scene\n\nMulti-threaded, multi-wavelength Monte Carlo ray tracer"
  },
  {
    "objectID": "manual/Introduction/index.html#graphs",
    "href": "manual/Introduction/index.html#graphs",
    "title": "What is VPL?",
    "section": "Graphs",
    "text": "Graphs\n\nA tree graph represents topology of a plant (nodes, internodes, leaves, etc.)\nA node can store any user-defined data type (<: Node) as well as the graph itself (vars)\nEach data type has a method that defines its geometry, material and color (feed!)\nGraph edges created by a simply node algebra:\n\nPhytomer: Node() + (Bud(), Leaf()) + Internode() + Meristem()\n\nUser defines functions to implement:\n\nRelational growth rules can replace nodes by subgraphs (Rule & rewrite!)\nRelational queries can extract combinations of nodes (Query & apply)\n\nDifferent graphs can be queried/rewritten in parallel (multi-threading)"
  },
  {
    "objectID": "manual/Introduction/index.html#geometry",
    "href": "manual/Introduction/index.html#geometry",
    "title": "What is VPL?",
    "section": "Geometry",
    "text": "Geometry\n\nA Scene contains\n\n3D triangular mesh\nOptional colors (for rendering)\nOptional materials (for ray tracing)\n\nScenes are created from graphs using feed!\nIndividual elements can be added to the scene manually (add!)\nMesh constructors are provided for common shapes (cylinder, rectangle, etc.)\nMeshes can be exported/imported to/from other formats (e.g. OBJ, STL, PLY)"
  },
  {
    "objectID": "manual/Introduction/index.html#visualization",
    "href": "manual/Introduction/index.html#visualization",
    "title": "What is VPL?",
    "section": "Visualization",
    "text": "Visualization\n\nGraphs can be rendered as networks diagrams and labels can be customized\nScenes can be rendered with a simple 3D interactive engine\nAll visualization based on Makie.jl that supports OpenGL and WebGL\nSnapshots can be exported"
  },
  {
    "objectID": "manual/Introduction/index.html#ray-tracing",
    "href": "manual/Introduction/index.html#ray-tracing",
    "title": "What is VPL?",
    "section": "Ray tracing",
    "text": "Ray tracing\n\nMulti-threaded, multi-wavelength forward Monte Carlo ray tracer\nAcceleration with SAH-based Bounding Volume Hierarchy\nCommon radiation sources are available (point, directional, area, line)\nCommon materials are available (Black, Sensor, Lambertian, Modified Phong)\nUsers can add new materials and light sources (not documented yet)\nSky.jl creates light sources for diffuse and direct solar radiation\nUse instancing to approximate large canopies (grid cloner)\nCould have multiple ray tracers in the same model"
  },
  {
    "objectID": "manual/Introduction/index.html#short-term",
    "href": "manual/Introduction/index.html#short-term",
    "title": "What is VPL?",
    "section": "Short term",
    "text": "Short term\n\nAdd more tutorials and examples of models\n\nRefacor/add features to VPL\nFurther develop Ecophys.jl\n\nTechnical documentation for developers and setup VPL for collaboration\nMove rendering and raytracing to separate packages in the VPLverse"
  },
  {
    "objectID": "manual/Introduction/index.html#long-term",
    "href": "manual/Introduction/index.html#long-term",
    "title": "What is VPL?",
    "section": "Long term",
    "text": "Long term\n\nPlant internal transport via ODEs\n\nInterface with environment (soil and atmosphere)\n\nMapping 3D geometry to a 3D grid\n\nSupport PDE models for environment\n\n\nHybrid models (e.g. FSPM + MAESPA-like models)"
  },
  {
    "objectID": "manual/Julia/index.html",
    "href": "manual/Julia/index.html",
    "title": "Julia basic concepts",
    "section": "",
    "text": "This is not a tutorial or introduction to Julia, but a collection of basic concepts about Julia that are particularly useful to understand VPL. It is assumed that the reader has some experience with programming in other languages, such as Matlab, R or Python. These concepts should be complemented with general introductory material about Julia, which can be found at the official Julia website.\nJulia is a dynamic, interactive programming language, like Matlab, R or Python. Thus, it is very easy to use and learn incrementally. The language is young and well designed, with an emphasis on numerical/scientific computation although it is starting to occupy some space in areas such as data science and machine learning. It has a clear syntax and better consistency than older programming languages.\nUnlike Matlab, R or Python, Julia was designed from the beginning to be fast (as fast as statically compiled languages like C, C++ or Fortran). However, achieving this goal does require paying attention to certain aspects of the language, such as type stability and dynamic memory allocation, which are not always obvious to the user coming from other scientific dynamic languages. In the different sections below, a few basic Julia concepts are presented, first by ignoring performance considerations and focusing on syntax, and then by showing how to improve the performance of the code. Some concepts are ignored as they are not deemed relevant for the use of VPL."
  },
  {
    "objectID": "manual/Julia/index.html#functions",
    "href": "manual/Julia/index.html#functions",
    "title": "Julia basic concepts",
    "section": "Functions",
    "text": "Functions\nA function is defined with the following syntax.\n\nfunction foo(x)\n    x^2\nend\nfoo(2.0)\n\n4.0\n\n\nVery short functions can also be defined in one line\n\nfoo2(x) = x^2\n\nfoo2 (generic function with 1 method)\n\n\n\nfoo2(2.0)\n\n4.0\n\n\nFunctions can also be defined with the “\\(\\to\\)” syntax. The result can be assigned to any variable.\n\nfoo3 = x -> x^2\n\n#11 (generic function with 1 method)\n\n\n\nfoo3(2.0)\n\n4.0\n\n\nA begin - end block can be used to store a sequence of statements in multiple lines and assign them to “short function or a”\\(\\to\\) function.\n\nfoo4 = begin\n    x -> x^2\nend\n\n#13 (generic function with 1 method)\n\n\n\nfoo4(2.0)\n\n4.0\n\n\nOnce created, there is no difference among foo, foo2, foo3 and foo4.\nAnonymous functions are useful when passing a function to another function as argument. For example, the function bar below allows applying any function f to an argument x. In this case we could pass any of the variables defined above, or just create an anonymous funcion in-place.\n\nfunction bar(x, f)\n    f(x)\nend\nbar(2.0, x -> x^2)\n\n4.0"
  },
  {
    "objectID": "manual/Julia/index.html#types",
    "href": "manual/Julia/index.html#types",
    "title": "Julia basic concepts",
    "section": "Types",
    "text": "Types\nA Type in Julia is a data structure that can contain one or more fields. Types are used to keep related data together, and to select the right method implementation of a function (see below). It shares some of the properties of Classes in Object-Oriented Programming but there are also important differences.\nJulia types can be immutable or mutable.\nImmutable means that, once created, the fields of an object cannot be changed. They are defined with the following syntax:\n\nstruct Point\n  x\n  y\n  z\nend\n\n\np = Point(0.0, 0.0, 0.0)\n\nPoint(0.0, 0.0, 0.0)\n\n\n\np.x = 1.0\n\nLoadError: setfield!: immutable struct of type Point cannot be changed\n\n\nMutable means that the fields of an object can be modified after creation. The definition is similar, just needs to add the keyword mutable\n\nmutable struct mPoint\n  x\n  y\n  z\nend\n\n\nmp = mPoint(0.0, 0.0, 0.0)\n\nmPoint(0.0, 0.0, 0.0)\n\n\n\nmp.x = 1.0\nmp\n\nmPoint(1.0, 0.0, 0.0)\n\n\nWe can always check the type of an object with the function typeof\n\ntypeof(p)\n\nPoint\n\n\nIf you forget the fields of a type, try to using fieldnames in the type (not the object). It will return the name of all the fields it contains (the “:” in front of each name can be ignored)\n\nfieldnames(Point)\n\n(:x, :y, :z)\n\n\nNote that, for performance reasons, the type of each field should be annotated in the type definition as in:\n\nstruct pPoint\n  x::Float64\n  y::Float64\n  z::Float64\nend\npPoint(1.0, 2.0, 3.0)\n\npPoint(1.0, 2.0, 3.0)\n\n\nAlso, note that there are no private fields in a Julia type (like Python, unlike C++ or Java)."
  },
  {
    "objectID": "manual/Julia/index.html#methods",
    "href": "manual/Julia/index.html#methods",
    "title": "Julia basic concepts",
    "section": "Methods",
    "text": "Methods\nMethods are functions with the same name but specialized for different types.\nMethods are automatically created by specifying the type of (some of) the arguments of a function, like in the following example\n\nfunction dist(p1::pPoint, p2::pPoint)\n    dx = p1.x - p2.x\n    dy = p1.y - p2.y\n    dz = p1.z - p2.z\n    sqrt(dx^2 + dy^2 + dz^2)\nend\n\ndist (generic function with 1 method)\n\n\n\np1 = pPoint(1.0, 0.0, 0.0)\np2 = pPoint(0.0, 1.0, 0.0)\ndist(p1, p2)\n\n1.4142135623730951\n\n\nNote that this function will not work for mPoints\n\nmp1 = mPoint(1.0, 0.0, 0.0)\nmp2 = mPoint(0.0, 1.0, 0.0)\ndist(mp1, mp2)\n\nLoadError: MethodError: no method matching dist(::mPoint, ::mPoint)\n\n\nSo we need to define dist for mPoint as arguments, or use inheritance (see below)."
  },
  {
    "objectID": "manual/Julia/index.html#abstract-types",
    "href": "manual/Julia/index.html#abstract-types",
    "title": "Julia basic concepts",
    "section": "Abstract types",
    "text": "Abstract types\nTypes cannot inherit from other types.\nHowever, when multiple types share analogus functionality, it is possible to group them by “abstract types” from which they can inherit. Note that abstract types do not contain any fields, so inheritance only works for methods. “abstract types are defined by how they act” (C. Rackauckas)\nFor example, we may define an abstract type Vec3 defined as any type for which a distance (dist) can be calculated. The default implementation assumes that the type contains fields x, y and z, though inherited methods can always be overriden.\nInheritance is indicated by the “<:” syntax after the name of the type in its declaration.\n\n# Vec3 contains no data, but dist actually assumes that x, y and z are fields of any type inheriting from Vec3\nabstract type Vec3 end\nfunction dist(p1::Vec3, p2::Vec3)\n    dx = p1.x - p2.x\n    dy = p1.y - p2.y\n    dz = p1.z - p2.z\n    sqrt(dx^2 + dy^2 + dz^2)\nend\n# Like before, but inhering from Vec3\nstruct Point2 <: Vec3\n  x::Float64\n  y::Float64\n  z::Float64\nend\nmutable struct mPoint2 <: Vec3\n  x::Float64\n  y::Float64\n  z::Float64\nend\nstruct Point3 <: Vec3\n  x::Float64\n  y::Float64\nend\n\nThe method now works with Point2 and mPoint2\n\np1 = Point2(1.0, 0.0, 0.0)\np2 = Point2(0.0, 1.0, 0.0)\ndist(p1, p2)\nmp1 = mPoint2(1.0, 0.0, 0.0)\nmp2 = mPoint2(0.0, 1.0, 0.0)\ndist(mp1, mp2)\n\n1.4142135623730951\n\n\nThe method will try to run with Point3 but it will raise an error because Point3 does not have the field z.\n\np3 = Point3(1.0, 0.0)\ndist(p1, p3)\n\nLoadError: type Point3 has no field z\n\n\n\nOptional and keyword arguments\nFunctions can have optional arguments (i.e. arguments with default values) as well as keyword arguments, which are like optional arguments but you need to use their name (rather than position) to assign a value.\nAn example of a function with optional arguments:\n\nopfoo(a, b::Int = 0) = a + b\nopfoo(1)\n\n1\n\n\n\nopfoo(1,1)\n\n2\n\n\nAn example of a function with keyword arguments\n\nkwfoo(a; b::Int = 0) = a + b\nkwfoo(1)\n\n1\n\n\n\nkwfoo(1, b = 1)\n\n2"
  },
  {
    "objectID": "manual/Julia/index.html#modules",
    "href": "manual/Julia/index.html#modules",
    "title": "Julia basic concepts",
    "section": "Modules",
    "text": "Modules\nWithin a Julia session you cannot redefine Types. Also, if you assign different data to the same name, it will simply overwrite the previous data (note: these statements are simplifications of what it actually happens, but it suffices for now).\nTo avoid name clashes, Julia allows collecting functions, methods, types and abstract types into Modules. Every Julia package includes at least one module.\nA module allows exporting a subset of the the names defined inside of it:\n\nmodule Mod\n\nexport fooz\n\nfooz(x) = abs(x)\n\nstruct bar\n   data\nend\n\nend\n\nMain.Mod\n\n\nIn order to use a module the using command must be used (the . is required and indicates that the module was defined in the current scoppe, as modules can be nested).\n\nusing .Mod\n\nExportednames can be used directly\n\nfooz(-1)\n\n1\n\n\nUnexported names can still be retrieved, but must be qualified by the module name.\n\nb = Mod.fooz(-1.0)\n\n1.0"
  },
  {
    "objectID": "manual/Julia/index.html#adding-methods-to-existing-functions",
    "href": "manual/Julia/index.html#adding-methods-to-existing-functions",
    "title": "Julia basic concepts",
    "section": "Adding methods to existing functions",
    "text": "Adding methods to existing functions\nIf a function is defined inside a module (e.g., a Julia package) we can add methods to that function by accessing it through the module name. Let’s define a function abs_dist that calculates the Manhattan (as opposed to Euclidean) distance between two points. We will put it inside a module called Funs to emulate a Julia package.\n\nmodule Funs\n  export manhattan\n  function manhattan(p1, p2)\n      dx = p1.x - p2.x\n      dy = p1.y - p2.y\n      dz = p1.z - p2.z\n      abs(dx + dy + dz)\n  end\nend\nusing .Funs\nmanhattan(p1, p2)\nmanhattan(p1, p3)\n\nLoadError: type Point3 has no field z\n\n\nWe see that we have the same error as before when using p3. Let’s add methods for when one the first or second argument is a Point3 that ignores the z:\n\nFuns.manhattan(p1::Point3, p2) = abs(p1.x - p2.x + p1.y - p2.y)\nFuns.manhattan(p1, p2::Point3) = abs(p1.x - p2.x + p1.y - p2.y)\nmanhattan(p1, p3)\nmanhattan(p3, p1)\n\n0.0\n\n\nYou can find all the methods of a function by using methods() on the function name:\n\nmethods(manhattan)\n\n# 3 methods for generic function manhattan: manhattan(p1::Point3, p2) in Main at In[34]:1  manhattan(p1, p2::Point3) in Main at In[34]:2  manhattan(p1, p2) in Main.Funs at In[33]:3"
  },
  {
    "objectID": "manual/Julia/index.html#macros",
    "href": "manual/Julia/index.html#macros",
    "title": "Julia basic concepts",
    "section": "Macros",
    "text": "Macros\nA macro is a function or statement that starts with @. The details of macros are not explained here, but it is important to know that they work by modifying the code that you write inside the macro, usually to provided specific features or to achieve higher performance. That is, a macro will take the code that you write and substitute it by some new code that then gets executed.\nAn useful macro is @kwdef provided by the module Base, which allows assigning default values to the fields of a type and use the fields as keyword arguments in the constructors. This macro needs to be written before the type definition. For example, a point constructed in this manner would be:\n\nBase.@kwdef struct kwPoint\n    x::Float64 = 0.0\n    y::Float64 = 0.0\n    z::Float64 = 0.0\nend\nkwPoint()\nkwPoint(1,1,1)\nkwPoint(y = 1)\n\nkwPoint(0.0, 1.0, 0.0)"
  },
  {
    "objectID": "manual/Julia/index.html#dot-notation",
    "href": "manual/Julia/index.html#dot-notation",
    "title": "Julia basic concepts",
    "section": "Dot notation",
    "text": "Dot notation\nDot notation is a very useful feature of Julia that allows you to apply a function to each element of a vector. For example, if you want to calculate the square of each element of a vector you can do:\n\nx = [1,2,3]\ny = x.^2\n\n3-element Vector{Int64}:\n 1\n 4\n 9\n\n\nThe dot notation can be used with any function, not just mathematical functions. For example, if you want to calculate the absolute value of each element of a vector you can do:\n\nabs.(y)\n\n3-element Vector{Int64}:\n 1\n 4\n 9\n\n\nIf the operation is more complex, the ‘.’ should be used in all the steps or, alternatively, use the macro @. that does the same:\n\nabs.(y) .+ x.^3\n@. abs(y) + x^3\n\n3-element Vector{Int64}:\n  2\n 12\n 36\n\n\nThe dot notation can also be used with functions that take more than one argument, but make sure that all the arguments have the same length\n\nmin.(x, y)\nmax.(x, y)\n\n3-element Vector{Int64}:\n 1\n 4\n 9"
  },
  {
    "objectID": "manual/Julia/index.html#type-instability",
    "href": "manual/Julia/index.html#type-instability",
    "title": "Julia basic concepts",
    "section": "Type instability",
    "text": "Type instability\nAs indicated above, annotating the fields of a data type (struct or mutable struct) is required for achieve good performance. However, neither arguments of functions nor variables created through assignment require type annotation. This is because Julia uses type inference (i.e. it tries to infer the type of data to be stored in each newly created varaible) and compiles the code to machine level based on this inference. This leads to the concept of type instability: if the type of data stored in a variable changes over time, the compiler will need to accomodate for this, which results (for technical reasons beyond the scope of this document) in a loss of performance.\nHere is a classic example of type instability. The following function will add up the squares of all the values in a vector:\n\nfunction add_squares(x)\n  out = 0\n  for i in eachindex(x)\n    out += x[i]^2\n  end\n  return out\nend\n\nadd_squares (generic function with 1 method)\n\n\nIt looks innocent enough. The issue here is that out is initialized as an integer (0), but then it is assigned the result of sqrt(x), which may be a real value (e.g. 1.0), which would have to be stored as a floating point number. Because out has different types at different points in the code, the resulting code will be slower than it could be, but still correct (this is why Julia is useful for rapid code development compared to static languages like C++ or Java).\n\nadd_squares(collect(1:1000)) # type stable\nadd_squares(collect(1:1000.0)) # not type stable\n\n3.338335e8\n\n\nHow do we measure performance then? The @time macro is useful for this if dealing with a slow function. Otherwise it is better to use @btime from the BenchmarkTools package (see documentation of the package to understand why we use $).\n\nusing BenchmarkTools\nv1 = collect(1:1000)\nv2 = collect(1:1000.0)\n@btime add_squares($v1)\n@btime add_squares($v2)\n\n  136.448 ns (0 allocations: 0 bytes)\n\n\n  1.650 μs (0 allocations: 0 bytes)\n\n\n3.338335e8\n\n\nThe second code is 12 times slower than the first one. We can detect type instability by using the @code_warntype macro. This macro will print a internal representation of the code before it is compiled. The details are complex, but you just need to look for things in red (which indicate type instability).\n\n@code_warntype add_squares(v1)\n@code_warntype add_squares(v2)\n\nMethodInstance for add_squares(::\n\n\nVector{Int64})\n  from add_squares(x) in Main at In[41]:1\nArguments\n  #self#::Core.Const(add_squares)\n  x::Vector{Int64}\nLocals\n  @_3::Union{Nothing, Tuple{Int64, Int64}}\n  out::Int64\n  i::Int64\nBody::Int64\n\n\n\n1 ─ \n\n\n      (out = 0)\n\n\n\n│   %2  = Main.eachindex(x)::Base.OneTo{Int64}\n│         (@_3 = Base.iterate(%2))\n│   %4  = (@_3 === nothing)::Bool\n│   %5  = Base.not_int(%4)::Bool\n└──       goto #4 if not %5\n2 ┄ %7  = @_3::Tuple{Int64, Int64}\n│         (i = Core.getfield(%7, 1))\n│   %9  = Core.getfield(%7, 2)::Int64\n│   %10 = out::Int64\n│   %11 = Base.getindex(x, i)::Int64\n│   %12 = Core.apply_type(Base.Val, 2)::Core.Const(Val{2})\n│   %13 = (%12)()::Core.Const(Val{2}())\n│   %14 = Base.literal_pow(Main.:^, %11, %13)::Int64\n│         (out = %10 + %14)\n│         (@_3 = Base.iterate(%2, %9))\n│   %17 = (@_3 === nothing)::Bool\n│   %18 = Base.not_int(%17)::Bool\n└──       goto #4 if not %18\n3 ─       \n\n\ngoto #2\n4 ┄       return out\n\nMethodInstance for add_squares(::Vector{Float64})\n  from add_squares(x) in Main at In[41]:1\nArguments\n  #self#::Core.Const(add_squares)\n  x::Vector{Float64}\nLocals\n  @_3::Union{Nothing, Tuple{Int64, Int64}}\n  out::Union{Float64, Int64}\n  i::Int64\nBody::Union{Float64, Int64}\n1 ─       (out = 0)\n│   %2  = Main.eachindex(x)::Base.OneTo{Int64}\n│         (@_3 = Base.iterate(%2))\n│   %4  = (@_3 === nothing)::Bool\n│   %5  = Base.not_int(%4)::Bool\n└──       goto #4 if not %5\n2 ┄ %7  = @_3::Tuple{Int64, Int64}\n│         (i = Core.getfield(%7, 1))\n│   %9  = Core.getfield(%7, 2)::Int64\n│   %10 = out::Union{Float64, Int64}\n│   %11 = Base.getindex(x, i)::Float64\n│   %12 = Core.apply_type(Base.Val, 2)::Core.Const(Val{2})\n│   %13 = (%12)()::Core.Const(Val{2}())\n│   %14 = Base.literal_pow(Main.:^, %11, %13)::Float64\n│         (out = %10 + %14)\n│         (@_3 = Base.iterate(%2, %9))\n│   %17 = (@_3 === \n\n\nnothing)::Bool\n│   %18 = Base.not_int(%17)::Bool\n└──       goto #4 if not %18\n3 ─       goto #2\n4 ┄       return out\n\n\n\nHow do we fix this? We could write different methods for different types of x, but this is not very practical. Instead, we can use the zero() function combined with eltype() to initialize out with the correct type.\n\nfunction add_squares(x)\n  out = zero(eltype(x)) # Initialize out with the correct type with value of zero\n  for i in eachindex(x)\n    out += x[i]^2\n  end\n  return out\nend\n\nadd_squares (generic function with 1 method)\n\n\nYou could also initialize out to the first element of x and iterate over the rest of the elements, but this may not always possible (e.g. if x is empty or has one value only), so the logic will get more complex.\nNow the code is type stable:\n\n@code_warntype add_squares(v1)\n@code_warntype add_squares(v2)\n\nMethodInstance for add_squares(::Vector{Int64})\n  from add_squares(x) in Main at In[45]:1\nArguments\n  #self#::Core.Const(add_squares)\n  x::Vector{Int64}\nLocals\n  @_3::Union{Nothing, Tuple{Int64, Int64}}\n  out::Int64\n  i::Int64\nBody::Int64\n1 ─ %1  = Main.eltype(x)::Core.Const(Int64)\n│         (out = Main.zero(%1))\n│   %3  = Main.eachindex(x)::Base.OneTo{Int64}\n│         (@_3 = Base.iterate(%3))\n│   %5  = (@_3 === nothing)::Bool\n│   %6  = Base.not_int(%5)::Bool\n└──       goto #4 if not %6\n2 ┄ %8  = @_3::Tuple{Int64, Int64}\n│         (i = Core.getfield(%8, 1))\n│   %10 = Core.getfield(%8, 2)::Int64\n│   %11 = out::Int64\n│   %12 = Base.getindex(x, i)::Int64\n│   %13 = Core.apply_type(Base.Val, 2)::Core.Const(Val{2})\n│   %14 = (%13)()::Core.Const(Val{2}())\n│   %15 = Base.literal_pow(Main.:^, %12, %14)::Int64\n│         (out = %11 + %15)\n│         (@_3 = Base.iterate(%3, %10))\n│   %18 = (@_3 === nothing)::Bool\n│   %19 = Base.not_int(%18)::Bool\n└──       goto #4 if not %19\n3 ─       goto #2\n4 ┄       return out\n\nMethodInstance for add_squares(::Vector{Float64})\n  from add_squares(x) in Main at In[45]:1\nArguments\n  #self#::Core.Const(add_squares)\n  x::Vector{Float64}\nLocals\n  @_3::Union{Nothing, Tuple{Int64, Int64}}\n  out::Float64\n  i::Int64\nBody::Float64\n1 ─ %1  = Main.eltype(x)::Core.Const(Float64)\n│         (out = Main.zero(%1))\n│   %3  = Main.eachindex(x)::Base.OneTo{Int64}\n│         (@_3 = Base.iterate(%3))\n│   %5  = (@_3 === nothing)::Bool\n│   %6  = Base.not_int(%5)::Bool\n└──       goto #4 if not %6\n2 ┄ %8  = @_3::Tuple{Int64, Int64}\n│         (i = Core.getfield(%8, 1))\n│   %10 = Core.getfield(%8, 2)::Int64\n│   %11 = out::Float64\n│   %12 = Base.getindex(x, i)::Float64\n│   %13 = Core.apply_type(Base.Val, 2)::Core.Const(Val{2})\n│   %14 = (%13)()::Core.Const(Val{2}())\n│   %15 = Base.literal_pow(Main.:^, %12, %14)::Float64\n│         (out = %11 + %15)\n│         (@_3 = Base.iterate(%3, %10))\n│   %18 = (@_3 === nothing)::Bool\n│   %19 = Base.not_int(%18)::Bool\n└──       goto #4 if not %19\n3 ─       goto #2\n4 ┄       return out\n\n\n\nAnd the performance is more similar:\n\n@btime add_squares($v1)\n@btime add_squares($v2)\n\n  136.541 ns (0 allocations: 0 bytes)\n\n\n  812.644 ns (0 allocations: 0 bytes)\n\n\n3.338335e8"
  },
  {
    "objectID": "manual/Julia/index.html#performance-annotations",
    "href": "manual/Julia/index.html#performance-annotations",
    "title": "Julia basic concepts",
    "section": "Performance annotations",
    "text": "Performance annotations\nSometimes code can be annotated to improve performance. For example, the @simd can be used in simple loops to indicate that the loop can be vectorized inside the CPU (it allows to run simple CPU instructions on small sets of data simultaneously). The @inbounds macro can be used to indicate that the code will not access elements outside the bounds of an array.\n\nfunction add_squares(x)\n  out = zero(eltype(x)) # Initialize out with the correct type with value of zero\n  @simd for i in eachindex(x)\n    @inbounds out += x[i]^2\n  end\n  return out\nend\n@btime add_squares($v1)\n@btime add_squares($v2)\n\n  135.771 ns (0 allocations: 0 bytes)\n\n\n  54.619 ns (0 allocations: 0 bytes)\n\n\n3.338335e8\n\n\nNow we actually get faster performance for floating point number, which is related to the fact that the CPU can vectorize floating point operations more efficiently than integer operations (at least in this example). You can see the actual assembly code being generated (or an approximation of it) by using the @code_native macro. Any instruction that starts with v is a vectorized instruction. Note that sometimes Julia will automatically vectorize code without the need for the @simd but this is not always the case.\n\n@code_native add_squares(v2)\n\n    .text\n    .file   \"add_squares\"\n    \n\n\n.globl  julia_add_squares_3992          # -- Begin function julia_add_squares_3992\n    .p2align    4, 0x90\n    .type   julia_add_squares_3992,@function\njulia_add_squares_3992:                 # @julia_add_squares_3992\n; ┌ @ In[48]:1 within `add_squares`\n    .cfi_startproc\n# %bb.0:                                # %top\n    pushq   %rbp\n    .cfi_def_cfa_offset 16\n    \n\n\n.cfi_offset %rbp, -16\n    movq    %rsp, %rbp\n    .cfi_def_cfa_register %rbp\n    subq    $32, %rsp\n    vmovapd %xmm7, -16(%rbp)                # 16-byte Spill\n    vmovapd %xmm6, -32(%rbp)                # 16-byte Spill\n; │ @ In[48]:3 within `add_squares`\n; │┌ @ simdloop.jl:69 within `macro expansion`\n; ││┌ @ abstractarray.jl:285 within `eachindex`\n; │││┌ @ abstractarray.jl:116 within `axes1`\n; ││││┌ @ abstractarray.jl:95 within `axes`\n; │││││┌ @ array.jl:151 within `size`\n    movq    8(%rcx), %r8\n; ││└└└└\n; ││ @ simdloop.jl:72 within `macro expansion`\n; ││┌ @ int.jl:83 within `<`\n    testq   %r8, %r8\n; ││└\n    je  .LBB0_1\n# %bb.2:                                # %L14.lr.ph\n    movq    (%rcx), %rcx\n; ││ @ simdloop.jl:75 within `macro expansion`\n    cmpq    $16, %r8\n    jae .LBB0_4\n# %bb.3:\n    \n\n\nvxorpd  %xmm0, %xmm0, %xmm0\n    xorl    %edx, %edx\n    jmp .LBB0_7\n.LBB0_1:\n    vxorpd  %xmm0, %xmm0, %xmm0\n    jmp .LBB0_8\n.LBB0_4:                                # %vector.ph\n    movq    %r8, %rdx\n    andq    $-16, %rdx\n    \n\n\nvxorpd  %xmm0, %xmm0, %xmm0\n    xorl    %eax, %eax\n    vxorpd  %xmm1, %xmm1, %xmm1\n    vxorpd  %xmm2, %xmm2, %xmm2\n    vxorpd  %xmm3, %xmm3, %xmm3\n    .p2align    4, 0x90\n.LBB0_5:                                # %vector.body\n                                        # =>This Inner Loop Header: Depth=1\n; ││ @ simdloop.jl:77 within `macro expansion` @ In[48]:4\n; ││┌ @ array.jl:924 within `getindex`\n    vmovupd (%rcx,%rax,8), %ymm4\n    vmovupd 32(%rcx,%rax,8), %ymm5\n    vmovupd 64(%rcx,%rax,8), %ymm6\n    vmovupd 96(%rcx,%rax,8), %ymm7\n; ││└\n; ││┌ @ float.jl:383 within `+`\n    vfmadd231pd %ymm4, %ymm4, %ymm0     # ymm0 = (ymm4 * ymm4) + ymm0\n    vfmadd231pd %ymm5, %ymm5, %ymm1     # ymm1 = (ymm5 * ymm5) + ymm1\n    vfmadd231pd %ymm6, %ymm6, %ymm2     # ymm2 = (ymm6 * ymm6) + ymm2\n    vfmadd231pd %ymm7, %ymm7, %ymm3     # ymm3 = (ymm7 * ymm7) + ymm3\n; ││└\n; ││ @ simdloop.jl:78 within `macro expansion`\n; ││┌ @ int.jl:87 within `+`\n    \n\n\naddq    $16, %rax\n    cmpq    %rax, %rdx\n    jne .LBB0_5\n# %bb.6:                                # %middle.block\n; ││└\n; ││ @ simdloop.jl:75 within `macro expansion`\n    vaddpd  %ymm0, %ymm1, %ymm0\n    vaddpd  %ymm0, %ymm2, %ymm0\n    vaddpd  %ymm0, %ymm3, %ymm0\n    vextractf128    $1, %ymm0, %xmm1\n    vaddpd  %xmm1, %xmm0, %xmm0\n    vpermilpd   $1, %xmm0, %xmm1        # xmm1 = xmm0[1,0]\n    vaddsd  %xmm1, %xmm0, %xmm0\n    cmpq    %rdx, %r8\n    je  .LBB0_8\n    .p2align    4, 0x90\n.LBB0_7:                                # %L14\n                                        # =>This Inner Loop Header: Depth=1\n; ││ @ simdloop.jl:77 within `macro expansion` @ In[48]:4\n; ││┌ @ array.jl:924 within `getindex`\n    vmovsd  (%rcx,%rdx,8), %xmm1            # xmm1 = mem[0],zero\n; ││└\n; ││┌ @ float.jl:383 within `+`\n    vfmadd231sd %xmm1, %xmm1, %xmm0     # xmm0 = (xmm1 * xmm1) + xmm0\n; ││└\n; ││ @ simdloop.jl:78 within `macro expansion`\n; ││┌ @ int.jl:87 within `+`\n    \n\n\nincq    %rdx\n; ││└\n; ││ @ simdloop.jl:75 within `macro expansion`\n; ││┌ @ int.jl:83 within `<`\n    cmpq    %rdx, %r8\n; ││└\n    jne .LBB0_7\n.LBB0_8:                                # %L32\n    vmovaps -32(%rbp), %xmm6                # 16-byte Reload\n    vmovaps -16(%rbp), %xmm7                # 16-byte Reload\n; │└\n; │ @ In[48]:6 within `add_squares`\n    addq    $32, %rsp\n    popq    %rbp\n    vzeroupper\n    retq\n.Lfunc_end0:\n    .size   julia_add_squares_3992\n\n\n, .Lfunc_end0-julia_add_squares_3992\n    .cfi_endproc\n; └\n                                        # -- End function\n    .section    \".note.GNU-stack\",\"\",@progbits\n\n\nNotice how with some simple annotations and reorganizing the code to deal with type instability we were able to get a 30x speedup. Obviously this was a simple function with minimal runtime, so the speedup is not particularly useful, but this type of small functions are often the ones that are called many times in complex computations (e.g., ray tracing), so the speedup can be significant in actual applications. Whether you need to worry about performance depends on where the bottleneck is in your code.\nFor more details, see the sections of the manual on profiling and performance tips."
  },
  {
    "objectID": "manual/Julia/index.html#global-variables-and-type-instability",
    "href": "manual/Julia/index.html#global-variables-and-type-instability",
    "title": "Julia basic concepts",
    "section": "Global variables and type instability",
    "text": "Global variables and type instability\nGlobal variables are any variable defined in a module outside of a function that is accessed from within a function. Global variables are not recommended in general as they can easily introduce bugs in your code by making the logic of the program much harder to reason about. However, they can also introduce performance issues as any global variable that is not annotated with its type will lead to type instability.\nFor example, let’s say we modify the add_squares function to use a global variable (a bit odd, but it is just to illustrate the point) to enable differen options in the code.\n\nfunction add_squares(x)\n  out = zero(eltype(x))\n  if criterion > 0\n    @simd for i in eachindex(x)\n      @inbounds out += x[i]^2\n    end\n  else\n    @simd for i in eachindex(x)\n      @inbounds out -= x[i]^2\n    end\n  end\n  return out\nend\ncriterion = 1\n@code_warntype add_squares(v2)\n@btime add_squares(v2)\n\nMethodInstance for add_squares(::Vector{Float64})\n  from add_squares(x) in Main at In[50]:1\nArguments\n  #self#::Core.Const(add_squares)\n  x::Vector{Float64}\nLocals\n  out::Float64\n  @_4::Union{Nothing, Tuple{Int64, Int64}}\n  r#370::Base.OneTo{Int64}\n  i#371::Int64\n  n#372::Int64\n  i#373::Int64\n  val@_9::Float64\n  i@_10::Int64\n  @_11::Union{Nothing, Tuple{Int64, Int64}}\n  r#374::Base.OneTo{Int64}\n  i#375::Int64\n  n#376::Int64\n  i#377::Int64\n  val@_16::Float64\n  i@_17::Int64\nBody::Float64\n1 ── %1  = Main.eltype(x)::Core.Const(Float64)\n│          (out = Main.zero(%1))\n│    %3  = (Main.criterion > 0)::Any\n└───       goto #10 if not %3\n2 ── %5  = Main.eachindex(x)::Base.OneTo{Int64}\n│          (r#370 = %5)\n│    %7  = Base.simd_outer_range::Core.Const(Base.SimdLoop.simd_outer_range)\n│    %8  = (%7)(r#370)::Core.Const(0:0)\n│          (@_4 = Base.iterate(%8))\n│    %10 = (\n\n\n@_4\n\n\n::Core.Const((0, 0)) === nothing)::Core.Const(false)\n│    %11 = Base.not_int(%10)::Core.Const(true)\n└───       goto #9 if not %11\n3 ── %13 = @_4::Core.Const((0, 0))\n│          (i#371 = Core.getfield(%13, 1))\n│    %15 = Core.getfield(%13, 2)::Core.Const(0)\n│    %16 = Base.simd_inner_length::Core.Const(Base.SimdLoop.simd_inner_length)\n│    %17 = r#370::Base.OneTo{Int64}\n│    %18 = (%16)(%17, i#371::Core.Const(0))::Int64\n│          (n#372 = %18)\n│    %20 = Main.zero(n#372)::Core.Const(0)\n│    %21 = (%20 < n#372)::Bool\n└───       goto #7 if not %21\n4 ── %23 = Main.zero(n#372)::Core.Const(0)\n└───       (i#373 = %23)\n5 ┄─ %25 = (i#373 < n#372)::Bool\n└───       goto #7 if not %25\n6 ── %27 = Base.simd_index::Core.Const(Base.SimdLoop.simd_index)\n│    %28 = r#370::Base.OneTo{Int64}\n│    %29 = i#371::Core.Const(0)\n│          (i@_10 = (%27)(%28, %29, i#373))\n│          nothing\n│    %32 = out::Float64\n│    %33 = Base.getindex(x, i@_10)::Float64\n│    %34 = Core.apply_type(Base.Val, 2)::Core.Const(Val{2})\n│    %35 = (%34)()::Core.Const(Val{2}())\n│    %36 = Base.literal_pow(Main.:^, %33, %35)::Float64\n│    %37 = (%32 + %36)::Float64\n│          (out = %37)\n│          (val@_9 = %37)\n│          nothing\n│          val@_9\n│          (i#373 = i#373 + 1)\n│          $(Expr(:loopinfo, Symbol(\"julia.simdloop\"), nothing))\n└───       goto #5\n7 ┄─       (@_4 = Base.iterate(%8, %15))\n│    %46 = (@_4::Core.Const(nothing) === nothing)::Core.Const(true)\n│    %47 = Base.not_int(%46)::Core.Const(false)\n└───       goto #9 if not %47\n8 ──       Core.Const(:(goto %13))\n9 ┄─       Main.nothing\n└───       goto #18\n10 ─ %\n\n\n52 = Main.eachindex(x)::Base.OneTo{Int64}\n│          (r#374 = %52)\n│    %54 = Base.simd_outer_range::Core.Const(Base.SimdLoop.simd_outer_range)\n│    %55 = (%54)(r#374)::Core.Const(0:0)\n│          (@_11 = Base.iterate(%55))\n│    %57 = (@_11::Core.Const((0, 0)) === nothing)::Core.Const(false)\n│    %58 = Base.not_int(%57)::Core.Const(true)\n└───       goto #17 if not %58\n11 ─ %60 = @_11::Core.Const((0, 0))\n│          (i#375 = Core.getfield(%60, 1))\n│    %62 = Core.getfield(%60, 2)::Core.Const(0)\n│    %63 = Base.simd_inner_length::Core.Const(Base.SimdLoop.simd_inner_length)\n│    %64 = r#374::Base.OneTo{Int64}\n│    %65 = (%63)(%64, i#375::Core.Const(0))::Int64\n│          (n#376 = %65)\n│    %67 = Main.zero(n#376)::Core.Const(0)\n│    %68 = (%67 < n#376)::Bool\n└───       goto #15 if not %68\n12 ─ %70 = Main.zero(n#376)::Core.Const(0)\n└───       (i#377 = %70)\n13 ┄ %72 = (i#377 < n#376)::Bool\n└───       goto #15 if not %72\n14 ─ %74 = Base.simd_index::Core.Const(Base.SimdLoop.simd_index)\n│    %75 = r#374::Base.OneTo{Int64}\n│    %76 = i#375::Core.Const(0)\n│          (i@_17 = (%74)(%75, %76, i#377))\n│          nothing\n│    %79 = out::Float64\n│    %80 = Base.getindex(x, i@_17)::Float64\n│    %81 = Core.apply_type(Base.Val, 2)::Core.Const(Val{2})\n│    %82 = (%81)()::Core.Const(Val{2}())\n│    %83 = Base.literal_pow(Main.:^, %80, %82)::Float64\n│    %84 = (%79 - %83)::Float64\n│          (out = %84)\n│          (val@_16 = %84)\n│          nothing\n│          val@_16\n│          (i#377 = i#377 + 1)\n│          $(Expr(:loopinfo, Symbol(\"julia.simdloop\"), nothing))\n└───       goto #13\n15 ┄       (@_11 = Base.iterate(%55, %62))\n│    %93 = (@_11::Core.Const(nothing) === nothing)::Core.Const(true)\n│    %94 = Base.not_int(%93)::Core.Const(false)\n└───       goto #17 if not %94\n16 ─       Core.Const(:(goto %60))\n17 ┄       Main.nothing\n18 ┄       return out\n\n\n\n  94.864 ns (1 allocation: 16 bytes)\n\n\n3.338335e8\n\n\nIt is not a major hit in performance as criterion is only accessed once, but this can be a problem if the global variable is accessed many times in the code. The short term solution is to annotate the type of the global variable (but really we should be writing code without global variables). This can be frustating as once a global variable is created, you cannot annotate its type (even if it does not change!) without restarting the Julia session (unless it is inside a module).\n\nfunction add_squares(x)\n  out = zero(eltype(x))\n  if criterion2 > 0\n    @simd for i in eachindex(x)\n      @inbounds out += x[i]^2\n    end\n  else\n    @simd for i in eachindex(x)\n      @inbounds out -= x[i]^2\n    end\n  end\n  return out\nend\ncriterion2::Int64 = 1\n@code_warntype add_squares(v2)\n@btime add_squares(v2)\n\nMethodInstance for add_squares(::Vector{Float64})\n  from add_squares(x) in Main at In[51]:1\nArguments\n  #self#::Core.Const(add_squares)\n  x::Vector{Float64}\nLocals\n  out::Float64\n  @_4::Union{Nothing, Tuple{Int64, Int64}}\n  r#385::Base.OneTo{Int64}\n  i#386::Int64\n  n#387::Int64\n  i#388::Int64\n  val@_9::Float64\n  i@_10::Int64\n  @_11::Union{Nothing, Tuple{Int64, Int64}}\n  r#389::Base.OneTo{Int64}\n  i#390::Int64\n  n#391::Int64\n  i#392::Int64\n  val@_16::Float64\n  i@_17::Int64\nBody::Float64\n1 ── %1  = Main.eltype(x)::Core.Const(Float64)\n│          (out = Main.zero(%1))\n│    %3  = (Main.criterion2 > 0)::Bool\n└───       goto #10 if not %3\n2 ── %5  = Main.eachindex(x)::Base.OneTo{Int64}\n│          (r#385 = %5)\n│    %7  = Base.simd_outer_range::Core.Const(Base.SimdLoop.simd_outer_range)\n│    %8  = (%7)(r#385)::Core.Const(0:0)\n│          (@_4 = Base.iterate(%8))\n│    %10 = (@_4::Core.Const((0, 0)) === nothing)::Core.Const(false)\n│    %11 = Base.not_int(%10)::Core.Const(true)\n└───       goto #9 if not %11\n3 ── %13 = @_4::Core.Const((0, 0))\n│          (i#386 = Core.getfield(%13, 1))\n│    %15 = Core.getfield(%13, 2)::Core.Const(0)\n│    %16 = Base.simd_inner_length::Core.Const(Base.SimdLoop.simd_inner_length)\n│    %17 = r#385::Base.OneTo{Int64}\n│    %18 = (%16)(%17, i#386::Core.Const(0))::Int64\n│          (n#387 = %18)\n│    %20 = Main.zero(n#387)::Core.Const(0)\n│    %21 = (%20 < n#387)::Bool\n└───       goto #7 if not %21\n4 ── %23 = Main.zero(n#387)::Core.Const(0)\n└───       (i#388 = %23)\n5 ┄─ %25 = (i#388 < n#387)::Bool\n└───       goto #7 if not %25\n6 ── %27 = Base.simd_index::Core.Const(Base.SimdLoop.simd_index)\n│    %28 = r#385::Base.OneTo{Int64}\n│    %29 = i#386::Core.Const(0)\n│          (i@_10 = (%27)(%28, %29, i#388))\n│          nothing\n│    %32 = out::Float64\n│    %33 = Base.getindex(x, i@_10)::Float64\n│    %34 = Core.apply_type(Base.Val, 2)::Core.Const(Val{2})\n│    %35 = (%34)()::Core.Const(Val{2}())\n│    %36 = Base.literal_pow(Main.:^, %33, %35)::Float64\n│    %37 = (%32 + %36)::Float64\n│          (out = %37)\n│          (val@_9 = %37)\n│          nothing\n│          val@_9\n│          (i#388 = i#388 + 1)\n│          $(Expr(:loopinfo, Symbol(\"julia.simdloop\"), nothing))\n└───       goto #5\n7 ┄─       (@_4 = Base.iterate(%8, %15))\n│    %46 = (@_4::Core.Const(nothing) === nothing)::Core.Const(true)\n│    %47 = Base.not_int(%46)::Core.Const(false)\n└───       goto #9 if not %47\n8 ──       Core.Const(:(goto %13))\n9 ┄─       Main.nothing\n└───       goto #18\n10 ─ %52 = Main.eachindex(x)::Base.OneTo{Int64}\n│          (r#389 = %52)\n│    %54 = Base.simd_outer_range::Core.Const(Base.SimdLoop.simd_outer_range)\n│    %55 = (%54)(r#389)::Core.Const(0:0)\n│          (@_11 = Base.iterate(%55))\n│    %57 = (@_11::Core.Const((0, 0)) === nothing)::Core.Const(false)\n│    %58 = Base.not_int(%57)::Core.Const(true)\n└───       goto #17 if not %58\n11 ─ %60 = @_11::Core.Const((0, 0))\n│          (i#390 = Core.getfield(%60, 1))\n│    %62 = Core.getfield(%60, 2)::Core.Const(0)\n│    %63 = Base.simd_inner_length::Core.Const(Base.SimdLoop.simd_inner_length)\n│    %64 = r#389::Base.OneTo{Int64}\n│    %65 = (%63)(%64, i#390::Core.Const(0))::Int64\n│          (n#391 = %65)\n│    %67 = Main.zero(n#391)::Core.Const(0)\n│    %68 = (%67 < n#391)::Bool\n└───       goto #15 if not %68\n12 ─ %70 = Main.zero(n#391)::Core.Const(0)\n└───       (i#392 = %70)\n13 ┄ %72 = (i#392 < n#391)::Bool\n└───       goto #15 if not %72\n14 ─ %74 = Base.simd_index::Core.Const(Base.SimdLoop.simd_index)\n│    %75 = r#389::Base.OneTo{Int64}\n│    %76 = i#390::Core.Const(0)\n│          (i@_17 = (%74)(%75, %76, i#392))\n│          nothing\n│    %79 = out::Float64\n│    %80 = Base.getindex(x, i@_17)::Float64\n│    %81 = Core.apply_type(Base.Val, 2)::Core.Const(Val{2})\n│    %82 = (%81)()::Core.Const(Val{2}())\n│    %83 = Base.literal_pow(Main.:^, %80, %82)::Float64\n│    %84 = (%79 - %83)::Float64\n│          (out = %84)\n│          (val@_16 = %84)\n│          nothing\n│          val@_16\n│          (i#392 = i#392 + 1)\n│          $(Expr(:loopinfo, Symbol(\"julia.simdloop\"), nothing))\n└───       goto #13\n15 ┄       (@_11 = Base.iterate(%55, %62))\n│    %93 = (@_11::Core.Const(nothing) === nothing)::Core.Const(true)\n│    %94 = Base.not_int(%93)::Core.Const(false)\n└───       goto #17 if not %94\n16 ─       Core.Const(:(goto %60))\n17 ┄       Main.nothing\n18 ┄       return out\n\n\n\n  79.072 ns (1 allocation: 16 bytes)\n\n\n3.338335e8"
  },
  {
    "objectID": "manual/RayTracer/index.html",
    "href": "manual/RayTracer/index.html",
    "title": "Ray tracing distribution of irradiance",
    "section": "",
    "text": "Basics of ray tracing\nRussian roulette\nRTSettings()\nRaytracer()\ntrace()!\n\n\n\n\nBecause of the way directional sources are implemented (i.e., as rays emitted from upper face of the scene bounding box), it is recommended that a grid cloner is used as otherwise there will parts of the scene that will recieve no rays.\n\n\n\nSeveral types of materials are available for ray tracing, which all inherit from the Material abstract type. The materials play two roles: (i) they define the optical properties of the surface (i.e., reflectance and transmittance) for the different wavelengths being simulated, and (ii) store the radiant power absorbed by the surface. If the radiant power of a surface is needed, it is important that the material object is stored in a data structure that the user can have access to (e.g., within a node in a graph) as the raytracer will simply modify in-place (without creating a copy) the material object when a ray is absorbed. The radiant power in a material can be retrieved by applying power() to the object.\nMaterials are added to the scene at ther same time as the geometry either via feed() or add!(). It is possible to add one material per mesh (in which case all triangles within that mesh will share the same material object) or one material per triangle. In either case, VPL will take care of creating the corresponding association between the material and the triangles.\nVPL will not check that the number of wavelengths in the material matches the equivalent number in the radiation source or that the same ordering is used. This is entirely up to the user.\nThe following material types are available in VPL:\n\nBlack: A material that absorbs all the rays that hit it (equivalent to no reflectance or transmittance). It is not a realistic material but it is useful for debugging purposes or for special uses of a ray tracer (e.g., to compute ground cover).\nSensor: A material that registers the rays that hit and their radian power but it does not alter the radiant power or the direction of the rays themselves. This is useful for measuring the distribution of irradiance within canopy without disturbing the system. Note that a Sensor will not add to the scattering counter either so there is no need to modify the settings of the Russian roulette.\nLambertian: A material that describes a perfect diffuser with user-defined reflectance and transmittance per wavelength.\nPhong: A modified Phong material that implements the equations by Lafortune & Willems (1994). Reflectance is modelled as a combination of a diffuse and a specular component per wavelength.\n\n\n\n\nIn order to accelerate the tracing of rays within the 3D scene, a bounding volume hierarchy may be used by setting acceleration = BVH in the call to RayTracer(). This will create a series of nested axis-aligned bounding boxes organized as a binary tree. The purpose of this structure is to reduce the number of triangles that need to be tested against each ray (i.e., if a ray does not intersect a particular box, it will not intersect any of the triangles inside of it). This does add some additional cost due to the need to test the intersection of rays against the bounding boxes, but ideally this is much less than the cost of testing against all the excluded triangles.\nThe tree is constructed by recursively splitting each box into two halves and allocating the different triangles in the mesh to the corresponding boxes. Two rules are available for splitting the boxes, which must also be specified in the call to RayTracer():\n\nrule = AvgSplit(N, L): It splits each node along the longest axis at the average coordinate of the triangles in the node. The splitting is repeated until the number of triangles in a node is lessor equal than N or the total number of recursive splits (i.e., the depth of the binary tree) reaches L.\nrule = SAH{K}(N, L): It splits each node using the Surface Area Heuristic that defines the expected computation of ray tracing a splitted node versus not doing it. This method computes the cost of splitting each box along each of its three axes at different positions given by the value K. When K = 1 the split occurs at the median of the triangles in the box. For K > 1 the splits occur at different quantiles of the triangles in the box. The splitting is repeated until the number of triangles in a node is lessor equal than N or the total number of recursive splits reaches L or the cost of splitting a node exceeds the cost of not splitting it.\n\nFor debugging purposes (or for very small scenes), the user may also specify acceleration = Naive which will basically not implement any acceleration structured and all rays will be tested against all triangles.\nThe acceleration structure is created from a Scene object via the accelerate() function, and allows specifying the acceleration and rule arguments. This will also be responsible of translating the triangular mesh into the data structure used by the ray tracer (triangles in barycentric coordinates) as well as fitting a grid cloner to the scene (see below).\n\n\n\nThe grid cloner is used to minimize border effects when tracing rays from the sources towards the scene. The grid cloner is a form of geometric instancing where the same scene is repeated multiple times along the X, Y or Z direction. In practice, to avoid excessive memory usage, the scene is not actually replicated but rather the rays positions are modified to account to emulate the effect of the scene being repeated.\nIn order a grid cloner structure on top of a scene, the user needs to specify the number of duplications to perform in each direction (nx, ny and nz) as well as the offsets between the different copies (dx, dy and dz). The grid cloner is created from a Scene object via the accelerate() function, but the settings to control the grid cloner must be set when creating the RTSettings object.\nBy default, the grid cloner is enabled in the X and Y directions by replicating the scene three times in each direction (this means creating a grid of 7 x 7 = 49 copies of the scene including the original). The offsets between the copies are set by default to width of the scene in the X and Y directions such that there is no overlapping. The grid cloner is disabled in the Z direction by default.\nNote that whereas a grid cloner will not increase significantly the memory used by the ray tracer, it will increase ray tracing times as fewer rays will be able to leave the scene. On the other hand, a small (or no) grid cloner will create an edge effect such that only plants in the center of the scene will be able to capture the behaviour within a large canopy.\nThe actual number of copies to use will depend on plant dimension and solar angles, so a general recommendation is not possible. Regarding the offsets, these would be related to the sowing/planting pattern in the case of plant production systems on a regular grid and in many case this would mean that the copies overlap (and this would be correct) so the defaults should be overriden in most cases. Using a grid cloner should not be substitute for using a sufficient number of plants in the scene in order to capture the plant-to-plant variability, but simply to avoid edge effects."
  },
  {
    "objectID": "manual/Visualization/index.html",
    "href": "manual/Visualization/index.html",
    "title": "3D rendering",
    "section": "",
    "text": "VPL has two forms of visualization that are specific to a model: (i) a network representation of the graph via draw() and (ii) a 3D rendering of a graph or scene via render(). Both forms of visualization rely on the Makie visualization ecosystem built into Julia. Makie allows for different backends that are relevant in different context of code execution. The backends are specified with the argument backend to either of the visualization methods:\n\nbackend = \"native\": A native, desktop-based backend that requires an OpenGL enabled graphics card (based on GLMakie). This is the default backend used by VPL. It provides interactive 2D (for draw()) or 3D (for render()) visualization.\nbackend = \"web\": A web-based backend that requires a WebGL enabled web browser (based on WGLMakie). It provides interactive 2D (for draw()) or 3D (for render()) visualization.\nbackend = \"vector\": A vector graphics version of the visualization (based on CairoMakie. Different vector engines can be specified via the file argument including file = \"pdf\" (default) and file = \"svg\". It does not provide interactive visualization and it is meant for static documents (or for exporting pdf or svg versions of the visualization). This backend only works with draw(), not render()\n\nDepending on the context where the code is being executed and the backend being used, different forms of visualization will be obtained with different scenarios listed below (see section on Visualization). It is also possible to export static versions of any visualization in a wide range of formats (see section on Export visualization)."
  },
  {
    "objectID": "manual/Visualization/index.html#terminal",
    "href": "manual/Visualization/index.html#terminal",
    "title": "3D rendering",
    "section": "Terminal",
    "text": "Terminal\nThis means the code is ran from within the Julia REPL inside a terminal or command prompt (i.e., no IDE or notebook environment):\n\nUsing the native backend will trigger an external window (entitled Makie) where an interactive OpenGL visualization will be rendered. The interactivity provided allows zooming and moving the camera around the visualization.\nUsing the web backend will open a browser tab (unless there are some OS settings preventing, in which case a local IP address will be printed to the REPL and the user will have to manually input it into the browser) which an intetactive WebGL version will be rendered. The behaviour will be analogous to the natibe backend but note that this backend is still experimental (at the time of writing this documentation) so one should expect the ocasional bug.\nThe vector backend will not display any visual output in this context. One can still export the resulting figure (see section on Export visualization)."
  },
  {
    "objectID": "manual/Visualization/index.html#live-interactive-notebook",
    "href": "manual/Visualization/index.html#live-interactive-notebook",
    "title": "3D rendering",
    "section": "Live interactive notebook",
    "text": "Live interactive notebook\nThis means the code is running withn a Jupyter or Pluto notebook and they an active kernel or Julia session running in the background. Note that a notebook that is stored online will not be live unless it is hosted by a server that can run notebooks such as Binder or Google colab.\n\nThe native backend will produce an inline visualization (i.e., the visualization output shows below the code cell). This will however create a static image of the 2D or 3D with the initial camera settings (not interactive).\nThe web backend will generate the visualization output below the code cell and it will be interactive as long as the kernel or background Julia session keeps running.\nThe vector backend will display the static output next to the code cell (but only if it is using the svg engine, which is the default)."
  },
  {
    "objectID": "manual/Visualization/index.html#visual-studio-code",
    "href": "manual/Visualization/index.html#visual-studio-code",
    "title": "3D rendering",
    "section": "Visual Studio Code",
    "text": "Visual Studio Code\nIDEs that support Julia such as Visual Studio Code will generally have a plot pane where visualization output is stored. This can generally be turn off (in which case the behaviour of the IDE will be the same as running from a terminal). VPL has been tested with Visual Studio Code and the Julia extension and, if the plot pane is active, the behaviour will be equivalent to a live interative notebook:\n\nThe native backend will trigger an external window rather than in the plot pane.\nThe web backend will generate the visualization output in the plot pane and it will be interactive.\nThe vector backend will generate the static visualization output in the plot pane."
  },
  {
    "objectID": "manual/Visualization/index.html#document-generation",
    "href": "manual/Visualization/index.html#document-generation",
    "title": "3D rendering",
    "section": "Document generation",
    "text": "Document generation\nThis category includes a file that is processed by Quarto, Documenter, Weave or Literate. In all of these cases the final output will remain static while the visualization output should be generated inline (i.e., next to the code chunk). The following behavior has been observed with Quarto (other document generation methods have not been fully tested with VPL but are expected to behave similarly):\n\nFor the native backend, a static snapshot of the visualization will always be inlined. The result would be as in the inline visualization of interactive notebooks.\nThe web backend will not generate any visualization in the final document as this backend always requires interactivity.\nThe vector backend will display the static ouput as in interactive notebooks."
  },
  {
    "objectID": "manual/Visualization/index.html#on-a-headless-server",
    "href": "manual/Visualization/index.html#on-a-headless-server",
    "title": "3D rendering",
    "section": "On a headless server",
    "text": "On a headless server\nIt will be possible to use the visualization tools even when running VPL in a headless system (e.g., a high performance computing cluster). The folliowing is based on the documentation on Makie, it has not been tested with VPL:\n\nThe native backend will require X11 forwarding to render on the local machine or use VirtualGL technology.\nThe web backend will work if a Javascript serve is setup to serve the HTML content from the remote system (see here for details).\nThe vector backend will generate the images correctly but the user will have to export them to pdf or svg files."
  },
  {
    "objectID": "Sky/API.html",
    "href": "Sky/API.html",
    "title": "Virtual Plant Laboratory",
    "section": "",
    "text": "Module Sky\n# Sky.UniformSky — Type.\nUniformSky()\nModel of uniform sky diffuse radiation. See package documentation for details.\nsource\n# Sky.StandardSky — Type.\nStandardSky()\nStandard model of overcast sky diffuse radiation Moon & Spencer (1942). See package documentation for details.\nsource\n# Sky.CIE — Type.\nCIE(type::Int; θₛ = 0.0, Φₛ = 0.0, rtol = sqrt(eps(Float64)), atol = 0.0,\nmaxevals = typemax(Int))\nCreate a standard CIE model of sky diffuse radiance as described by Darula and Kittler (2002). The argument type can have values from 1 to 15 representing the 15 standard CIE models. θₛ and Φₛ are the zenith and azimuth angles of the solar disc. rtol and atol and maxevals are the relative tolerance, absolute tolerance and maximum number of function evaluation of the numerical integration algorithm. See package documentation for details.\nsource\n# Sky.radiance — Function.\nradiance(m, θ, Φ)\nCalculate the radiance per unit of solid angle at zenith (θ) and azimuth (Φ) angle normalized by diffuse radiance on the horizontal plane for a given model of diffuse radiation m. See package documentation for details.\nsource\n# Sky.radiosity — Function.\nradiosity(m, sky::SkySectors, cosine = true)\nCalculate the radiosity of each section of sky(multiplied by cos(θ) if cosine = true) normalized by diffuse radiance on the horizontal plane for a given model of radiation m. See package documentation for details.\nsource\n# Sky.equal_solid_angles — Function.\nequal_solid_angles (ntheta, nphi)\nDiscretize the sky into ntheta zenith rings and a number of sectors per ring that is proportional to sin(θ). The total number of sectors will be ntheta*nphi. Returns an object of type SkySectors. See package documentation for details.\nsource\n# Sky.equal_angle_intervals — Function.\nequal_angle_intervals(ntheta, nphi)\nDiscretize the sky into ntheta zenith rings of nphi sectors each assuming the same angle intervals for each sector (Δθ = π/2/ntheta and ΔΦ = 2π/nphi). Returns an object of type SkySectors. See package documentation for details.\nsource\n# Sky.sky — Function.\nsky(scene; Idir = 0.77, nrays_dir = 100_000, theta_dir = 0.0, phi_dir = 0.0, \n           Idif = 0.23, nrays_dif = 1_000_000, sky_model = StandardSky,\n           dome_method = equal_solid_angles, ntheta = 9, nphi = 12, \n           kwargs...)\nCreate a vector of directional radiation sources representing diffuse and direct solar radiation for a given scene.\nArguments\n\nscene: A Scene object generated by VPL.\nIdir: The direct solar radiation measured on the horizontal plane.\nnrays_dir: The number of rays to be generated for direct solar radiation.\ntheta_dir: The zenith angle of the sun position (radians).\nphi_dir: The azimuthal angle of the sun position (radians).\nIdif: The diffuse solar radiation measured on the horizontal plane.\nnrays_dif: The total number of rays to be generated diffuse solar radiation.\nsky_model: The angular distribution of diffuse irradiance (StandardSky, UniformSky or CIE).\ndome_method: The method to discretize hemisphere into patches for diffuse solar radiation (equal_solid_angles or equal_angle_intervals).\nntheta: The number of divisions along the zenith angle for dome_method.\nnphi: The number of divisions along the azimuthal angle for dome_method.\nkwargs...: Additional arguments to be used when dome_method = CIE\n\nReturns\nA vector of directional sources that can be used for ray tracing calculations in VPL. ```\nsource\n# Sky.clear_sky — Function.\nclear_sky(;lat, DOY, t, altitude = 0.0, TL = 4.0)\nCalculate global, direct and diffuse solar radiation on the horizontal plane using the clear sky model by Ineichen and Perez (2002).\nArguments\n\nlat: latitude in radians\nDOY: day of year\nf: fraction of the day (0 = sunrise, 1 = sunset)\naltitude: altitude above sea level in meters (default 0.0)\nTL: Linke turbidity coefficient (default 4.0)\n\nReturns\nA named tuple with fields:\n\nIg: global solar radiation on the horizontal plane in W/m^2\nIdir: direct solar radiation on the horizontal plane in W/m^2\nIdif: diffuse solar radiation on the horizontal plane in W/m^2\ntheta: solar zenith angle in radians\n\nReferences\nIneichen P., Perez R., A new airmass independent formulation for the Linke turbidity coefficient, Solar Energy, Vol 73(3), pp.151–157, 2002.\nsource\n# Sky.waveband_conversion — Function.\nwaveband_conversion(;Itype = :direct, waveband = :PAR, mode = :power)\nReturns the conversion coefficient from solar radiation (W/m2) to a give waveband in either power (W/m2) or photon flux (umol/m2/s). The coefficients are based on the Bird spectral model for a clear sky using June 21th in The Netherlands (latitude 52° N).\nArguments\n\nItype: The type of solar radiation, either :direct or :diffuse.\nwaveband: The waveband of interest, one of :PAR, :UV, :blue, :red, :green, or :NIR.\nmode: The physical units of the target, either :power (W/m^2) or :flux (mol/m^2/s).\n\nExamples\nwaveband_conversion(Itype = :diffuse, waveband = :UV, mode = :flux)\nwaveband_conversion(waveband = :NIR)\nsource"
  },
  {
    "objectID": "Sky/index.html",
    "href": "Sky/index.html",
    "title": "Sky.jl",
    "section": "",
    "text": "The package Sky provides a function to calculate the solar radiation on a horizontal surface (for clear skies) as a function of latitude, day of year and time of the day and for different wavebands. In addition, it can generate light sources as required by the VPL package to simulate the light distribution in a 3D scene."
  },
  {
    "objectID": "Sky/index.html#installation",
    "href": "Sky/index.html#installation",
    "title": "Sky.jl",
    "section": "Installation",
    "text": "Installation\nThe package Sky is not in the Julia registry. To install it, you can use the following command:\n\nPkg.add(url = \"https://github.com/AleMorales/Sky.jl.git\")"
  },
  {
    "objectID": "Sky/index.html#usage",
    "href": "Sky/index.html#usage",
    "title": "Sky.jl",
    "section": "Usage",
    "text": "Usage\n\nSolar radiation\nUse the clear_sky function to calculate the solar radiation on a horizontal plane as a function of day of year, latitude (in radians) and the relative solar time of the day (f = 0 is sunrise, f = 1 is sunset). The function returns the total solar radiation in W/m² as well as direct and diffuse components. For example:\n\nusing Sky\nlat = 52.0*π/180.0 # latitude in radians\nDOY = 182\nf = 0.5 # solar noon\nIg, Idir, Idif = clear_sky(lat = lat, DOY = DOY, f = f) # W/m2\n\nThe values Ig, Idir and Idif are the total, direct and diffuse solar radiation in W/m². The function waveband_conversion can be used to convert these values to specfic wavebands (UV, PAR, NIR, blue, green or red) as well as converting from W/m² to umol/m²/s, assuming particular spectra for direct and diffuse solar radiation. For example:\n\nf_PAR_dir = waveband_conversion(Itype = :direct, waveband = :PAR, mode = :flux)\nIdir_PAR = f_PAR_dir*Idir # PAR in umol/m²/s\nf_PAR_dif = waveband_conversion(Itype = :diffuse, waveband = :PAR, mode = :flux)\nIdif_PAR = f_PAR_dif*Idif # PAR in umol/m²/s\n\n\n\nLight sources for ray tracing\nOnce the direct and diffuse solar radiation in the relevant wavebands and units have been calculated, the function sky can be used to generate the light sources required by VPL to simulate the light distribution in a 3D scene. For example, a simple horizontal tile (representing soil) in VPL may be created as follows:\n\nusing VPL\nr = Rectangle(length = 2.0, width = 1.0) \nrotatey!(r, -π/2) # To put it in the XY plane\ntranslate!(r, Vec(0.0, 0.5, 0.0))\nrender(r)\n\nA 3D scene requires adding optical properties (e.g., a black material property) and linking these to the mesh (for complicated scenes see VPL documentation for examples):\n\nmaterials = [Black()]\nids = [1,1]\nscene = RTScene(mesh = r, ids = ids, materials = materials)\n\nIf we want to compute the amount of solar radiation absorbed by this tile, we need to create a series of light sources. The function sky can be used for that purpose:\n\nsources = sky(scene, \n             Idir = Idir_PAR, # Direct solar radiation from above\n             nrays_dir = 1_000_000, # Number of rays for direct solar radiation\n             Idif = Idif_PAR, # Diffuse solar radiation from above\n             nrays_dif = 10_000_000, # Total number of rays for diffuse solar radiation\n             sky_model = StandardSky, # Angular distribution of solar radiation\n             dome_method = equal_solid_angles, # Discretization of the sky dome\n             ntheta = 9, # Number of discretization steps in the zenith angle \n             nphi = 12) # Number of discretization steps in the azimuth angle\n\nThe function takes the scene as input to ensure that light sources scale with the scene. Direct solar radiation is represented by a single directiona light source that will emmit a number of rays given by nrays_dir. Diffuse solar radiation is represented by a hemispherical dome of directional light sources that will emmit a total of nrays_dif rays. The angular distribution of the diffuse solar radiation and the discretization of the sky dome can be modified via dome_method, sky_model, ntheta and nphi. See API documentation and VPL documentation for details.\nOnce the light sources are created, a ray tracing object can be generated combining all the elements above:\n\nsettings = RTSettings(parallel = true)\nrtobj = RayTracer(scene, sources, settings = settings);\n\nAnd the ray tracing can be performed by calling the trace! function:\n\ntrace!(rtobj);\n\nAs expected, the amount of solar radiation absorbed by the tile equals the total in the scene (Ig):\n\nmaterials[1].power[1]/area(r) ≈ Idir_PAR + Idif_PAR\n\nSee VPL documentation for more details and tutorials on ray tracing simulations"
  },
  {
    "objectID": "Sky/index.html#roadmap-for-future-dfevelopment",
    "href": "Sky/index.html#roadmap-for-future-dfevelopment",
    "title": "Sky.jl",
    "section": "Roadmap for future dfevelopment",
    "text": "Roadmap for future dfevelopment\nThe package is still under development. The following features are planned:\n\nCalculate fraction of direct and diffuse radiation from measurements of actual solar radiation.\nCalculate the solar radiation on a tilted surface.\nAllow for a different orientation of the 3D scene from VPL.\nMore advanced algorithms for solar radiation and spectrum (e.g., SOLPOS, Bird)."
  },
  {
    "objectID": "tutorials/advanced_raytracing/index.html",
    "href": "tutorials/advanced_raytracing/index.html",
    "title": "Advanced ray tracing",
    "section": "",
    "text": "Coming soon!"
  },
  {
    "objectID": "tutorials/algae/index.html",
    "href": "tutorials/algae/index.html",
    "title": "Algae growth",
    "section": "",
    "text": "In this first example, we learn how to create a Graph and update it dynamically with rewriting rules.\nThe model described here is based on the non-branching model of algae growth proposed by Lindermayer as one of the first L-systems.\nFirst, we need to load the VPL metapackage, which will automatically load all the packages in the VPL ecosystem.\n\nusing VPL \n\nThe rewriting rules of the L-system are as follows:\naxiom: A\nrule 1: A \\(\\rightarrow\\) AB\nrule 2: B \\(\\rightarrow\\) A\nIn VPL, this L-system would be implemented as a graph where the nodes can be of type A or B and inherit from the abstract type Node. It is advised to include type definitions in a module to avoid having to restart the Julia session whenever we want to redefine them. Because each module is an independent namespace, we need to import Node from the VPL package inside the module:\n\nmodule algae\n    import VPL: Node\n    struct A <: Node end\n    struct B <: Node end\nend\nimport .algae\n\nNote that in this very example we do not need to store any data or state inside the nodes, so types A and B do not require fields.\nThe axiom is simply defined as an instance of type of A:\n\naxiom = algae.A()\n\nMain.algae.A()\n\n\nThe rewriting rules are implemented in VPL as objects of type Rule. In VPL, a rewriting rule substitutes a node in a graph with a new node or subgraph and is therefore composed of two parts:\n\nA condition that is tested against each node in a graph to choose which nodes to rewrite.\n\nA subgraph that will replace each node selected by the condition above.\n\nIn VPL, the condition is split into two components:\n\nThe type of node to be selected (in this example that would be A or B).\n\nA function that is applied to each node in the graph (of the specified type) to indicate whether the node should be selected or not. This function is optional (the default is to select every node of the specified type).\n\nThe replacement subgraph is specified by a function that takes as input the node selected and returns a subgraph defined as a combination of node objects. Subgraphs (which can also be used as axioms) are created by linearly combining objects that inherit from Node. The operation + implies a linear relationship between two nodes and [] indicates branching.\nThe implementation of the two rules of algae growth model in VPL is as follows:\n\nrule1 = Rule(algae.A, rhs = x -> algae.A() + algae.B())\nrule2 = Rule(algae.B, rhs = x -> algae.A())\n\nRule replacing nodes of type Main.algae.B without context capturing.\n\n\nNote that in each case, the argument rhs is being assigned an anonymous (aka lambda) function. This is a function without a name that is defined directly in the assigment to the argument. That is, the Julia expression x -> A() + B() is equivalent to the following function definition:\n\nfunction rule_1(x)\n    algae.A() + algae.B()\nend\n\nrule_1 (generic function with 1 method)\n\n\nFor simple rules (especially if the right hand side is just a line of code) it is easier to just define the right hand side of the rule with an anonymous function rather than creating a standalone function with a meaningful name. However, standalone functions are easier to debug as you can call them directly from the REPL.\nWith the axiom and rules we can now create a Graph object that represents the algae organism. The first argument is the axiom and the second is a tuple with all the rewriting rules:\n\norganism = Graph(axiom = axiom, rules = (rule1, rule2))\n\nDynamic graph with 1 nodes of types Main.algae.A and 2 rewriting rules.\n\n\nIf we apply the rewriting rules iteratively, the graph will grow, in this case representing the growth of the algae organism. The rewriting rules are applied on the graph with the function rewrite!():\n\nrewrite!(organism)\n\nSince there was only one node of type A, the only rule that was applied was rule1, so the graph should now have two nodes of types A and B, respectively. We can confirm this by drawing the graph. We do this with the function draw() which will always generate the same representation of the graph, but different options are available depending on the context where the code is executed. By default, draw() will create a new window where an interactive version of the graph will be drawn and one can zoom and pan with the mouse (in this online document a static version is shown, see Backends for details):\n\ndraw(organism)\n\n\n\n\n\n\nNotice that each node in the network representation is labelled with the type of node (A or B in this case) and a number in parenthesis. This number is a unique identifier associated to each node and it is useful for debugging purposes (this will be explained in more advanced examples).\nApplying multiple iterations of rewriting can be achieved with a simple loop:\n\nfor i in 1:4\n    rewrite!(organism)\nend\n\nANd we can verify that the graph grew as expected:\n\ndraw(organism)\n\n\n\n\n\n\nThe network is rather boring as the system is growing linearly (no branching) but it already illustrates how graphs can grow rapidly in just a few iterations. Remember that the interactive visualization allows adjusting the zoom, which is handy when graphs become large."
  },
  {
    "objectID": "tutorials/beyond_VPL/index.html",
    "href": "tutorials/beyond_VPL/index.html",
    "title": "Beyond VPL",
    "section": "",
    "text": "Coming soon!"
  },
  {
    "objectID": "tutorials/context/index.html",
    "href": "tutorials/context/index.html",
    "title": "Context sensitive rules",
    "section": "",
    "text": "Context sensitive rules\nThis examples goes back to a very simple situation: a linear sequence of 3 cells. The point of this example is to introduce relational growth rules and context capturing.\nA relational rules matches nodes based on properties of neighbouring nodes in the graph. This requires traversing the graph, which can be done with the methods parent and children on the Context object of the current node, which return a list of Context objects for the parent or children nodes.\nIn some cases, it is not only sufficient to query the neighbours of a node but also to use properties of those neighbours in the right hand side component of the rule. This is know as “capturing the context” of the node being updated. This can be done by returning the additional nodes from the lhs component (in addition to true or false) and by accepting these additional nodes in the rhs component. In addition, we tell VPL that this rule is capturing the context with captures = true.\nIn the example below, each Cell keeps track of a state variable (which is either 0 or 1). Only the first cell has a state of 1 at the beginning. In the growth rule, we check the father of each Cell. When a Cell does not have a parent, the rule does not match, otherwise, we pass capture the parent node. In the right hand side, we replace the cell with a new cell with the state of the parent node that was captured. Note that that now, the rhs component gets a new argument, which corresponds to the context of the father node captured in the lhs.\n\nusing VPL\nstruct Cell <: Node\n    state::Int64\nend\nfunction transfer(context)\n    if hasParent(context)\n        return (true, (parent(context), ))\n    else\n        return (false, ())\n    end\nend\nrule = Rule(Cell, lhs = transfer, rhs = (context, father) -> Cell(data(father).state), captures = true)\naxiom = Cell(1) + Cell(0) + Cell(0)\npop = Graph(axiom = axiom, rules = rule)\n\nRewrite with queries to access the values\nIn the original state defined by the axiom, only the first node contains a state of 1. We can retrieve the state of each node with a query. A Query object is a like a Rule but without a right-hand side (i.e., its purpose is to return the nodes that match a particular condition). In this case, we just want to return all the Cell nodes. A Query object is created by passing the type of the node to be queried as an argument to the Query function. Then, to actually execute the query we need to use the apply function on the graph.\n\ngetCell = Query(Cell)\napply(pop, getCell)\n\nIf we rewrite the graph one we will see that a second cell now has a state of 1.\n\nrewrite!(pop)\napply(pop, getCell)\n\nAnd a second iteration results in all cells have a state of 1\n\nrewrite!(pop)\napply(pop, getCell)\n\nNote that queries may not return nodes in the same order as they were created because of how they are internally stored (and because queries are meant to return collection of nodes rather than reconstruct the topology of a graph). If we need to process nodes in a particular order, then it is best to use a traversal algorithm on the graph that follows a particular order (for example depth-first traversal with traverseDFS()). This algorithm requires a function that applies to each node in the graph. In this simple example we can just store the state of each node in a vector (unlike Rules and Queries, this function takes the actual node as argument rather than a Context object, see the documentation for more details):\n\npop  = Graph(axiom = axiom, rules = rule)\nstates = Int64[]\ntraverseDFS(pop, fun = node -> push!(states, node.state))\nstates\n\nNow the states of the nodes are in the same order as they were created:\n\nrewrite!(pop)\nstates = Int64[]\ntraverseDFS(pop, fun = node -> push!(states, node.state))\nstates"
  },
  {
    "objectID": "tutorials/forest/index.html",
    "href": "tutorials/forest/index.html",
    "title": "Forest",
    "section": "",
    "text": "In this example we extend the tree example into a forest, where each tree is described by a separate graph object and parameters driving the growth of these trees vary across individuals following a predefined distribution. This tutorial requires using the Distributions.jl package:\nThe data types, rendering methods and growth rules are the same as in the binary tree example:\nThe main difference with respect to the tree is that several of the parameters will vary per TreeTypes. Also, the location of the tree and initial orientation of the turtle will also vary. To achieve this we need to:\nThe code for elongating the internodes to simulate growth remains the same as for the binary tree example\nLet’s simulate a forest of 10 x 10 trees with a distance between (and within) rows of 2 meters. First we generate the original positions of the trees. For the position we just need to pass a Vec object with the x, y, and z coordinates of the location of each TreeTypes. The code below will generate a matrix with the coordinates:\nWe may assume that the initial orientation is uniformly distributed between 0 and 360 degrees:\nFor the growth and budbreak parameters we will assumed that they follow a LogNormal and Beta distribution, respectively. We can generate random values from these distributions using the Distributions package. For the relative growth rate:\nAnd for the budbreak parameter:\nNow we can create our forest by calling the create_tree function we defined earlier with the correct inputs per tree:\nBy vectorizing create_tree() over the different arrays, we end up with an array of trees. Each tree is a different Graph, with its own nodes, rewriting rules and variables. This avoids having to create a large graphs to include all the plants in a simulation. Below we will run a simulation, first using a sequential approach (i.e. using one core) and then using multiple cores in our computers (please check https://docs.julialang.org/en/v1/manual/multi-threading/ if the different cores are not being used as you may need to change some settings in your computer)."
  },
  {
    "objectID": "tutorials/forest/index.html#sequential-simulation",
    "href": "tutorials/forest/index.html#sequential-simulation",
    "title": "Forest",
    "section": "Sequential simulation",
    "text": "Sequential simulation\nWe can simulate the growth of each tree by applying the method simulate to each tree, creating a new version of the forest (the code below is an array comprehension)\n\nnewforest = [simulate(tree, getInternode, 2) for tree in forest];\n\nAnd we can render the forest with the function render as in the binary tree example but passing the whole forest at once\n\nrender(newforest)\n\n\n\n\nIf we iterate 4 more iterations we will start seeing the different individuals diverging in size due to the differences in growth rates\n\nnewforest = [simulate(tree, getInternode, 15) for tree in newforest];\nrender(newforest)"
  },
  {
    "objectID": "tutorials/forest/index.html#multithreaded-simulation",
    "href": "tutorials/forest/index.html#multithreaded-simulation",
    "title": "Forest",
    "section": "Multithreaded simulation",
    "text": "Multithreaded simulation\nIn the previous section, the simulation of growth was done sequentially, one tree after another (since the growth of a tree only depends on its own parameters). However, this can also be executed in multiple threads. In this case we use an explicit loop and execute the iterations of the loop in multiple threads using the macro @threads. Note that the rendering function can also be ran in parallel (i.e. the geometry will be generated separately for each plant and the merge together):\n\nusing Base.Threads\nnewforest = deepcopy(forest)\n@threads for i in 1:length(forest)\n    newforest[i] = simulate(forest[i], getInternode, 6)\nend\nrender(newforest, parallel = true)\n\n\n\n\nAn alternative way to perform the simulation is to have an outer loop for each timestep and an internal loop over the different trees. Although this approach is not required for this simple model, most FSP models will probably need such a scheme as growth of each individual plant will depend on competition for resources with neighbouring plants. In this case, this approach would look as follows:\n\nnewforest = deepcopy(forest)\nfor step in 1:15\n    @threads for i in 1:length(newforest)\n        newforest[i] = simulate(newforest[i], getInternode, 1)\n    end\nend\nrender(newforest, parallel = true)"
  },
  {
    "objectID": "tutorials/growth_forest/index.html",
    "href": "tutorials/growth_forest/index.html",
    "title": "Growth forest",
    "section": "",
    "text": "In this example we extend the binary forest example to have more complex, time- depedent development and growth based on carbon allocation. For simplicity, the model assumes a constant relative growth rate at the plant level to compute the biomass increment. In the next example this assumptio is relaxed by a model of radiation use efficiency. When modelling growth from carbon allocation, the biomass of each organ is then translated in to an area or volume and the dimensions of the organs are updated accordingly (assuming a particular shape).\nThe following packages are needed:"
  },
  {
    "objectID": "tutorials/growth_forest/index.html#model-definition",
    "href": "tutorials/growth_forest/index.html#model-definition",
    "title": "Growth forest",
    "section": "Model definition",
    "text": "Model definition\n\nNode types\nThe data types needed to simulate the trees are given in the following module. The differences with respect to the previous example are:\n- Meristems do not produce phytomers every day\n- A relative sink strength approach is used to allocate biomass to organs\n- The geometry of the organs is updated based on the new biomass\n- Bud break probability is a function of distance to apical meristem\n\n# Data types\nmodule TreeTypes\n    using VPL\n    using Distributions\n    # Meristem\n    Base.@kwdef mutable struct Meristem <: VPL.Node \n        age::Int64 = 0   # Age of the meristem\n    end\n    # Bud\n    struct Bud <: VPL.Node end\n    # Node\n    struct Node <: VPL.Node end\n    # BudNode\n    struct BudNode <: VPL.Node end\n    # Internode (needs to be mutable to allow for changes over time)\n    Base.@kwdef mutable struct Internode <: VPL.Node\n        age::Int64 = 0         # Age of the internode\n        biomass::Float64 = 0.0 # Initial biomass\n        length::Float64 = 0.0  # Internodes\n        width::Float64  = 0.0  # Internodes\n        sink::Exponential{Float64} = Exponential(5)\n    end\n    # Leaf\n    Base.@kwdef mutable struct Leaf <: VPL.Node\n        age::Int64 = 0         # Age of the leaf\n        biomass::Float64 = 0.0 # Initial biomass\n        length::Float64 = 0.0  # Leaves\n        width::Float64 = 0.0   # Leaves\n        sink::Beta{Float64} = Beta(2,5)\n    end    \n    # Graph-level variables -> mutable because we need to modify them during growth\n    Base.@kwdef mutable struct treeparams\n        # Variables\n        biomass::Float64 = 2e-3 # Current total biomass (g)\n        # Parameters\n        RGR::Float64 = 1.0   # Relative growth rate (1/d)\n        IB0::Float64 = 1e-3  # Initial biomass of an internode (g)\n        SIW::Float64 = 0.1e6   # Specific internode weight (g/m3)\n        IS::Float64  = 15.0  # Internode shape parameter (length/width)\n        LB0::Float64 = 1e-3  # Initial biomass of a leaf\n        SLW::Float64 = 100.0 # Specific leaf weight (g/m2)\n        LS::Float64  = 3.0   # Leaf shape parameter (length/width)\n        budbreak::Float64 = 1/0.5 # Bud break probability coefficient (in 1/m) \n        plastochron::Int64 = 5 # Number of days between phytomer production \n        leaf_expansion::Float64 = 15.0 # Number of days that a leaf expands\n        phyllotaxis::Float64 = 140.0\n        leaf_angle::Float64 = 30.0\n        branch_angle::Float64 = 45.0\n    end\nend\n\nimport .TreeTypes\n\n\n\nGeometry\nThe methods for creating the geometry and color of the tree are the same as in the previous example.\n\n# Create geometry + color for the internodes\nfunction VPL.feed!(turtle::Turtle, i::TreeTypes.Internode, vars)\n    # Rotate turtle around the head to implement elliptical phyllotaxis\n    rh!(turtle, vars.phyllotaxis) \n    HollowCylinder!(turtle, length = i.length, height = i.width, width = i.width, \n                move = true, color = RGB(0.5,0.4,0.0))\n    return nothing\nend\n\n# Create geometry + color for the leaves\nfunction VPL.feed!(turtle::Turtle, l::TreeTypes.Leaf, vars)\n    # Rotate turtle around the arm for insertion angle\n    ra!(turtle, -vars.leaf_angle)\n    # Generate the leaf \n    Ellipse!(turtle, length = l.length, width = l.width, move = false, \n             color = RGB(0.2,0.6,0.2))\n    # Rotate turtle back to original direction\n    ra!(turtle, vars.leaf_angle)\n    return nothing\nend\n\n# Insertion angle for the bud nodes\nfunction VPL.feed!(turtle::Turtle, b::TreeTypes.BudNode, vars)\n    # Rotate turtle around the arm for insertion angle\n    ra!(turtle, -vars.branch_angle)\nend\n\n\n\nDevelopment\nThe meristem rule is now parameterized by the initial states of the leaves and internodes and will only be triggered every X days where X is the plastochron.\n\n# Create right side of the growth rule (parameterized by the initial states\n# of the leaves and internodes)\nfunction create_meristem_rule(vleaf, vint)\n    meristem_rule = Rule(TreeTypes.Meristem, \n                        lhs = mer -> mod(data(mer).age, vars(mer).plastochron) == 0,\n                        rhs = mer -> TreeTypes.Node() + \n                                     (TreeTypes.Bud(), \n                                     TreeTypes.Leaf(biomass = vleaf.biomass, \n                                                    length  = vleaf.length,\n                                                    width   = vleaf.width)) +\n                                     TreeTypes.Internode(biomass = vint.biomass, \n                                                         length  = vint.length,\n                                                         width   = vint.width) + \n                                     TreeTypes.Meristem())\nend\n\ncreate_meristem_rule (generic function with 1 method)\n\n\nThe bud break probability is now a function of distance to the apical meristem rather than the number of internodes. An adhoc traversal is used to compute this length of the main branch a bud belongs to (ignoring the lateral branches).\n\n# Compute the probability that a bud breaks as function of distance to the meristem\nfunction prob_break(bud)\n    # We move to parent node in the branch where the bud was created\n    node =  parent(bud)\n    # Extract the first internode\n    child = filter(x -> data(x) isa TreeTypes.Internode, children(node))[1]\n    data_child = data(child)\n    # We measure the length of the branch until we find the meristem\n    distance = 0.0\n    while !isa(data_child, TreeTypes.Meristem)\n        # If we encounter an internode, store the length and move to the next node\n        if data_child isa TreeTypes.Internode\n            distance += data_child.length\n            child = children(child)[1]\n            data_child = data(child)\n        # If we encounter a node, extract the next internode    \n        elseif data_child isa TreeTypes.Node\n                child = filter(x -> data(x) isa TreeTypes.Internode, children(child))[1]\n                data_child = data(child)\n        else\n            error(\"Should be Internode, Node or Meristem\")\n        end\n    end\n    # Compute the probability of bud break as function of distance and \n    # make stochastic decision\n    prob =  min(1.0, distance*vars(bud).budbreak)\n    return rand() < prob\nend\n\n# Branch rule parameterized by initial states of internodes\nfunction create_branch_rule(vint)\n    branch_rule = Rule(TreeTypes.Bud, \n            lhs = prob_break, \n            rhs = bud -> TreeTypes.BudNode() + \n                         TreeTypes.Internode(biomass = vint.biomass, \n                                             length  = vint.length,\n                                             width   = vint.width) +\n                         TreeTypes.Meristem())\nend\n\ncreate_branch_rule (generic function with 1 method)\n\n\n\n\nGrowth\nWe need some functions to compute the length and width of a leaf or internode from its biomass\n\nfunction leaf_dims(biomass, vars)\n    leaf_biomass = biomass\n    leaf_area    = biomass/vars.SLW\n    leaf_length  = sqrt(leaf_area*4*vars.LS/pi)\n    leaf_width   = leaf_length/vars.LS\n    return leaf_length, leaf_width\nend\n\nfunction int_dims(biomass, vars)\n    int_biomass = biomass\n    int_volume  = biomass/vars.SIW\n    int_length  = cbrt(int_volume*4*vars.IS^2/pi)\n    int_width   = int_length/vars.IS\n    return int_length, int_width\nend\n\nint_dims (generic function with 1 method)\n\n\nEach day, the total biomass of the tree is updated using a simple RGR formula and the increment of biomass is distributed across the organs proportionally to their relative sink strength (of leaves or internodes).\nThe sink strength of leaves is modelled with a beta distribution scaled to the leaf_expansion argument that determines the duration of leaf growth, whereas for the internodes it follows a negative exponential distribution. The pdf function computes the probability density of each distribution which is taken as proportional to the sink strength (the model is actually source-limited since we imposed a particular growth rate).\n\nsink_strength(leaf, vars) = leaf.age > vars.leaf_expansion ? 0.0 :  \n                            pdf(leaf.sink, leaf.age/vars.leaf_expansion)/100.0\nplot(0:1:50, x -> sink_strength(TreeTypes.Leaf(age = x), TreeTypes.treeparams()), \n     xlabel = \"Age\", ylabel = \"Sink strength\", label = \"Leaf\")\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nsink_strength(int) = pdf(int.sink, int.age)\nplot!(0:1:50, x -> sink_strength(TreeTypes.Internode(age = x)), label = \"Internode\")\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNow we need a function that updates the biomass of the tree, allocates it to the different organs and updates the dimensions of said organs. For simplicity, we create the functions leaves() and internodes() that will apply the queries to the tree required to extract said nodes:\n\nget_leaves(tree) = apply(tree, Query(TreeTypes.Leaf))\nget_internodes(tree) = apply(tree, Query(TreeTypes.Internode))\n\nget_internodes (generic function with 1 method)\n\n\nThe age of the different organs is updated every time step:\n\nfunction age!(all_leaves, all_internodes, all_meristems)\n    for leaf in all_leaves\n        leaf.age += 1\n    end\n    for int in all_internodes\n        int.age += 1\n    end\n    for mer in all_meristems\n        mer.age += 1\n    end\n    return nothing\nend\n\nage! (generic function with 1 method)\n\n\nThe daily growth is allocated to different organs proportional to their sink strength.\n\nfunction grow!(tree, all_leaves, all_internodes)\n    # Compute total biomass increment\n    tvars = vars(tree)\n    ΔB    = tvars.RGR*tvars.biomass\n    tvars.biomass += ΔB\n    # Total sink strength\n    total_sink = 0.0\n    for leaf in all_leaves\n        total_sink += sink_strength(leaf, tvars)\n    end\n    for int in all_internodes\n        total_sink += sink_strength(int)\n    end\n    # Allocate biomass to leaves and internodes\n    for leaf in all_leaves\n        leaf.biomass += ΔB*sink_strength(leaf, tvars)/total_sink\n    end\n    for int in all_internodes\n        int.biomass += ΔB*sink_strength(int)/total_sink\n    end\n    return nothing\nend\n\ngrow! (generic function with 1 method)\n\n\nFinally, we need to update the dimensions of the organs. The leaf dimensions are\n\nfunction size_leaves!(all_leaves, tvars)\n    for leaf in all_leaves\n        leaf.length, leaf.width = leaf_dims(leaf.biomass, tvars)\n    end\n    return nothing\nend\nfunction size_internodes!(all_internodes, tvars)\n    for int in all_internodes\n        int.length, int.width = int_dims(int.biomass, tvars)\n    end\n    return nothing\nend\n\nsize_internodes! (generic function with 1 method)\n\n\n\n\nDaily step\nAll the growth and developmental functions are combined together into a daily step function that updates the forest by iterating over the different trees in parallel.\n\nget_meristems(tree) = apply(tree, Query(TreeTypes.Meristem))\nfunction daily_step!(forest)\n    @threads for tree in forest\n        # Retrieve all the relevant organs\n        all_leaves = get_leaves(tree)\n        all_internodes = get_internodes(tree)\n        all_meristems = get_meristems(tree)\n        # Update the age of the organs\n        age!(all_leaves, all_internodes, all_meristems)\n        # Grow the tree\n        grow!(tree, all_leaves, all_internodes)\n        tvars = vars(tree)\n        size_leaves!(all_leaves, tvars)\n        size_internodes!(all_internodes, tvars)\n        # Developmental rules\n        rewrite!(tree)\n    end\nend\n\ndaily_step! (generic function with 1 method)\n\n\n\n\nInitialization\nThe trees are initialized in a regular grid with random values for the initial orientation and RGR:\n\nRGRs = rand(Normal(0.3,0.01), 10, 10)\nhistogram(vec(RGRs))\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\norientations = [rand()*360.0 for i = 1:2.0:20.0, j = 1:2.0:20.0]\nhistogram(vec(orientations))\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\norigins = [Vec(i,j,0) for i = 1:2.0:20.0, j = 1:2.0:20.0];\n\nThe following initalizes a tree based on the origin, orientation and RGR:\n\nfunction create_tree(origin, orientation, RGR)\n    # Initial state and parameters of the tree\n    vars = TreeTypes.treeparams(RGR = RGR)\n    # Initial states of the leaves\n    leaf_length, leaf_width = leaf_dims(vars.LB0, vars)\n    vleaf = (biomass = vars.LB0, length = leaf_length, width = leaf_width)\n    # Initial states of the internodes\n    int_length, int_width = int_dims(vars.LB0, vars)\n    vint = (biomass = vars.IB0, length = int_length, width = int_width)\n    # Growth rules\n    meristem_rule = create_meristem_rule(vleaf, vint)\n    branch_rule   = create_branch_rule(vint)\n    axiom = T(origin) + RH(orientation) +\n            TreeTypes.Internode(biomass = vint.biomass,\n                             length  = vint.length,\n                             width   = vint.width) +\n            TreeTypes.Meristem()\n    tree = Graph(axiom = axiom, rules = (meristem_rule, branch_rule), \n                 vars = vars)\n    return tree\nend\n\ncreate_tree (generic function with 1 method)"
  },
  {
    "objectID": "tutorials/growth_forest/index.html#visualization",
    "href": "tutorials/growth_forest/index.html#visualization",
    "title": "Growth forest",
    "section": "Visualization",
    "text": "Visualization\nAs in the previous example, it makes sense to visualize the forest with a soil tile beneath it. Unlike in the previous example, we will construct the soil tile using a dedicated graph and generate a Scene object which can later be merged with the rest of scene generated in daily step:\n\nBase.@kwdef struct Soil <: VPL.Node\n    length::Float64 \n    width::Float64\nend\nfunction VPL.feed!(turtle::Turtle, s::Soil, vars)\n    Rectangle!(turtle, length = s.length, width = s.width, color = RGB(255/255, 236/255, 179/255))\nend\nsoil_graph = RA(-90.0) + T(Vec(0.0, 10.0, 0.0)) + # Moves into position\n             Soil(length = 20.0, width = 20.0) # Draws the soil tile\nsoil = Scene(Graph(axiom = soil_graph));\nrender(soil, axes = false)\n\n\n\n\nAnd the following function renders the entire scene (notice that we need to use display() to force the rendering of the scene when called within a loop or a function):\n\nfunction render_forest(forest, soil)\n    scene = Scene(vec(forest)) # create scene from forest\n    scene = Scene([scene, soil]) # merges the two scenes\n    render(scene)\nend\n\nrender_forest (generic function with 1 method)"
  },
  {
    "objectID": "tutorials/growth_forest/index.html#retrieving-canopy-level-data",
    "href": "tutorials/growth_forest/index.html#retrieving-canopy-level-data",
    "title": "Growth forest",
    "section": "Retrieving canopy-level data",
    "text": "Retrieving canopy-level data\nWe may want to extract some information at the canopy level such as LAI. This is best achieved with a query:\n\nfunction get_LAI(forest)\n    LAI = 0.0\n    @threads for tree in forest\n        for leaf in get_leaves(tree)\n            LAI += leaf.length*leaf.width*pi/4.0\n        end\n    end\n    return LAI/400.0\nend\n\nget_LAI (generic function with 1 method)"
  },
  {
    "objectID": "tutorials/growth_forest/index.html#simulation",
    "href": "tutorials/growth_forest/index.html#simulation",
    "title": "Growth forest",
    "section": "Simulation",
    "text": "Simulation\nWe can now create a forest of trees on a regular grid:\n\nforest = create_tree.(origins, orientations, RGRs);\nrender_forest(forest, soil)\nfor i in 1:50\n    daily_step!(forest)\nend\nrender_forest(forest, soil)\n\n\n\n\nAnd compute the leaf area index:\n\nget_LAI(forest)\n\n0.1444666725606486"
  },
  {
    "objectID": "tutorials/meshes/index.html",
    "href": "tutorials/meshes/index.html",
    "title": "3D meshes",
    "section": "",
    "text": "Coming soon!"
  },
  {
    "objectID": "tutorials/photosynthesis_forest/index.html",
    "href": "tutorials/photosynthesis_forest/index.html",
    "title": "Photosynthesis-driven forest",
    "section": "",
    "text": "Coming soon!"
  },
  {
    "objectID": "tutorials/raytraced_forest/index.html",
    "href": "tutorials/raytraced_forest/index.html",
    "title": "Ray-traced forest of binary trees",
    "section": "",
    "text": "In this example we extend the forest growth model to include PAR interception a radiation use efficiency to compute the daily growth rate.\nThe following packages are needed:"
  },
  {
    "objectID": "tutorials/raytraced_forest/index.html#model-definition",
    "href": "tutorials/raytraced_forest/index.html#model-definition",
    "title": "Ray-traced forest of binary trees",
    "section": "Model definition",
    "text": "Model definition\n\nNode types\nThe data types needed to simulate the trees are given in the following module. The difference with respec to the previous model is that Internodes and Leaves have optical properties needed for ray tracing (they are defined as Lambertian surfaces).\n\n# Data types\nmodule TreeTypes\n    using VPL\n    using Distributions\n    # Meristem\n    Base.@kwdef mutable struct Meristem <: VPL.Node \n        age::Int64 = 0   # Age of the meristem\n    end\n    # Bud\n    struct Bud <: VPL.Node end\n    # Node\n    struct Node <: VPL.Node end\n    # BudNode\n    struct BudNode <: VPL.Node end\n    # Internode (needs to be mutable to allow for changes over time)\n    Base.@kwdef mutable struct Internode <: VPL.Node\n        age::Int64 = 0         # Age of the internode\n        biomass::Float64 = 0.0 # Initial biomass\n        length::Float64 = 0.0  # Internodes\n        width::Float64  = 0.0  # Internodes\n        sink::Exponential{Float64} = Exponential(5)\n        material::Lambertian{1} = Lambertian(τ = 0.1, ρ = 0.05) # Leaf material\n    end\n    # Leaf\n    Base.@kwdef mutable struct Leaf <: VPL.Node\n        age::Int64 = 0         # Age of the leaf\n        biomass::Float64 = 0.0 # Initial biomass\n        length::Float64 = 0.0  # Leaves\n        width::Float64 = 0.0   # Leaves\n        sink::Beta{Float64} = Beta(2,5)\n        material::Lambertian{1} = Lambertian(τ = 0.1, ρ = 0.05) # Leaf material\n    end    \n    # Graph-level variables -> mutable because we need to modify them during growth\n    Base.@kwdef mutable struct treeparams\n        # Variables\n        PAR::Float64 = 0.0   # Total PAR absorbed by the leaves on the tree (MJ)\n        biomass::Float64 = 2e-3 # Current total biomass (g)\n        # Parameters\n        RUE::Float64 = 5.0   # Radiation use efficiency (g/MJ) -> unrealistic to speed up sim\n        IB0::Float64 = 1e-3  # Initial biomass of an internode (g)\n        SIW::Float64 = 0.1e6   # Specific internode weight (g/m3)\n        IS::Float64  = 15.0  # Internode shape parameter (length/width)\n        LB0::Float64 = 1e-3  # Initial biomass of a leaf\n        SLW::Float64 = 100.0 # Specific leaf weight (g/m2)\n        LS::Float64  = 3.0   # Leaf shape parameter (length/width)\n        budbreak::Float64 = 1/0.5 # Bud break probability coefficient (in 1/m) \n        plastochron::Int64 = 5 # Number of days between phytomer production \n        leaf_expansion::Float64 = 15.0 # Number of days that a leaf expands\n        phyllotaxis::Float64 = 140.0\n        leaf_angle::Float64 = 30.0\n        branch_angle::Float64 = 45.0\n    end\nend\n\nimport .TreeTypes\n\n\n\nGeometry\nThe methods for creating the geometry and color of the tree are the same as in the previous example but include the materials for the ray tracer.\n\n# Create geometry + color for the internodes\nfunction VPL.feed!(turtle::Turtle, i::TreeTypes.Internode, vars)\n    # Rotate turtle around the head to implement elliptical phyllotaxis\n    rh!(turtle, vars.phyllotaxis) \n    HollowCylinder!(turtle, length = i.length, height = i.width, width = i.width, \n                move = true, color = RGB(0.5,0.4,0.0), material = i.material)\n    return nothing\nend\n\n# Create geometry + color for the leaves\nfunction VPL.feed!(turtle::Turtle, l::TreeTypes.Leaf, vars)\n    # Rotate turtle around the arm for insertion angle\n    ra!(turtle, -vars.leaf_angle)\n    # Generate the leaf \n    Ellipse!(turtle, length = l.length, width = l.width, move = false, \n             color = RGB(0.2,0.6,0.2), material = l.material)\n    # Rotate turtle back to original direction\n    ra!(turtle, vars.leaf_angle)\n    return nothing\nend\n\n# Insertion angle for the bud nodes\nfunction VPL.feed!(turtle::Turtle, b::TreeTypes.BudNode, vars)\n    # Rotate turtle around the arm for insertion angle\n    ra!(turtle, -vars.branch_angle)\nend\n\n\n\nDevelopment\nThe meristem rule is now parameterized by the initial states of the leaves and internodes and will only be triggered every X days where X is the plastochron.\n\n# Create right side of the growth rule (parameterized by the initial states\n# of the leaves and internodes)\nfunction create_meristem_rule(vleaf, vint)\n    meristem_rule = Rule(TreeTypes.Meristem, \n                        lhs = mer -> mod(data(mer).age, vars(mer).plastochron) == 0,\n                        rhs = mer -> TreeTypes.Node() + \n                                     (TreeTypes.Bud(), \n                                     TreeTypes.Leaf(biomass = vleaf.biomass, \n                                                    length  = vleaf.length,\n                                                    width   = vleaf.width)) +\n                                     TreeTypes.Internode(biomass = vint.biomass, \n                                                         length  = vint.length,\n                                                         width   = vint.width) + \n                                     TreeTypes.Meristem())\nend\n\nThe bud break probability is now a function of distance to the apical meristem rather than the number of internodes. An adhoc traversal is used to compute this length of the main branch a bud belongs to (ignoring the lateral branches).\n\n# Compute the probability that a bud breaks as function of distance to the meristem\nfunction prob_break(bud)\n    # We move to parent node in the branch where the bud was created\n    node =  parent(bud)\n    # Extract the first internode\n    child = filter(x -> data(x) isa TreeTypes.Internode, children(node))[1]\n    data_child = data(child)\n    # We measure the length of the branch until we find the meristem\n    distance = 0.0\n    while !isa(data_child, TreeTypes.Meristem)\n        # If we encounter an internode, store the length and move to the next node\n        if data_child isa TreeTypes.Internode\n            distance += data_child.length\n            child = children(child)[1]\n            data_child = data(child)\n        # If we encounter a node, extract the next internode    \n        elseif data_child isa TreeTypes.Node\n                child = filter(x -> data(x) isa TreeTypes.Internode, children(child))[1]\n                data_child = data(child)\n        else\n            error(\"Should be Internode, Node or Meristem\")\n        end\n    end\n    # Compute the probability of bud break as function of distance and \n    # make stochastic decision\n    prob =  min(1.0, distance*vars(bud).budbreak)\n    return rand() < prob\nend\n\n# Branch rule parameterized by initial states of internodes\nfunction create_branch_rule(vint)\n    branch_rule = Rule(TreeTypes.Bud, \n            lhs = prob_break, \n            rhs = bud -> TreeTypes.BudNode() + \n                         TreeTypes.Internode(biomass = vint.biomass, \n                                             length  = vint.length,\n                                             width   = vint.width) +\n                         TreeTypes.Meristem())\nend\n\n\n\nLight interception\nAs growth is now dependent on intercepted PAR via RUE, we now need to simulate light interception by the trees. We will use a ray-tracing approach to do so. The first step is to create a scene with the trees and the light sources. As for rendering, the scene can be created from the forest object by simply calling Scene(forest) that will generate the 3D meshes and connect them to their optical properties.\nHowever, we also want to add the soil surface as this will affect the light distribution within the scene due to reflection from the soil surface. This is similar to the customized scene that we created before for rendering, but now for the light simulation.\n\nfunction create_soil()\n    soil = Rectangle(length = 21.0, width = 21.0)\n    rotatey!(soil, π/2) # To put it in the XY plane\n    VPL.translate!(soil, Vec(0.0, 10.5, 0.0)) # Corner at (0,0,0)\n    return soil\nend\nfunction create_scene(forest)\n    # These are the trees\n    scene = Scene(vec(forest))\n    # Add a soil surface\n    soil = create_soil()\n    soil_material = Lambertian(τ = 0.0, ρ = 0.21)\n    add!(scene, mesh = soil, material = soil_material)\n    # Return the scene\n    return scene\nend\n\nGiven the scene, we can create the light sources that can approximate the solar irradiance on a given day, location and time of the day using the functions from the Sky package (see package documentation for details). Given the latitude, day of year and fraction of the day (f = 0 being sunrise and f = 1 being sunset), the function clear_sky() computes the direct and diffuse solar radiation assuming a clear sky. These values may be converted to different wavebands and units using waveband_conversion(). Finally, the collection of light sources approximating the solar irradiance distribution over the sky hemisphere is constructed with the function sky() (this last step requires the 3D scene as input in order to place the light sources adequately).\n\nfunction create_sky(;scene, lat = 52.0*π/180.0, DOY = 182)\n    # Fraction of the day and day length\n    fs = collect(0.1:0.1:0.9)\n    dec = declination(DOY)\n    DL = day_length(lat, dec)*3600\n    # Compute solar irradiance\n    temp = [clear_sky(lat = lat, DOY = DOY, f = f) for f in fs] # W/m2\n    Ig   = getindex.(temp, 1)\n    Idir = getindex.(temp, 2)\n    Idif = getindex.(temp, 3)\n    # Conversion factors to PAR for direct and diffuse irradiance\n    f_dir = waveband_conversion(Itype = :direct,  waveband = :PAR, mode = :power)\n    f_dif = waveband_conversion(Itype = :diffuse, waveband = :PAR, mode = :power)\n    # Actual irradiance per waveband\n    Idir_PAR = f_dir.*Idir\n    Idif_PAR = f_dif.*Idif\n    # Create the dome of diffuse light\n    dome = sky(scene, \n                  Idir = 0.0, # No direct solar radiation\n                  Idif = sum(Idir_PAR)/10*DL, # Daily Diffuse solar radiation\n                  nrays_dif = 1_000_000, # Total number of rays for diffuse solar radiation\n                  sky_model = StandardSky, # Angular distribution of solar radiation\n                  dome_method = equal_solid_angles, # Discretization of the sky dome\n                  ntheta = 9, # Number of discretization steps in the zenith angle \n                  nphi = 12) # Number of discretization steps in the azimuth angle\n    # Add direct sources for different times of the day\n    for I in Idir_PAR\n        push!(dome, sky(scene, Idir = I/10*DL, nrays_dir = 100_000, Idif = 0.0)[1])\n    end \n    return dome\nend\n\nThe 3D scene and the light sources are then combined into a RayTracer object, together with general settings for the ray tracing simulation chosen via RTSettings(). The most important settings refer to the Russian roulette system and the grid cloner (see section on Ray Tracing for details). The settings for the Russian roulette system include the number of times a ray will be traced deterministically (maxiter) and the probability that a ray that exceeds maxiter is terminated (pkill). The grid cloner is used to approximate an infinite canopy by replicating the scene in the different directions (nx and ny being the number of replicates in each direction along the x and y axes, respectively). It is also possible to turn on parallelization of the ray tracing simulation by setting parallel = true (currently this uses Julia’s builtin multithreading capabilities).\nIn addition RTSettings(), an acceleration structure and a splitting rule can be defined when creating the RayTracer object (see ray tracing documentation for details). The acceleration structure allows speeding up the ray tracing by avoiding testing all rays against all objects in the scene.\n\nfunction create_raytracer(scene, sources)\n    settings = RTSettings(pkill = 0.9, maxiter = 4, nx = 5, ny = 5, parallel = true)\n    RayTracer(scene, sources, settings = settings, acceleration = BVH,\n                     rule = SAH{3}(5, 10));\nend\n\nThe actual ray tracing simulation is performed by calling the trace!() method on the ray tracing object. This will trace all rays from all light sources and update the radiant power absorbed by the different surfaces in the scene inside the Material objects (see feed!() above):\n\nfunction run_raytracer!(forest; DOY = 182)\n    scene   = create_scene(forest)\n    sources = create_sky(scene = scene, DOY = DOY)\n    rtobj   = create_raytracer(scene, sources)\n    trace!(rtobj)\n    return nothing\nend\n\nThe total PAR absorbed for each tree is calculated from the material objects of the different internodes (using power() on the Material object). Note that the power() function returns three different values, one for each waveband, but they are added together as RUE is defined for total PAR.\n\n# Run the ray tracer, calculate PAR absorbed per tree and add it to the daily\n# total using general weighted quadrature formula\nfunction calculate_PAR!(forest;  DOY = 182)\n    # Reset PAR absorbed by the tree (at the start of a new day)\n    reset_PAR!(forest)\n    # Run the ray tracer to compute daily PAR absorption\n    run_raytracer!(forest, DOY = DOY)\n    # Add up PAR absorbed by each leaf within each tree\n    @threads for tree in forest\n        for l in get_leaves(tree)\n            vars(tree).PAR += power(l.material)[1]\n        end\n    end\n    return nothing\nend\n\n# Reset PAR absorbed by the tree (at the start of a new day)\nfunction reset_PAR!(forest)\n    for tree in forest\n        vars(tree).PAR = 0.0\n    end\n    return nothing\nend\n\n\n\nGrowth\nWe need some functions to compute the length and width of a leaf or internode from its biomass\n\nfunction leaf_dims(biomass, vars)\n    leaf_biomass = biomass\n    leaf_area    = biomass/vars.SLW\n    leaf_length  = sqrt(leaf_area*4*vars.LS/pi)\n    leaf_width   = leaf_length/vars.LS\n    return leaf_length, leaf_width\nend\n\nfunction int_dims(biomass, vars)\n    int_biomass = biomass\n    int_volume  = biomass/vars.SIW\n    int_length  = cbrt(int_volume*4*vars.IS^2/pi)\n    int_width   = int_length/vars.IS\n    return int_length, int_width\nend\n\nEach day, the total biomass of the tree is updated using a simple RUE formula and the increment of biomass is distributed across the organs proportionally to their relative sink strength (of leaves or internodes).\nThe sink strength of leaves is modelled with a beta distribution scaled to the leaf_expansion argument that determines the duration of leaf growth, whereas for the internodes it follows a negative exponential distribution. The pdf function computes the probability density of each distribution which is taken as proportional to the sink strength (the model is actually source-limited since we imposed a particular growth rate).\n\nsink_strength(leaf, vars) = leaf.age > vars.leaf_expansion ? 0.0 :  \n                            pdf(leaf.sink, leaf.age/vars.leaf_expansion)/100.0\nplot(0:1:50, x -> sink_strength(TreeTypes.Leaf(age = x), TreeTypes.treeparams()), \n     xlabel = \"Age\", ylabel = \"Sink strength\", label = \"Leaf\")\n\n\nsink_strength(int) = pdf(int.sink, int.age)\nplot!(0:1:50, x -> sink_strength(TreeTypes.Internode(age = x)), label = \"Internode\")\n\nNow we need a function that updates the biomass of the tree, allocates it to the different organs and updates the dimensions of said organs. For simplicity, we create the functions leaves() and internodes() that will apply the queries to the tree required to extract said nodes:\n\nget_leaves(tree) = apply(tree, Query(TreeTypes.Leaf))\nget_internodes(tree) = apply(tree, Query(TreeTypes.Internode))\n\nThe age of the different organs is updated every time step:\n\nfunction age!(all_leaves, all_internodes, all_meristems)\n    for leaf in all_leaves\n        leaf.age += 1\n    end\n    for int in all_internodes\n        int.age += 1\n    end\n    for mer in all_meristems\n        mer.age += 1\n    end\n    return nothing\nend\n\nThe daily growth is allocated to different organs proportional to their sink strength.\n\nfunction grow!(tree, all_leaves, all_internodes)\n    # Compute total biomass increment\n    tvars = vars(tree)\n    ΔB    = max(0.5, tvars.RUE*tvars.PAR/1e6) # Trick to emulate reserves in seedling\n    tvars.biomass += ΔB\n    # Total sink strength\n    total_sink = 0.0\n    for leaf in all_leaves\n        total_sink += sink_strength(leaf, tvars)\n    end\n    for int in all_internodes\n        total_sink += sink_strength(int)\n    end\n    # Allocate biomass to leaves and internodes\n    for leaf in all_leaves\n        leaf.biomass += ΔB*sink_strength(leaf, tvars)/total_sink\n    end\n    for int in all_internodes\n        int.biomass += ΔB*sink_strength(int)/total_sink\n    end\n    return nothing\nend\n\nFinally, we need to update the dimensions of the organs. The leaf dimensions are\n\nfunction size_leaves!(all_leaves, tvars)\n    for leaf in all_leaves\n        leaf.length, leaf.width = leaf_dims(leaf.biomass, tvars)\n    end\n    return nothing\nend\nfunction size_internodes!(all_internodes, tvars)\n    for int in all_internodes\n        int.length, int.width = int_dims(int.biomass, tvars)\n    end\n    return nothing\nend\n\n\n\nDaily step\nAll the growth and developmental functions are combined together into a daily step function that updates the forest by iterating over the different trees in parallel.\n\nget_meristems(tree) = apply(tree, Query(TreeTypes.Meristem))\nfunction daily_step!(forest, DOY)\n    # Compute PAR absorbed by each tree\n    calculate_PAR!(forest, DOY = DOY)\n    # Grow the trees\n    @threads for tree in forest\n        # Retrieve all the relevant organs\n        all_leaves = get_leaves(tree)\n        all_internodes = get_internodes(tree)\n        all_meristems = get_meristems(tree)\n        # Update the age of the organs\n        age!(all_leaves, all_internodes, all_meristems)\n        # Grow the tree\n        grow!(tree, all_leaves, all_internodes)\n        tvars = vars(tree)\n        size_leaves!(all_leaves, tvars)\n        size_internodes!(all_internodes, tvars)\n        # Developmental rules\n        rewrite!(tree)\n    end\nend\n\n\n\nInitialization\nThe trees are initialized on a regular grid with random values for the initial orientation and RUE:\n\nRUEs = rand(Normal(1.5,0.2), 10, 10)\nhistogram(vec(RUEs))\n\n\norientations = [rand()*360.0 for i = 1:2.0:20.0, j = 1:2.0:20.0]\nhistogram(vec(orientations))\n\n\norigins = [Vec(i,j,0) for i = 1:2.0:20.0, j = 1:2.0:20.0];\n\nThe following initalizes a tree based on the origin, orientation and RUE:\n\nfunction create_tree(origin, orientation, RUE)\n    # Initial state and parameters of the tree\n    vars = TreeTypes.treeparams(RUE = RUE)\n    # Initial states of the leaves\n    leaf_length, leaf_width = leaf_dims(vars.LB0, vars)\n    vleaf = (biomass = vars.LB0, length = leaf_length, width = leaf_width)\n    # Initial states of the internodes\n    int_length, int_width = int_dims(vars.LB0, vars)\n    vint = (biomass = vars.IB0, length = int_length, width = int_width)\n    # Growth rules\n    meristem_rule = create_meristem_rule(vleaf, vint)\n    branch_rule   = create_branch_rule(vint)\n    axiom = T(origin) + RH(orientation) +\n            TreeTypes.Internode(biomass = vint.biomass,\n                                length  = vint.length,\n                                width   = vint.width) +\n            TreeTypes.Meristem()\n    tree = Graph(axiom = axiom, rules = (meristem_rule, branch_rule), \n                 vars = vars)\n    return tree\nend"
  },
  {
    "objectID": "tutorials/raytraced_forest/index.html#visualization",
    "href": "tutorials/raytraced_forest/index.html#visualization",
    "title": "Ray-traced forest of binary trees",
    "section": "Visualization",
    "text": "Visualization\nAs in the previous example, it makes sense to visualize the forest with a soil tile beneath it. Unlike in the previous example, we will construct the soil tile using a dedicated graph and generate a Scene object which can later be merged with the rest of scene generated in daily step:\n\nBase.@kwdef struct Soil <: VPL.Node\n    length::Float64 \n    width::Float64\nend\nfunction VPL.feed!(turtle::Turtle, s::Soil, vars)\n    Rectangle!(turtle, length = s.length, width = s.width, color = RGB(255/255, 236/255, 179/255))\nend\nsoil_graph = RA(-90.0) + T(Vec(0.0, 10.0, 0.0)) + # Moves into position\n             Soil(length = 20.0, width = 20.0) # Draws the soil tile\nsoil = Scene(Graph(axiom = soil_graph));\nrender(soil, axes = false)\n\nAnd the following function renders the entire scene (notice that we need to use display() to force the rendering of the scene when called within a loop or a function):\n\nfunction render_forest(forest, soil)\n    scene = Scene(vec(forest)) # create scene from forest\n    scene = Scene([scene, soil]) # merges the two scenes\n    display(render(scene))\nend"
  },
  {
    "objectID": "tutorials/raytraced_forest/index.html#simulation",
    "href": "tutorials/raytraced_forest/index.html#simulation",
    "title": "Ray-traced forest of binary trees",
    "section": "Simulation",
    "text": "Simulation\nWe can now create a forest of trees on a regular grid:\n\nforest = create_tree.(origins, orientations, RUEs);\nrender_forest(forest, soil)\nstart = 180\nfor i in 1:50\n    println(\"Day $i\")\n    daily_step!(forest, i + start)\n    if mod(i, 5) == 0\n        render_forest(forest, soil)\n    end\nend"
  },
  {
    "objectID": "tutorials/relational_queries/index.html",
    "href": "tutorials/relational_queries/index.html",
    "title": "Relational queries",
    "section": "",
    "text": "In this example we illustrate how to test relationships among nodes inside queries. Relational queries allow to establish relationships between nodes in the graph, which generally requires a intimiate knowledge of the graph. For this reason, relational queries are inheretly complex as graphs can become complex and there may be solutions that do not require relational queries in many instances. Nevertheless, they are integral part of VPL and can sometimes be useful. As they can be hard to grasp, this tutorial will illustrate with a relatively simple graph a series of relational queries with increasing complexity with the aim that users will get a better understanding of relational queries. For this purpose, an abstract graph with several branching levels will be used, so that we can focus on the relations among the nodes without being distracted by case-specific details.\nThe graph will be composed of two types of nodes: the inner nodes (A and C) and the leaf nodes (B). Each leaf node will be identified uniquely with an index and the objective is to write queries that can identify a specific subset of the leaf nodes, without using the data stored in the nodes themselves. That is, the queries should select the right nodes based on their relationships to the rest of nodes in the graph. Note that C nodes contain a single value that may be positive or negative, whereas A nodes contain no data.\nAs usual, we start with defining the types of nodes in the graph\nWe generate the graph directly, rather than with rewriting rules. The graph has a motif that is repeated three times (with a small variation), so we can create the graph in a piecewise manner. Note how we can use the function sum to add nodes to the graph (i.e. sum(A() for i in 1:3) is equivalent to A() + A() + A())\nBy default, VPL will use as node label the type of node and the internal ID generated by VPL itself. This ID is useful if we want to extract a particular node from the graph, but it is not controlled by the user. However, the user can specialized the function node_label() to specify exactly how to label the nodes of a particular type. In this case, we want to just print A or C for nodes of type A and C, whereas for nodes of type B we want to use the ID field that was stored inside the node during the graph generation.\nTo clarify, the id argument of the function node_label() refers to the internal id generated by VPL (used by the default method for node_label(), whereas the the first argument is the data stored inside a node (in the case of B nodes, there is a field called ID that will not be modified by VPL as that is user-provided data).\nThe goal of this exercise is then to write queries that retrieve specific B nodes without using the data stored in the node in the query. That is, we have to identify nodes based on their relationships to other nodes."
  },
  {
    "objectID": "tutorials/relational_queries/index.html#all-nodes-of-type-b",
    "href": "tutorials/relational_queries/index.html#all-nodes-of-type-b",
    "title": "Relational queries",
    "section": "All nodes of type B",
    "text": "All nodes of type B\nFirst, we create the query object. In this case, there is no special condition as we want to retrieve all the nodes of type B\n\nQ1 = Query(Q.B)\n\nQuery object for nodes of type Main.Queries.B\n\n\nApplying the query to the graph returns an array with all the B nodes\n\nA1 = apply(graph, Q1)\n\n13-element Vector{Main.Queries.B}:\n Main.Queries.B(7)\n Main.Queries.B(8)\n Main.Queries.B(3)\n Main.Queries.B(10)\n Main.Queries.B(5)\n Main.Queries.B(6)\n Main.Queries.B(2)\n Main.Queries.B(12)\n Main.Queries.B(1)\n Main.Queries.B(11)\n Main.Queries.B(13)\n Main.Queries.B(9)\n Main.Queries.B(4)\n\n\nFor the remainder of this tutorial, the code will be hidden by default to allow users to try on their own."
  },
  {
    "objectID": "tutorials/relational_queries/index.html#node-containing-value-13",
    "href": "tutorials/relational_queries/index.html#node-containing-value-13",
    "title": "Relational queries",
    "section": "Node containing value 13",
    "text": "Node containing value 13\nSince the B node 13 is the leaf node of the main branch of the graph (e.g. this could be the apical meristem of the main stem of a plant), there are no rotations between the root node of the graph and this node. Therefore, the only condition require to single out this node is that it has no ancestor node of type C.\nChecking whether a node has an ancestor that meets a certain condition can be achieved with the function hasAncestor(). Similarly to the condition of the Query object, the hasAncestor() function also has a condition, in this case applied to the parent node of the node being tested, and moving upwards in the graph recursively (until reaching the root node). Note that, in order to access the object stored inside the node, we need to use the data() function, and then we can test if that object is of type C. The B node 13 is the only node for which hasAncestor() should return false:\n\n\nShow the code\nfunction Q2_fun(n)\n    check, steps = hasAncestor(n, condition = x -> data(x) isa Q.C)\n    !check\nend\n\n\nQ2_fun (generic function with 1 method)\n\n\nAs before, we just need to apply the Query object to the graph:\n\n\nShow the code\nQ2 = Query(Q.B, condition = Q2_fun)\nA2 = apply(graph, Q2)\n\n\n1-element Vector{Main.Queries.B}:\n Main.Queries.B(13)"
  },
  {
    "objectID": "tutorials/relational_queries/index.html#nodes-containing-values-1-2-and-3",
    "href": "tutorials/relational_queries/index.html#nodes-containing-values-1-2-and-3",
    "title": "Relational queries",
    "section": "Nodes containing values 1, 2 and 3",
    "text": "Nodes containing values 1, 2 and 3\nThese three nodes belong to one of the branch motifs repeated through the graph. Thus, we need to identify the specific motif they belong to and chose all the B nodes inside that motif. The motif is defined by an A node that has a C child with a negative val and parent node C with positive val. This A node should then be 2 nodes away from the root node to separate it from upper repetitions of the motif. Therefore, we need to test for two conditions, first find those nodes inside a branch motif, then retrieve the root of the branch motif (i.e., the A node described in the above) and then check the distance of that node from the root:\n\n\nShow the code\nfunction branch_motif(p)\n    data(p) isa Q.A && \n    hasDescendent(p, condition = x -> data(x) isa Q.C && data(x).val < 0.0)[1] &&\n    hasAncestor(p, condition = x -> data(x) isa Q.C && data(x).val > 0.0)[1]\nend\n\nfunction Q3_fun(n, nsteps)\n    # Condition 1\n    check, steps = hasAncestor(n, condition = branch_motif)\n    !check && return false\n    # Condition 2\n    p = parent(n, nsteps = steps)\n    check, steps = hasAncestor(p, condition = isRoot)\n    steps != nsteps && return false\n    return true\nend\n\n\nQ3_fun (generic function with 1 method)\n\n\nAnd applying the query to the object results in the required nodes:\n\n\nShow the code\nQ3 = Query(Q.B, condition = n -> Q3_fun(n, 2))\nA3 = apply(graph, Q3)\n\n\n3-element Vector{Main.Queries.B}:\n Main.Queries.B(3)\n Main.Queries.B(2)\n Main.Queries.B(1)"
  },
  {
    "objectID": "tutorials/relational_queries/index.html#node-containing-value-4",
    "href": "tutorials/relational_queries/index.html#node-containing-value-4",
    "title": "Relational queries",
    "section": "Node containing value 4",
    "text": "Node containing value 4\nThe node B with value 4 can be singled-out because there is no branching point between the root node and this node. This means that no ancestor node should have more than one children node except the root node. Remember that hasAncestor() returns two values, but we are only interested in the first value. You do not need to assign the returned object from a Julia function, you can just index directly the element to be selected from the returned tuple:\n\n\nShow the code\nfunction Q4_fun(n)\n    !hasAncestor(n, condition = x -> !isRoot(x) && length(children(x)) > 1)[1]\nend\n\n\nQ4_fun (generic function with 1 method)\n\n\nAnd applying the query to the object results in the required node:\n\n\nShow the code\nQ4 = Query(Q.B, condition = Q4_fun)\nA4 = apply(graph, Q4)\n\n\n1-element Vector{Main.Queries.B}:\n Main.Queries.B(4)"
  },
  {
    "objectID": "tutorials/relational_queries/index.html#node-containing-value-3",
    "href": "tutorials/relational_queries/index.html#node-containing-value-3",
    "title": "Relational queries",
    "section": "Node containing value 3",
    "text": "Node containing value 3\nThis node is the only B node that is four steps from the root node, which we can retrieve from the second argument returned by hasAncestor():\n\n\nShow the code\nfunction Q5_fun(n)\n    check, steps = hasAncestor(n, condition = isRoot)\n    steps == 4\nend\n\nQ5 = Query(Q.B, condition = Q5_fun)\nA5 = apply(graph, Q5)\n\n\n1-element Vector{Main.Queries.B}:\n Main.Queries.B(3)"
  },
  {
    "objectID": "tutorials/relational_queries/index.html#node-containing-value-7",
    "href": "tutorials/relational_queries/index.html#node-containing-value-7",
    "title": "Relational queries",
    "section": "Node containing value 7",
    "text": "Node containing value 7\nNode B 7 belongs to the second lateral branch motif and the second parent node is of type A. Note that we can reuse the Q3_fun from before in the condition required for this node:\n\n\nShow the code\nfunction Q6_fun(n, nA)\n    check = Q3_fun(n, nA)\n    !check && return false\n    p2 = parent(n, nsteps = 2)\n    data(p2) isa Q.A\nend\n\nQ6 = Query(Q.B, condition = n -> Q6_fun(n, 3))\nA6 = apply(graph, Q6)\n\n\n1-element Vector{Main.Queries.B}:\n Main.Queries.B(7)"
  },
  {
    "objectID": "tutorials/relational_queries/index.html#nodes-containing-values-11-and-13",
    "href": "tutorials/relational_queries/index.html#nodes-containing-values-11-and-13",
    "title": "Relational queries",
    "section": "Nodes containing values 11 and 13",
    "text": "Nodes containing values 11 and 13\nThe B nodes 11 and 13 actually have different relationships to the rest of the graph, so we just need to define two different condition functions and combine them. The condition for the B node 11 is similar to the B node 7, whereas the condition for node 13 was already constructed before, so we just need to combined them with an OR operator:\n\n\nShow the code\nQ7 = Query(Q.B, condition = n -> Q6_fun(n, 4) || Q2_fun(n))\nA7 = apply(graph, Q7)\n\n\n2-element Vector{Main.Queries.B}:\n Main.Queries.B(11)\n Main.Queries.B(13)"
  },
  {
    "objectID": "tutorials/relational_queries/index.html#nodes-containing-values-1-5-and-9",
    "href": "tutorials/relational_queries/index.html#nodes-containing-values-1-5-and-9",
    "title": "Relational queries",
    "section": "Nodes containing values 1, 5 and 9",
    "text": "Nodes containing values 1, 5 and 9\nThese nodes play the same role in the three lateral branch motifs. They are the only B nodes preceded by the sequence A C+ A. We just need to check the sequence og types of objects for the the first three parents of each B node:\n\n\nShow the code\nfunction Q8_fun(n)\n    p1 = parent(n)\n    p2 = parent(n, nsteps = 2)\n    p3 = parent(n, nsteps = 3)\n    data(p1) isa Q.A && data(p2) isa Q.C && data(p2).val > 0.0 && data(p3) isa Q.A\nend\n\nQ8 = Query(Q.B, condition = Q8_fun)\nA8 = apply(graph, Q8)\n\n\n3-element Vector{Main.Queries.B}:\n Main.Queries.B(5)\n Main.Queries.B(1)\n Main.Queries.B(9)"
  },
  {
    "objectID": "tutorials/relational_queries/index.html#nodes-contaning-values-2-6-and-10",
    "href": "tutorials/relational_queries/index.html#nodes-contaning-values-2-6-and-10",
    "title": "Relational queries",
    "section": "Nodes contaning values 2, 6 and 10",
    "text": "Nodes contaning values 2, 6 and 10\nThis exercise is similar to the previous one, but the C node has a negative val. The problem is that node 12 would also match the pattern A C- A. We can differentiate between this node and the rest by checking for a fourth ancestor node of class C:\n\n\nShow the code\nfunction Q9_fun(n)\n    p1 = parent(n)\n    p2 = parent(n, nsteps = 2)\n    p3 = parent(n, nsteps = 3)\n    p4 = parent(n, nsteps = 4)\n    data(p1) isa Q.A && data(p2) isa Q.C && data(p2).val < 0.0 && \n       data(p3) isa Q.A && data(p4) isa Q.C\nend\n\nQ9 = Query(Q.B, condition = Q9_fun)\nA9 = apply(graph, Q9)\n\n\n3-element Vector{Main.Queries.B}:\n Main.Queries.B(10)\n Main.Queries.B(6)\n Main.Queries.B(2)"
  },
  {
    "objectID": "tutorials/relational_queries/index.html#nodes-containg-values-6-7-and-8",
    "href": "tutorials/relational_queries/index.html#nodes-containg-values-6-7-and-8",
    "title": "Relational queries",
    "section": "Nodes containg values 6, 7 and 8",
    "text": "Nodes containg values 6, 7 and 8\nWe already came up with a condition to extract node 7. We can also modify the previous condition so that it only node 6. Node 8 can be identified by checking for the third parent node being of type C and being 5 nodes from the root of the graph.\nAs always, we can reusing previous conditions since they are just regular Julia functions:\n\n\nShow the code\nfunction Q10_fun(n)\n    Q6_fun(n, 3) && return true # Check node 7\n    Q9_fun(n) && hasAncestor(n, condition = isRoot)[2] == 6 && return true # Check node 6\n    hasAncestor(n, condition = isRoot)[2] == 5 && data(parent(n, nsteps = 3)) isa Q.C && return true # Check node 8 (and not 4!)\nend\n\nQ10 = Query(Q.B, condition = Q10_fun)\nA10 = apply(graph, Q10)\n\n\n3-element Vector{Main.Queries.B}:\n Main.Queries.B(7)\n Main.Queries.B(8)\n Main.Queries.B(6)"
  },
  {
    "objectID": "tutorials/relational_queries/index.html#nodes-containig-values-3-7-11-and-12",
    "href": "tutorials/relational_queries/index.html#nodes-containig-values-3-7-11-and-12",
    "title": "Relational queries",
    "section": "Nodes containig values 3, 7, 11 and 12",
    "text": "Nodes containig values 3, 7, 11 and 12\nWe already have conditions to select nodes 3, 7 and 11 so we just need a new condition for node 12 (similar to the condition for 8).\n\n\nShow the code\nfunction Q11_fun(n)\n    Q5_fun(n) && return true # 3\n    Q6_fun(n, 3) && return true # 7\n    Q6_fun(n, 4) && return true # 11\n    hasAncestor(n, condition = isRoot)[2] == 5 && data(parent(n, nsteps = 2)) isa Q.C && \n        data(parent(n, nsteps = 4)) isa Q.A && return true # 12\nend\n\nQ11 = Query(Q.B, condition = Q11_fun)\nA11 = apply(graph, Q11)\n\n\n4-element Vector{Main.Queries.B}:\n Main.Queries.B(7)\n Main.Queries.B(3)\n Main.Queries.B(12)\n Main.Queries.B(11)"
  },
  {
    "objectID": "tutorials/relational_queries/index.html#nodes-containing-values-7-and-12",
    "href": "tutorials/relational_queries/index.html#nodes-containing-values-7-and-12",
    "title": "Relational queries",
    "section": "Nodes containing values 7 and 12",
    "text": "Nodes containing values 7 and 12\nWe just need to combine the conditions for the nodes 7 and 12\n\n\nShow the code\nfunction Q12_fun(n)\n    Q6_fun(n, 3) && return true # 7\n    hasAncestor(n, condition = isRoot)[2] == 5 && data(parent(n, nsteps = 2)) isa Q.C && \n        data(parent(n, nsteps = 4)) isa Q.A && return true # 12\nend\n\nQ12 = Query(Q.B, condition = Q12_fun)\nA12 = apply(graph, Q12)\n\n\n2-element Vector{Main.Queries.B}:\n Main.Queries.B(7)\n Main.Queries.B(12)"
  },
  {
    "objectID": "tutorials/snowflakes/index.html",
    "href": "tutorials/snowflakes/index.html",
    "title": "The Koch snowflake",
    "section": "",
    "text": "In this example, we create a Koch snowflake, which is one of the earliest fractals to be described. The Koch snowflake is a closed curve composed on multiple of segments of different lengths. Starting with an equilateral triangle, each segment in the snowflake is replaced by four segments of smaller length arrange in a specific manner. Graphically, the first four iterations of the Koch snowflake construction process result in the following figures (the green segments are shown as guides but they are not part of the snowflake):\n\n\n\nFirst four iterations fo Koch snowflake fractal\n\n\nIn order to implement the construction process of a Koch snowflake in VPL we need to understand how a 3D structure can be generated from a graph of nodes. VPL uses a procedural approach to generate of structure based on the concept of turtle graphics.\nThe idea behind this approach is to imagine a turtle located in space with a particular position and orientation. The turtle then starts consuming the different nodes in the graph (following its topological structure) and generates 3D structures as defined by the user for each type of node. The consumption of a node may also include instructions to move and/or rotate the turtle, which allows to alter the relative position of the different 3D structures described by a graph.\nThe construction process of the Koch snowflake in VPL could then be represented by the following axiom and rewriting rule:\naxiom: E(L) + RU(120) + E(L) + RU(120) + E(L)\nrule: E(L) → E(L/3) + RU(-60) + E(L/3) + RU(120) + E(L/3) + RU(-60) + E(L/3)\nWhere E represent and edge of a given length (given in parenthesis) and RU represents a rotation of the turtle around the upward axis, with angle of rotation given in parenthesis in hexadecimal degrees. The rule can be visualized as follows:\n\n\n\nKoch construction rule\n\n\nNote that VPL already provides several classes for common turtle movements and rotations, so our implementation of the Koch snowflake only needs to define a class to implement the edges of the snowflake. This can be achieved as follows:\n\nusing VPL\nmodule sn\n    import VPL\n    struct E <: VPL.Node\n        length::Float64\n    end\nend\nimport .sn\n\nNote that nodes of type E need to keep track of the length as illustrated in the above. The axiom is straightforward:\n\nconst L = 1.0\naxiom = sn.E(L) + VPL.RU(120.0) + sn.E(L) + VPL.RU(120.0) + sn.E(L)\n\nVPL.Core.StaticGraph(Dict{Int64, Any}(5 => VPL.Core.GraphNode{Main.sn.E}(Main.sn.E(1.0), Set{Int64}(), 4, 5), 4 => VPL.Core.GraphNode{VPL.Geom.RU{Float64}}(VPL.Geom.RU{Float64}(120.0), Set([5]), 3, 4), 2 => VPL.Core.GraphNode{VPL.Geom.RU{Float64}}(VPL.Geom.RU{Float64}(120.0), Set([3]), 1, 2), 3 => VPL.Core.GraphNode{Main.sn.E}(Main.sn.E(1.0), Set([4]), 2, 3), 1 => VPL.Core.GraphNode{Main.sn.E}(Main.sn.E(1.0), Set([2]), missing, 1)), Dict{DataType, Set{Int64}}(VPL.Geom.RU{Float64} => Set([4, 2]), Main.sn.E => Set([5, 3, 1])), 1, 5)\n\n\nThe rule is also straightforward to implement as all the nodes of type E will be replaced in each iteration. However, we need to ensure that the length of the new edges is a calculated from the length of the edge being replaced. In order to extract the data stored in the node being replaced we can simply use the function data. In this case, the replacement function is defined and then added to the rule. This can make the code more readable but helps debugging and testing the replacement function.\n\nfunction Kochsnowflake(x)\n    L = data(x).length\n    sn.E(L/3) + RU(-60.0) + sn.E(L/3) + RU(120.0) + sn.E(L/3) + RU(-60.0) + sn.E(L/3)\n end\n rule = Rule(sn.E, rhs = Kochsnowflake)\n\nRule replacing nodes of type Main.sn.E without context capturing.\n\n\nThe model is then created by constructing the graph\n\nKoch = Graph(axiom = axiom, rules = rule)\n\nDynamic graph with 5 nodes of types VPL.Geom.RU{Float64},Main.sn.E and 1 rewriting rules.\n\n\nIn order to be able to generate a 3D structure we need to define a method for the function VPL.feed! (notice the need to prefix it with VPL. as we are going to define a method for this function). The method needs to two take two arguments, the first one is always an object of type Turtle and the second is an object of the type for which the method is defined (in this case, E).\nThe body of the method should generate the 3D structures using the geometry primitives provided by VPL and feed them to the turtle that is being passed to the method as first argument. In this case, we are going to represent the edges of the Koch snowflakes with cylinders, which can be generated with the HollowCylinder! function from VPL. Note that the feed! should return nothing, the turtle will be modified in place (hence the use of ! at the end of the function as customary in the VPL community).\nIn order to render the geometry, we need assign a color (i.e., any type of color support by the package ColorTypes.jl). In this case, we just feed a basic RGB color defined by the proportion of red, green and blue. To make the figures more appealing, we can assign random values to each channel of the color to generate random colors.\n\nfunction VPL.feed!(turtle::Turtle, e::sn.E, vars)\n    HollowCylinder!(turtle, length = e.length, width = e.length/10, \n                    height = e.length/10, move = true,\n                    color = RGB(rand(), rand(), rand()))\n    return nothing\nend\n\nNote that the argument move = true indicates that the turtle should move forward as the cylinder is generated a distance equal to the length of the cylinder. Also, the feed! method has a third argument called vars. This gives acess to the shared variables stored within the graph (such that they can be accessed by any node). In this case, we are not using this argument.\nAfter defining the method, we can now call the function render on the graph to generate a 3D interactive image of the Koch snowflake in the current state\n\nrender(Koch, axes = false)\n\n\n\n\nThis renders the initial triangle of the construction procedure of the Koch snowflake. Let’s execute the rules once to verify that we get the 2nd iteration (check the figure at the beginning of this document):\n\nrewrite!(Koch)\nrender(Koch, axes = false)\n\n\n\n\nAnd two more times\n\nfor i in 1:3\n    rewrite!(Koch)\nend\nrender(Koch, axes = false)\n\n\n\n\n\nOther snowflake fractals\nTo demonstrate the power of this approach, let’s create an alternative snowflake. We will simply invert the rotations of the turtle in the rewriting rule\n\nfunction Kochsnowflake2(x)\n   L = data(x).length\n   sn.E(L/3) + RU(60.0) + sn.E(L/3) + RU(-120.0) + sn.E(L/3) + RU(60.0) + sn.E(L/3)\nend\nrule2 = Rule(sn.E, rhs = Kochsnowflake2)\nKoch2 = Graph(axiom = axiom, rules = rule2)\n\nDynamic graph with 5 nodes of types VPL.Geom.RU{Float64},Main.sn.E and 1 rewriting rules.\n\n\nThe axiom is the same, but now the edges added by the rule will generate the edges towards the inside of the initial triangle. Let’s execute the first three iterations and render the results\n\n# First iteration\nrewrite!(Koch2)\nrender(Koch2, axes = false)\n# Second iteration\nrewrite!(Koch2)\nrender(Koch2, axes = false)\n# Third iteration\nrewrite!(Koch2)\nrender(Koch2, axes = false)\n\n\n\n\nThis is know as Koch antisnowflake. We could also easily generate a Cesàro fractal by also changing the axiom:\n\naxiomCesaro = sn.E(L) + RU(90.0) + sn.E(L) + RU(90.0) + sn.E(L) + RU(90.0) + sn.E(L)\nCesaro = Graph(axiom = axiomCesaro, rules = rule2)\nrender(Cesaro, axes = false)\n\n\n\n\nAnd, as before, let’s go through the first three iterations\n\n# First iteration\nrewrite!(Cesaro)\nrender(Cesaro, axes = false)\n# Second iteration\nrewrite!(Cesaro)\nrender(Cesaro, axes = false)\n# Third iteration\nrewrite!(Cesaro)\nrender(Cesaro, axes = false)"
  },
  {
    "objectID": "tutorials/tree/index.html",
    "href": "tutorials/tree/index.html",
    "title": "Tree",
    "section": "",
    "text": "In this example we build a 3D representation of a binary TreeTypes. Although this will not look like a real plant, this example will help introduce additional features of VPL.\nThe model requires five types of nodes:\nMeristem: These are the nodes responsible for growth of new organs in our binary TreeTypes. They contain no data or geometry (i.e. they are a point in the 3D structure).\nInternode: The result of growth of a branch, between two nodes. Internodes are represented by cylinders with a fixed width but variable length.\nNode: What is left after a meristem produces a new organ (it separates internodes). They contain no data or geometry (so also a point) but are required to keep the branching structure of the tree as well as connecting leaves.\nBud: These are dormant meristems associated to tree nodes. When they are activated, they become an active meristem that produces a branch. They contain no data or geometry but they change the orientation of the turtle.\nBudNode: The node left by a bud after it has been activated. They contain no data or geometry but they change the orientation of the turtle.\nLeaf: These are the nodes associated to leaves in the TreeTypes. They are represented by ellipses with a particular orientation and insertion angle. The insertion angle is assumed constant, but the orientation angle varies according to an elliptical phyllotaxis rule.\nIn this first simple model, only internodes grow over time according to a relative growth rate, whereas leaves are assumed to be of fixed sized determined at their creation. For simplicity, all active meristems will produce an phytomer (combination of node, internode, leaves and buds) per time step. Bud break is assumed stochastic, with a probability that increases proportional to the number of phytomers from the apical meristem (up to 1). In the following tutorials, these assumptions are replaced by more realistic models of light interception, photosynthesis, etc.\nIn order to simulate growth of the 3D binary tree, we need to define a parameter describing the relative rate at which each internode elongates in each iteration of the simulation, a coefficient to compute the probability of bud break as well as the insertion and orientation angles of the leaves. We could stored these values as global constants, but VPL offers to opportunity to store them per plant. This makes it easier to manage multiple plants in the same simulation that may belong to different species, cultivars, ecotypes or simply to simulate plant-to-plant variation. Graphs in VPL can store an object of any user-defined type that will me made accessible to graph rewriting rules and queries. For this example, we define a data type treeparams that holds the relevant parameters. We use Base.@kwdef to assign default values to all parameters and allow to assign them by name.\n\nusing VPL\n\nmodule TreeTypes\n    import VPL\n    # Meristem\n    struct Meristem <: VPL.Node end\n    # Bud\n    struct Bud <: VPL.Node end\n    # Node\n    struct Node <: VPL.Node end\n    # BudNode\n    struct BudNode <: VPL.Node end\n    # Internode (needs to be mutable to allow for changes over time)\n    Base.@kwdef mutable struct Internode <: VPL.Node\n        length::Float64 = 0.10 # Internodes start at 10 cm\n    end\n    # Leaf\n    Base.@kwdef struct Leaf <: VPL.Node\n        length::Float64 = 0.20 # Leaves are 20 cm long\n        width::Float64  = 0.1 # Leaves are 5 cm wide\n    end    \n    # Graph-level variables\n    Base.@kwdef struct treeparams\n        growth::Float64 = 0.1   \n        budbreak::Float64 = 0.25\n        phyllotaxis::Float64 = 140.0\n        leaf_angle::Float64 = 30.0\n        branch_angle::Float64 = 45.0\n    end\nend\n\n[ Info: Precompiling VPL [bb250ff9-e5b1-4ad2-87ac-b577c1acaa48]\n\n\n[ Info: Precompiling GeometryBasicsExt [b238bd29-021f-5edc-8b0e-16b9cda5f63a]\n\n\n[ Info: Precompiling FileIOExt [f5f51d8f-5827-5d2e-939b-192fcd6ec70c]\n\n\nMain.TreeTypes\n\n\nAs always, the 3D structure and the color of each type of node are implemented with the feed! method. In this case, the internodes and leaves have a 3D representation, whereas bud nodes rotate the turtle. The rest of the elements of the trees are just points in the 3D structure, and hence do not have an explicit geometry:\n\n# Create geometry + color for the internodes\nfunction VPL.feed!(turtle::Turtle, i::TreeTypes.Internode, vars)\n    # Rotate turtle around the head to implement elliptical phyllotaxis\n    rh!(turtle, vars.phyllotaxis) \n    HollowCylinder!(turtle, length = i.length, height = i.length/15, width = i.length/15, \n                move = true, color = RGB(0.5,0.4,0.0))\n    return nothing\nend\n\n# Create geometry + color for the leaves\nfunction VPL.feed!(turtle::Turtle, l::TreeTypes.Leaf, vars)\n    # Rotate turtle around the arm for insertion angle\n    ra!(turtle, -vars.leaf_angle)\n    # Generate the leaf \n    Ellipse!(turtle, length = l.length, width = l.width, move = false, \n             color = RGB(0.2,0.6,0.2))\n    # Rotate turtle back to original direction\n    ra!(turtle, vars.leaf_angle)\n    return nothing\nend\n\n# Insertion angle for the bud nodes\nfunction VPL.feed!(turtle::Turtle, b::TreeTypes.BudNode, vars)\n    # Rotate turtle around the arm for insertion angle\n    ra!(turtle, -vars.branch_angle)\nend\n\nThe growth rule for a branch within a tree is simple: a phytomer (or basic unit of morphology) is composed of a node, a leaf, a bud node, an internode and an active meristem at the end. Each time step, the meristem is replaced by a new phytomer, allowing for developmemnt within a branch.\n\nmeristem_rule = Rule(TreeTypes.Meristem, rhs = mer -> TreeTypes.Node() + \n                                              (TreeTypes.Bud(), TreeTypes.Leaf()) +\n                                         TreeTypes.Internode() + TreeTypes.Meristem())\n\nRule replacing nodes of type Main.TreeTypes.Meristem without context capturing.\n\n\nIn addition, every step of the simulation, each bud may break, creating a new branch. The probability of bud break is proportional to the number of phytomers from the apical meristem (up to 1), which requires a relational rule to count the number of internodes in the graph up to reaching a meristem. When a bud breaks, it is replaced by a bud node, an internode and a new meristem. This new meristem becomes the apical meristem of the new branch, such that meristem_rule would apply. Note how we create an external function to compute whether a bud breaks or not. This is useful to keep the branch_rule rule simple and readable, while allow for a relatively complex bud break model. It also makes it easier to debug the bud break model, since it can be tested independently of the graph rewriting.\n\nfunction prob_break(bud)\n    # We move to parent node in the branch where the bud was created\n    node =  parent(bud)\n    # We count the number of internodes between node and the first Meristem \n    # moving down the graph\n    check, steps = hasDescendent(node, condition = n -> data(n) isa TreeTypes.Meristem)\n    steps = Int(ceil(steps/2)) # Because it will count both the nodes and the internodes\n    # Compute probability of bud break and determine whether it happens\n    if check\n        prob =  min(1.0, steps*vars(bud).budbreak)\n        return rand() < prob\n    # If there is no meristem, an error happened since the model does not allow for this    \n    else\n        error(\"No meristem found in branch\")\n    end\nend\nbranch_rule = Rule(TreeTypes.Bud, \n            lhs = prob_break, \n            rhs = bud -> TreeTypes.BudNode() + TreeTypes.Internode() + TreeTypes.Meristem())\n\nRule replacing nodes of type Main.TreeTypes.Bud without context capturing.\n\n\nA binary tree initializes as an internode followed by a meristem, so the axiom can be constructed simply as:\n\naxiom = TreeTypes.Internode() + TreeTypes.Meristem()\n\nVPL.Core.StaticGraph(Dict{Int64, Any}(2 => VPL.Core.GraphNode{Main.TreeTypes.Meristem}(Main.TreeTypes.Meristem(), Set{Int64}(), 1, 2), 1 => VPL.Core.GraphNode{Main.TreeTypes.Internode}(Main.TreeTypes.Internode(0.1), Set([2]), missing, 1)), Dict{DataType, Set{Int64}}(Main.TreeTypes.Meristem => Set([2]), Main.TreeTypes.Internode => Set([1])), 1, 2)\n\n\nAnd the object for the tree can be constructed as in previous examples, by passing the axiom and the graph rewriting rules, but in this case also with the object with growth-related parameters.\n\ntree = Graph(axiom = axiom, rules = (meristem_rule, branch_rule), vars = TreeTypes.treeparams())\n\nDynamic graph with 2 nodes of types Main.TreeTypes.Meristem,Main.TreeTypes.Internode and 2 rewriting rules.\nDynamic graph variables stored in struct of type Main.TreeTypes.treeparams\n\n\nNote that so far we have not included any code to simulate growth of the internodes. The reason is that, as elongation of internotes does not change the topology of the graph (it simply changes the data stored in certain nodes), this process does not need to be implemented with graph rewriting rules. Instead, we will use a combination of a query (to identify which nodes need to be altered) and direct modification of these nodes:\n\ngetInternode = Query(TreeTypes.Internode)\n\nQuery object for nodes of type Main.TreeTypes.Internode\n\n\nIf we apply the query to a graph using the apply function, we will get an array of all the nodes that match the query, allow for direct manipulation of their contents. To help organize the code, we will create a function that simulates growth by multiplying the length argument of all internodes in a tree by the growth parameter defined in the above:\n\nfunction elongate!(tree, query)\n    for x in apply(tree, query)\n        x.length = x.length*(1.0 + vars(tree).growth)\n    end\nend\n\nelongate! (generic function with 1 method)\n\n\nNote that we use vars on the Graph object to extract the object that was stored inside of it. Also, as this function will modify the graph which is passed as input, we append an ! to the name (this not a special syntax of the language, its just a convention in the Julia community). Also, in this case, the query object is kept separate from the graph. We could have also stored it inside the graph like we did for the parameter growth. We could also have packaged the graph and the query into another type representing an individual TreeTypes. This is entirely up to the user and indicates that a model can be implemented in many differences ways with VPL.\nSimulating the growth a tree is a matter of elongating the internodes and applying the rules to create new internodes:\n\nfunction growth!(tree, query)\n    elongate!(tree, query)\n    rewrite!(tree)\nend\n\ngrowth! (generic function with 1 method)\n\n\nand a simulation for n steps is achieved with a simple loop:\n\nfunction simulate(tree, query, nsteps)\n    new_tree = deepcopy(tree)\n    for i in 1:nsteps\n        growth!(new_tree, query)\n    end\n    return new_tree\nend\n\nsimulate (generic function with 1 method)\n\n\nNotice that the simulate function creates a copy of the object to avoid overwriting it. If we run the simulation for a couple of steps\n\nnewtree = simulate(tree, getInternode, 2)\n\nDynamic graph with 10 nodes of types Main.TreeTypes.Meristem,Main.TreeTypes.Bud,Main.TreeTypes.Node,Main.TreeTypes.Internode,Main.TreeTypes.Leaf and 2 rewriting rules.\nDynamic graph variables stored in struct of type Main.TreeTypes.treeparams\n\n\nThe binary tree after two iterations has two branches, as expected:\n\nrender(newtree)\n\n\n\n\nNotice how the lengths of the prisms representing internodes decreases as the branching order increases, as the internodes are younger (i.e. were generated fewer generations ago). Further steps will generate a structure that is more tree-like.\n\nnewtree = simulate(newtree, getInternode, 15)\nrender(newtree)"
  },
  {
    "objectID": "tutorials/turtle_message/index.html",
    "href": "tutorials/turtle_message/index.html",
    "title": "Turtle messages",
    "section": "",
    "text": "Coming soon!"
  }
]