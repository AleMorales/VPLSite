[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site!"
  },
  {
    "objectID": "api/Core.html#types",
    "href": "api/Core.html#types",
    "title": "Virtual Plant Laboratory",
    "section": "Types",
    "text": "Types\n# VPL.Core.Graph — Type.\nGraph(axiom; rules = nothing, vars = nothing)\nCreates a dynamic graph defined by the initial node or nodes (axiom), one or more rules (rules), and an object with graph-level variables (vars). Rules and graph-level variables are optional and must be assigned by keyword (see example below). Rules must be a Rule or tuple of Rule objects. The axiom may be a single object inheriting from Node or a subgraph generated with the graph construction DSL. A copy of the axiom and rules is always made when constructing the graph, but if object containing graph-level variables is not mutable, the user must manually copy it (with copy or deepcopy) or else changes within the graph will affect the original object (and other graphs created from the same object).\nExample\nstruct A <: Node end\nstruct B <: Node end\naxiom = A() + B()\nno_rules_graph = Graph(axiom)\nrule = Rule(A, rhs = x -> A() + B())\nrules_graph = Graph(axiom, rules = rule)\nsource\n# VPL.Core.Rule — Type.\nRule(nodetype; lhs = x -> true, rhs = x -> nothing, captures = false)\nCreate a replacement rule for nodes of type nodetype with function-like objects for the left-hand side (lhs) and right-hand side (rhs). If the rule captures nodes in the context of the replacement node this must be indicated by the argument captures.\nExample\nstruct A <: Node end\nstruct B <: Node end\naxiom = A() + B()\nrule = Rule(A, rhs = x -> A() + B())\nrules_graph = Graph(axiom, rules = rule)\nrewrite!(rules_graph)\nsource\n# VPL.Core.Query — Type.\nQuery(nodetype::DataType, query = x -> true)\nCreate a query that matches nodes of type nodetype and the conditions specified in the argument query (must be a function that returns true). It returns an object of type Query that can be applied to a graph with the function apply.\nExample\nstruct A <: Node end\nstruct B <: Node end\naxiom = A() + B()\ngraph = Graph(axiom)\nquery = Query(A)\napply(graph, query)\nsource\n# VPL.Core.Node — Type.\nNode\nAbstract type from which every node in a graph should inherit. This allows using the graph construction DSL.\nExample\nstruct bar <: Node\n  x::Int\nend\nb1 = bar(1)\nb2 = bar(2)\nb1 + b2\nsource\n# VPL.Core.Context — Type.\nContext\nData structure than links a GraphNode to a Graph. Functions data() and vars() give access to the data stored in the node and graph, respectively. Several methods are also available to test relationships among nodes in the graph and to extract these related nodes (see User Manual for details).\nUsers do not build Context objects directly but they are provided by VPL as inputs to the user-defined functions inside rules and queries.\nsource"
  },
  {
    "objectID": "api/Core.html#graph-dsl",
    "href": "api/Core.html#graph-dsl",
    "title": "Virtual Plant Laboratory",
    "section": "Graph DSL",
    "text": "Graph DSL\n# Base.:+ — Method.\n+(n1::Node, n2::Node)\nCreates a graph with two nodes where n1 is the root and n2 is the insertion point.\nsource\n# Base.:+ — Method.\n+(g::StaticGraph, n::Node)\nCreates a graph as the result of appending the node n to the insertion point of graph g.\nsource\n# Base.:+ — Method.\n+(n::Node, g::StaticGraph)\nCreates a graph as the result of appending the static graph g to the node n.\nsource\n# Base.:+ — Method.\n+(g1::StaticGraph, g2::StaticGraph)\nCreates a graph as the result of appending g2 to the insertion point of g1. The insertion point of the final graph corresponds to the insertion point of g2\nsource\n# Base.:+ — Method.\n+(g::StaticGraph, T::Tuple)\n+(n::Node, T::Tuple)\nCreates a graph as the result of appending a tuple of graphs/nodes T to the insertion point of the graph g or node n. Each graph/node in L becomes a branch.\nsource"
  },
  {
    "objectID": "api/Core.html#applying-rules-and-queries",
    "href": "api/Core.html#applying-rules-and-queries",
    "title": "Virtual Plant Laboratory",
    "section": "Applying rules and queries",
    "text": "Applying rules and queries\n# VPL.Core.apply — Method.\napply(g::Graph, query::Query)\nReturn an array with all the nodes in the graph that match the query supplied by the user.\nExample\nstruct A <: Node end\nstruct B <: Node end\naxiom = A() + B()\ngraph = Graph(axiom)\nquery = Query(A)\napply(graph, query)\nsource\n# VPL.Core.rewrite! — Method.\nrewrite!(g::Graph)\nApply the graph-rewriting rules stored in the graph. This function will match the left-hand sides of the rules against the graph and then replace and/or prune the graph at every location where the left-hand sides matched by the result of executing the right hand side of each rule. The modification is performed in-place, so this function returns nothing.\nExample\nstruct A <: Node end\nstruct B <: Node end\naxiom = A() + B()\nrule = Rule(A, rhs = x -> A() + B())\nrules_graph = Graph(axiom, rules = rule)\nrewrite!(rules_graph)\nsource"
  },
  {
    "objectID": "api/Core.html#extracting-information",
    "href": "api/Core.html#extracting-information",
    "title": "Virtual Plant Laboratory",
    "section": "Extracting information",
    "text": "Extracting information\n# VPL.Core.vars — Method.\nvars(g::Graph)\nReturns the object storing the graph-level variables\nExample\nstruct A <: Node end\naxiom = A()\ngraph = Graph(axiom, vars = 2)\nvars(graph)\nsource\n# VPL.Core.rules — Method.\nrules(g::Graph)\nReturns a tuple with all the graph-rewriting rules stored in the graph\nExample\nstruct A <: Node end\nstruct B <: Node end\naxiom = A() + B()\nrule = Rule(A, rhs = x -> A() + B())\nrules_graph = Graph(axiom, rules = rule)\nrules(rules_graph)\nsource\n# VPL.Core.vars — Method.\nvars(c::Context)\nReturns the object storing the graph-level variables in the graph associated to a Context object. This needs to be used inside rules and queries.\nsource\n# VPL.Core.data — Method.\ndata(c::Context)\nReturns the data stored in the node associated to a Context object. This needs to be used inside rules and queries.\nsource"
  },
  {
    "objectID": "api/Core.html#graph-traversal",
    "href": "api/Core.html#graph-traversal",
    "title": "Virtual Plant Laboratory",
    "section": "Graph traversal",
    "text": "Graph traversal\n# VPL.Core.hasParent — Method.\nhasParent(c::Context)\nCheck if the node passed as argument has a parent and return true or false.\nsource\n# VPL.Core.isRoot — Method.\nisRoot(c::Context)\nCheck if the node passed as argument is the root of the graph (i.e. has no parent) and return true or false.\nsource\n# VPL.Core.hasAncestor — Function.\nhasAncestor(c::Context, condition, maxlevel)\nCheck if the node passed as argument has an ancestor that matches the optional condition and and return true or false and the number of steps taken. The argument maxlevel is optional and limits the number of steps that the algorithm will move through the graph (by default there is no limitation). The default condition returns true for any ancestor and it takes an object of type Context.\nsource\n# Base.parent — Method.\nparent(c::Context, nsteps::Int)\nReturns a Context object associated to the parent of the node passed as first argument (nsteps = 1, the default) or an ancestor that is nsteps away from the node passed as first argument.\nsource\n# VPL.Core.ancestor — Function.\nancestor(c::Context, condition, maxlevel)\nReturns a Context object associated to the first ancestor of the node given as argument that matches the optional condition. The argument maxlevel is optional and limits the number of steps that the algorithm will move through the graph (by default there is no limitation). The matched node is returned as a Context object. The default condition returns true for any ancestor and it takes an object of type Context.\nsource\n# VPL.Core.hasChildren — Method.\nhasChildren(c::Context)\nCheck if the node passed as argument has at least one child and return true or false.\nsource\n# VPL.Core.isLeaf — Method.\nisLeaf(c::Context)\nCheck if the node passed as argument is a leaf in the graph (i.e. has no children) and return true or false.\nsource\n# VPL.Core.hasDescendent — Function.\nhasDescendent(c::Context, condition, maxlevel)\nCheck if the node passed as argument has a descendent that matches the optional condition and return true or false. The argument maxlevel is optional and limits the number of steps that the algorithm will move through the graph (by default there is no limitation). The default condition returns true for any descendent and it takes an object of type Context.\nsource\n# VPL.Core.children — Method.\nchildren(c::Context)\nReturns a tuple of Context objects with all the children of the node given as argument.\nsource\n# VPL.Core.descendent — Function.\ndescendent(c::Context, condition, maxlevel)\nReturns a Context object associated to the first descendent of the node given as argument that matches the optional condition. The argument maxlevel is optional and limits the number of steps that the algorithm will move through the graph (by default there is no limitation). The matched node is returned as a Context object. The default condition returns true for any descendent and it takes an object of type Context.\nsource\n# VPL.Core.traverse — Method.\ntraverse(g::Graph, f)\nIterates over all the nodes in the graph (in no particular order) and execute for each node the function f taking as input the data stored in the node.\nsource\n# VPL.Core.traverseDFS — Method.\ntraverseDFS(g::Graph, f)\nIterates over all the nodes in the graph (depth-first order, starting at the root of the graph) and execute for each node the function f taking as input the data stored in the node.\nsource\n# VPL.Core.traverseBFS — Method.\ntraverseBFS(g::Graph, f)\nIterates over all the nodes in the graph (breadth-first order, starting at the root of the graph) and execute for each node the function f taking as input the data stored in the node.\nsource"
  },
  {
    "objectID": "api/Core.html#graph-visualization",
    "href": "api/Core.html#graph-visualization",
    "title": "Virtual Plant Laboratory",
    "section": "Graph visualization",
    "text": "Graph visualization\n# VPL.Core.draw — Method.\ndraw(g::Graph; force = false, backend = \"native\", inline = false, resolution = (1920, 1080),\nnlabelstextsize = 15, arrowsize = 15, node_size = 5)\nVisualize a graph as a network using different backends (native for OpenGL, web for WebGL and vector for Cairo vector graphics, see VPL documentation for details). To force an external window when using the native backend set force = true whereas to force to be inlined use inline = true. Details on the behaviour of each backend on different contexts of code execution can be found in the VPL documentation. For backend native or web, the user may specify the resolution in pixels (by default HD is used). Additional customization is possible via nlabels_textsize (useful if the labels of the nodes are too large or small), arrow_size (this adjust the size of arrow heads) and node_size (for the size of the nodes).\nsource\n# VPL.Core.draw — Method.\ndraw(g::StaticGraph; force = false, backend = \"native\", inline = false, resolution = (1920, 1080),\nnlabelstextsize = 15, arrowsize = 15, node_size = 5)\nEquivalent to the method draw(g::Graph) but useful to visualize static graphs (e.g., usually this would be the axiom of a graph).\nsource\n# VPL.Core.node_label — Method.\nnode_label(n::Node, id)\nFunction that constructs a label for a node to be used by draw() when visualizing the graph as a network. The default method will create a label from the type of node its unique id. The user can specialize this method for user-defined data types to customize the label.\nsource\n# VPL.Core.export_graph — Method.\nexport_graph(f, filename; kwargs...)\nExport a graph visualization (created by draw()) into an external file. Supported formats are png (if the native or web backends were used in draw()), pdf or svg (if the vector backend was used). The file name should include the extension from which the format will be inferred. Additional keyword arguments are passed along to the corresponding save() method defined in the Makie package (see VPL documentation for details).\nsource\n# VPL.Core.calculate_resolution — Method.\ncalculate_resolution(width, height; format = \"png\", dpi = 300)\nCalculate the resolution required to achieve a specific width and height (in cm) of the exported image, with a particular dpi (for png format).\nsource"
  },
  {
    "objectID": "api/Geometry.html#turtle-geometry",
    "href": "api/Geometry.html#turtle-geometry",
    "title": "Virtual Plant Laboratory",
    "section": "Turtle geometry",
    "text": "Turtle geometry\n# VPL.Geom.MTurtle — Method.\nMTurtle()\nCreate a meshing turtle that can convert a Graph into a 3D mesh using turtle operators, geometry primitives and methods of feedgeom!(). By default, the meshing turtle will generate geometry primitives with single floating precision (Float32) but it is possible to generate a version with higher precision as in MTurtle(Float64). The turtle generated by this function will be centered at the origin and oriented with the head towards the Z axis (see VPL documentation for details on turtles).\nsource\n# VPL.Geom.head — Method.\nhead(turtle)\nExtract the direction vector (a Vec object) of the head of the turtle (see VPL documentation for details).\nsource\n# VPL.Geom.up — Method.\nup(turtle)\nExtract the direction vector (a Vec object) of the back of the turtle (see VPL documentation for details).\nsource\n# VPL.Geom.arm — Method.\narm(turtle)\nExtract the direction vector (a Vec object) of the arm of the turtle (see VPL documentation for details).\nsource\n# VPL.Geom.pos — Method.\npos(turtle)\nExtract the current position of the turtle (a Vec object, see VPL documentation for details).\nsource\n# VPL.Geom.geoms — Method.\ngeoms(turtle)\nExtract the 3D mesh generated by the turtle (a Mesh object, see VPL documentation for details). This mesh does not distinguish among geometric primitives (i.e., as the turtle parses the graph, the triangular mesh associated to each primitive is appended to the growing mesh).\nsource\n# VPL.Geom.nvertices — Method.\nnvertices(turtle)\nExtract the number of vertices in the mesh associated to each geometry primitive. This links each subset of the mesh stored in the turtle to the original geometry primitives.\nsource\n# VPL.Geom.feedgeom! — Function.\nfeedgeom!(turtle::MTurtle, m::Mesh)\nGeneral purpose method to feed a mesh to a turtle. This should be used to add any generated primitive to the turtle’s mesh as they are all implemented as meshes\nsource\nfeedgeom!(turtle::MTurtle, node::Node)\nDefault method for feedgeom!() that does not do anything. Hence, the user can include nodes in a graph withour an associated geometry.\nsource\nfeedgeom!(turtle::MTurtle, g::Graph)\nProcess a Graph object with a turtle and generate the corresponding 3D mesh from the turtle movement operations and geometry primitives or meshes defined in the graph.\nsource\nfeedgeom!(turtle::MTurtle, collection::AbstractArray)\nfeedgeom!(turtle::MTurtle, collection::Tuple)\nFeed a turtle an array or tuple of objects (collection) with existing feedgeom!() methods.\nsource\n# VPL.Geom.T — Type.\nT(to)\nNode that translates a turtle to the new position to.\nsource\n# VPL.Geom.t! — Method.\nt!(turtle; to)\nTranslate a turtle to the new position to.\nsource\n# VPL.Geom.OR — Type.\nOR(head, up, arm)\nNode that orients a turtle to a new direction by re-defining the local reference system.\nsource\n# VPL.Geom.or! — Method.\nor!(turtle, head, up, arm)\nOrient a turtle to a new direction by re-defining the local reference system.\nsource\n# VPL.Geom.SET — Type.\nSET(to, head, up, arm)\nNode that sets the position and orientation of a turtle.\nsource\n# VPL.Geom.set! — Method.\nset!(turtle, to, head, up, arm)\nSet position and orientation of a turtle.\nsource\n# VPL.Geom.RU — Type.\nRU(angle)\nNode that rotates a turtle around up axis. Angle must be in hexadecimal degrees and the rotation is clockwise.\nsource\n# VPL.Geom.ru! — Method.\nru!(turtle, angle)\nRotates a turtle around up axis. Angle must be in hexadecimal degrees and the rotation is clockwise.\nsource\n# VPL.Geom.RA — Type.\nRA(angle)\nNode that rotates a turtle around arm axis. Angle must be in hexadecimal degrees and the rotation is clockwise.\nsource\n# VPL.Geom.ra! — Method.\nra!(turtle, angle)\nRotates a turtle around arm axis. Angle must be in hexadecimal degrees and the rotation is clockwise.\nsource\n# VPL.Geom.RH — Type.\nRH(angle)\nNode that rotates a turtle around head axis. Angle must be in hexadecimal degrees and the rotation is clockwise.\nsource\n# VPL.Geom.rh! — Method.\nrh!(turtle, angle)\nRotate turtle around head axis. Angle must be in hexadecimal degrees and the rotation is clockwise.\nsource\n# VPL.Geom.F — Type.\nF(dist)\nMoves a turtle forward a given distance.\nsource\n# VPL.Geom.f! — Method.\nf!(turtle, dist)\nMove turtle forward a given distance.\nsource"
  },
  {
    "objectID": "api/Geometry.html#d-vectors",
    "href": "api/Geometry.html#d-vectors",
    "title": "Virtual Plant Laboratory",
    "section": "3D vectors",
    "text": "3D vectors\n# VPL.Geom.Vec — Type.\nVec(x, y, z)\n3D vector or point with coordinates x, y and z.\nsource\n# VPL.Geom.O — Method.\nO()\nReturns the origin of the 3D coordinate system as a Vec object. By default, the coordinates will be in double floating precision (Float64) but it is possible to generate a version with lower floating precision as in O(Float32).\nsource\n# VPL.Geom.X — Method.\nX()\nReturns an unit vector in the direction of the X axis as a Vec object. By default, the coordinates will be in double floating precision (Float64) but it is possible to generate a version with lower floating precision as in X(Float32).\nsource\n# VPL.Geom.Y — Method.\nY()\nReturns an unit vector in the direction of the Y axis as a Vec object. By default, the coordinates will be in double floating precision (Float64) but it is possible to generate a version with lower floating precision as in Y(Float32).\nsource\n# VPL.Geom.Z — Method.\nZ()\nReturns an unit vector in the direction of the Z axis as a Vec object. By default, the coordinates will be in double floating precision (Float64) but it is possible to generate a version with lower floating precision as in Z(Float32).\nsource\n# VPL.Geom.X — Method.\nX(s)\nReturns scaled vector in the direction of the X axis with length s as a Vec object using the same floating point precision as s.\nsource\n# VPL.Geom.Y — Method.\nY(s)\nReturns scaled vector in the direction of the Y axis with length s as a Vec object using the same floating point precision as s.\nsource\n# VPL.Geom.Z — Method.\nZ(s)\nReturns scaled vector in the direction of the Z axis with length s as a Vec object using the same floating point precision as s.\nsource"
  },
  {
    "objectID": "api/Geometry.html#geometry-primitives",
    "href": "api/Geometry.html#geometry-primitives",
    "title": "Virtual Plant Laboratory",
    "section": "Geometry primitives",
    "text": "Geometry primitives\n# VPL.Geom.Rectangle — Method.\nRectangle(v, l, w)\nCreate a rectangle from a vertex (v) and vectors l and w representing the side of the primitive. If l and w are not orthogonal\nsource\n# VPL.Geom.Rectangle — Method.\nRectangle(;l = 1.0, w = 1.0)\nCreate a standard rectangle with length l and width w (see VPL documentation for details).\nsource\n# VPL.Geom.Rectangle! — Method.\nRectangle!(turtle; l = 1.0, w = 1.0, move = false)\nGenerate a rectangle with length l (along the head of the turtle) and width w (along the arm of the turtle) in front of the turtle and optionally move the turtle forward to the opposite side of the generated rectangle (see VPL documentation for for more details).\nsource\n# VPL.Geom.Ellipse — Method.\nEllipse(;l = 1.0, w = 1.0, n = 20)\nCreate a standard ellipse with length l, width w and discretized into n triangles (see VPL documentation for details).\nsource\n# VPL.Geom.Ellipse! — Method.\nEllipse!(turtle; l = 1.0, w = 1.0, n = 20, move = false)\nGenerate an ellipse with length l (along the head of the turtle) and width w (along the arm of the turtle) in front of the turtle and optionally move the turtle forward to the opposite side of the generated rectangle (see VPL documentation for for more details). The ellipse will be converted into a mesh with n triangles.\nsource\n# VPL.Geom.HollowCylinder — Method.\nHollowCylinder(;l = 1.0, w = 1.0, h = 1.0, n = 20)\nCreate a standard hollow cylinder with length l, width w, height h and discretized into 2n triangles (see VPL documentation for details).\nsource\n# VPL.Geom.HollowCylinder! — Method.\nHollowCylinder!(turtle; l = 1.0, w = 1.0, h = 1.0, n = 20, move = false)\nGenerate a hollow cylinder with length l (along the up direction of the turtle), width w (along the arm of the turtle) and height h (along the head of the turtle) in front of the turtle and optionally move the turtle forward to the opposite side of the generated hollow cylinder (see VPL documentation for for more details). The hollow cylinder will be converted into a mesh with 2n triangles.\nsource\n# VPL.Geom.SolidCylinder — Method.\nSolidCylinder(;l = 1.0, w = 1.0, h = 1.0, n = 20)\nCreate a standard solid cylinder with length l, width w, height h and discretized into 4n triangles (see VPL documentation for details).\nsource\n# VPL.Geom.SolidCylinder! — Method.\nSolidCylinder!(turtle; l = 1.0, w = 1.0, h = 1.0, n = 20, move = false)\nGenerate a solid cylinder with length l (along the up direction of the turtle), width w (along the arm of the turtle) and height h (along the head of the turtle) in front of the turtle and optionally move the turtle forward to the opposite side of the generated solid cylinder (see VPL documentation for for more details). The solid cylinder will be converted into a mesh with 4n triangles.\nsource\n# VPL.Geom.HollowCone — Method.\nHollowCone(;l = 1.0, w = 1.0, h = 1.0, n = 20)\nCreate a standard hollow cone with length l, width w, height h and discretized into n triangles (see VPL documentation for details).\nsource\n# VPL.Geom.HollowCone! — Method.\nHollowCone!(turtle; l = 1.0, w = 1.0, h = 1.0, n = 20, move = false)\nGenerate a hollow cone with length l (along the up direction of the turtle), width w (along the arm of the turtle) and height h (along the head of the turtle) in front of the turtle and optionally move the turtle forward to the opposite side of the generated hollow cone (see VPL documentation for for more details). The hollow cone will be converted into a mesh with n triangles.\nsource\n# VPL.Geom.SolidCone — Method.\nSolidCone(;l = 1.0, w = 1.0, h = 1.0, n = 20)\nCreate a standard solid cone with length l, width w, height h and discretized into 2n triangles (see VPL documentation for details).\nsource\n# VPL.Geom.SolidCone! — Method.\nSolidCone!(turtle; l = 1.0, w = 1.0, h = 1.0, n = 20, move = false)\nGenerate a solid cone with length l (along the up direction of the turtle), width w (along the arm of the turtle) and height h (along the head of the turtle) in front of the turtle and optionally move the turtle forward to the opposite side of the generated solid cone (see VPL documentation for for more details). The solid cone will be converted into a mesh with 2n triangles.\nsource\n# VPL.Geom.SolidCube — Method.\nSolidCube(;l = 1.0, w = 1.0, h = 1.0)\nCreate a standard solid cube with length l, width w, height h (see VPL documentation for details).\nsource\n# VPL.Geom.SolidCube! — Method.\nSolidCube!(turtle; l = 1.0, w = 1.0, h = 1.0, move = false)\nGenerate a solid cube with length l (along the up direction of the turtle), width w (along the arm of the turtle) and height h (along the head of the turtle) in front of the turtle and optionally move the turtle forward to the opposite side of the generated solid cube (see VPL documentation for for more details).\nsource\n# VPL.Geom.HollowCube — Method.\nHollowCube(;l = 1.0, w = 1.0, h = 1.0)\nCreate a standard hollow cube with length l, width w, height h (see VPL documentation for details).\nsource\n# VPL.Geom.HollowCube! — Method.\nHollowCube!(turtle; l = 1.0, w = 1.0, h = 1.0, move = false)\nGenerate a hollow cube with length l (along the up direction of the turtle), width w (along the arm of the turtle) and height h (along the head of the turtle) in front of the turtle and optionally move the turtle forward to the opposite side of the generated hollow cube (see VPL documentation for for more details).\nsource\n# VPL.Geom.SolidFrustum — Method.\nSolidFrustum(;l = 1.0, w = 1.0, h = 1.0, n = 20)\nCreate a standard solid frustum with length l, width w, height h and discretized into 4n triangles (see VPL documentation for details).\nsource\n# VPL.Geom.SolidFrustum! — Method.\nSolidFrustum!(turtle; l = 1.0, w = 1.0, h = 1.0, ratio 1.0, n = 20, move = false)\nGenerate a solid frustum of a given ratio with length l (along the up direction of the turtle), width w (along the arm of the turtle) and height h (along the head of the turtle) in front of the turtle and optionally move the turtle forward to the opposite side of the generated solid frustum (see VPL documentation for for more details). The solid frustum will be converted into a mesh with 4n triangles.\nsource\n# VPL.Geom.HollowFrustum — Method.\nHollowFrustum(;l = 1.0, w = 1.0, h = 1.0, n = 20)\nCreate a standard hollow frustum with length l, width w, height h and discretized into 2n triangles (see VPL documentation for details).\nsource\n# VPL.Geom.HollowFrustum! — Method.\nHollowFrustum!(turtle; l = 1.0, w = 1.0, h = 1.0, ratio =  1.0, n = 20, move = false)\nGenerate a hollow frustum with length l (along the up direction of the turtle), width w (along the arm of the turtle) and height h (along the head of the turtle) in front of the turtle and optionally move the turtle forward to the opposite side of the generated hollow frustum (see VPL documentation for for more details). The hollow frustum will be converted into a mesh with 2n triangles.\nsource\n# VPL.Geom.BBox — Method.\nBBox(m::Mesh)\nBuild a tight axis-aligned bounding box around a Mesh object.\nsource\n# VPL.Geom.BBox — Method.\nBBox(pmin, pmax)\nBuild an axis-aligned bounding box given the vector of minimum (pmin) and maximum (pmax) coordinates.\nsource"
  },
  {
    "objectID": "api/Geometry.html#mesh-related-methods",
    "href": "api/Geometry.html#mesh-related-methods",
    "title": "Virtual Plant Laboratory",
    "section": "Mesh-related methods",
    "text": "Mesh-related methods\n# VPL.Geom.Mesh — Method.\nMesh()\nGenerate an empty triangular dense mesh that represents a primitive or 3D scene. By default a Mesh object will only accept coordinates in double floating precision (Float64) but a lower precision can be generated by specifying the corresponding data type as in Mesh(Float32).\nsource\n# VPL.Geom.Mesh — Method.\nMesh(nt, nv = nt*3)\nGenerate a triangular dense mesh with enough memory allocated to store nt triangles and nv vertices. The behaviour is equivalent to generating an empty mesh but may be computationally more efficient when appending a large number of primitives. If a lower floating precision is require this may be specified as the third argument as in Mesh(10, 30, Float32).\nsource\n# VPL.Geom.ntriangles — Method.\nntriangles(mesh)\nExtract the number of triangles from a Mesh object.\nsource\n# VPL.Geom.nvertices — Method.\nnvertices(mesh)\nExtract the number of vertices from a Mesh object.\nsource\n# VPL.Geom.area — Method.\narea(m::Mesh)\nTotal surface area of a mesh (as the sum of areas of individual triangles).\nsource\n# VPL.Geom.areas — Method.\nareas(m::Mesh)\nA vector with the areas of the different triangles in a mesh.\nsource"
  },
  {
    "objectID": "api/RayTracer.html",
    "href": "api/RayTracer.html",
    "title": "Virtual Plant Laboratory",
    "section": "",
    "text": "Module RayTracing\n\n\n\n\nTurtle\n# VPL.RayTracing.RTTurtle — Type.\nRTTurtle()\nCreate a RTTurtle() object that will parse a Graph object and store the materials associated to the different primitives. This type of turtle is automatically created by calls to RTScene() but the user may want to separately construct the geometry and materials and manually combine them into a RTScene object for performance reasons.\nsource\n# VPL.RayTracing.materials — Function.\nmaterials(turtle)\nExtract the array of materials stored inside a RTTurtle object.\nsource\n# VPL.RayTracing.feedmaterial! — Function.\nfeedmaterial!(turtle::RTTurtle, material::Material)\nGeneral purpose method to feed a material to a RT turtle. This should be used inside user’s defined methods to add the material object with optical properties associated to the primitive.\nsource\nfeedmaterial!(turtle::RTTurtle, node::Node)\nDefault method for feedmaterial!() that does not do anything. Hence, the user can include nodes in a graph withour associated colors (the nodes should not generate geometry either).\nsource\nfeedmaterial!(turtle::RTTurtle, g::Graph)\nProcess a Graph object with a RT turtle and collect the materials defined in the graph, in the same order in which the 3D mesh is created by the corresponding feedgeom!() method.\nsource\nfeedmaterial!(turtle::RTTurtle, collection::AbstractArray)\nfeedmaterial!(turtle::RTTurtle, collection::Tuple)\nFeed a RT turtle an array or tuple of objects (collection) with existing feedmaterial!() methods.\nsource\n\n\n\n\nRTScene\n# VPL.RayTracing.Triangle — Method.\nTriangle(p1, p2, p3)\nCreate a ray tracing Triangle object given the three vertices p1, p2 and p3.\nsource\n# VPL.RayTracing.Triangle — Method.\nTriangle(mesh)\nCreate a vector of ray tracing Triangle objects from a Mesh object.\nsource\n# VPL.RayTracing.RTScene — Type.\nRTScene(triangles, material_ids, materials)\nCreate a ray tracing scene for rendering from a vector of triangles (triangles), a vector of ids that match each triangle to a material (ids) and the vector of material objects (materials). This method will generally not be used by the author unless the components of an RTScene were generated manually.\nsource\n# VPL.RayTracing.add! — Function.\nadd!(scene, mesh, materials)\nAdd a 3D mesh with corresponding materials (mesh and materials) to an existing RTScene object (scene).\nsource\n\n\n\n\nRayTracer\n# VPL.RayTracing.get_nw — Function.\nget_nw(s::Source)\nRetrieve the number of wavelengths that rays from a source will contain.\nsource\nget_nw(rt::RayTracer)\nRetrieve the number of wavelengths being simulated by the ray tracer. See VPL documentation for more details on the ray tracer.\nsource\n# VPL.RayTracing.RTSettings — Type.\nRTSettings(;parallel = false, pkill = 0.2, maxiter = 2, sampler = Random.Xoshiro(123456789))\nSettings for the ray tracer: parallel indicates if the raytracer will run on a single core or make use of multiple cores in the machine based on Julia’s multithreading support. pkill is the probably that a ray is terminated by the Russian roulette after it has been scattered a maxiter number of times. sampler is the pseudo-random number generator to be used by the ray tracer. See VPL documentation for more details on the ray tracer.\nsource\n# VPL.RayTracing.RayTracer — Type.\nRayTracer(acceleration, grid, materials, sources, settings)\nCreate a ray tracer object from an acceleration structure built around a 3D mesh (acceleration), a grid clonder structure around the acceleration structure (grid), a vector of materials associated to the mesh (materials), a vector of sources of irradiance (sources) and settings. (as generated by RTSettings()). See VPL documentation for more details on the ray tracer.\nsource\n# VPL.RayTracing.trace! — Function.\ntrace!(rt)\nRun the ray tracing simulations. This function will overwrite the power component of any material object that is included in the scene. It returns the total number of rays being traced (primary and secondary). See VPL documentation for more details on the ray tracer.\nsource\n\n\n\n\nSources\n# VPL.RayTracing.Source — Type.\nSource(geom, angle, power::Number, nrays)\nSource(geom, angle, power::Tuple, nrays)\nCreaten irradiance source given a source geometry, a source angle, the power per ray and the total number of rays to be generated from this source. When simulating more than one wavelength simultaneously, a tuple of power values should be given, of the same length as in the materials used in the scene. See VPL documentation for details on source geometries and source angles.\nsource\n# VPL.RayTracing.DirectionalSource — Function.\nDirectionalSource(box::AABB, θ, Φ, power, nrays)\nDirectionalSource(scene::RTScene, θ, Φ, power, nrays)\nCreate a Directional source (including geometry and angle components) by providing an axis-aligned bounding box (box) or an RTScene object (scene) as well as the zenith (θ) and azimuth (Φ) angles, the power per ray (as in Source) and the number of rays to be generated. See VPL documentation for details on irradiance sources.\nsource\n# VPL.RayTracing.PointSource — Type.\nPointSource(vec)\nCreate a point irradiance source geometry at given 3D location vec, defined as vector of Cartesian coordinates (Vec(x, y, z)).\nsource\n# VPL.RayTracing.LineSource — Type.\nLineSource(p, line)\nCreate a line irradiance source geometry given an origin (p) and a segment (line) both specified as vector of Cartesian coordinates (Vec(x, y, z)). This will create a line source between the points p and p .+ line.\nsource\n# VPL.RayTracing.AreaSource — Type.\nAreaSource(mesh)\nCreate an area irradiance source geometry given a triangular mesh.\nsource\n\n\n\n\nAngles\n# VPL.RayTracing.LambertianSource — Type.\nLambertianSource(x, y, z)\nLambertianSource(axes)\nCreate a Lambertian irradiance source angle by given a local coordinate system as three separate Vec objects representing the axes (x, y, z) or as tuple containing the three axes. Rays will be generated towards the hemisphere defined by the z direction. See VPL documentation for details on irradiance sources.\nsource\n\n\n\n\nMaterials\n# VPL.RayTracing.Sensor — Type.\nSensor(nw::Int)\nCreate a sensor material object to store power for nw wavelengths. See VPL documentation for details.\nsource\n# VPL.RayTracing.Black — Type.\nBlack(nw::Int)\nCreate a black material object to store power for nw wavelengths. See VPL documentation for details.\nsource\n# VPL.RayTracing.Lambertian — Type.\nLambertian(τ::Tuple, ρ::Tuple)\nLambertian(τ::Number, ρ::Number)\nCreate a Lambertian material object from the values of transmittance (τ) and reflectance (ρ). When more than one wavelength is being simulated, a tuple of values should be passed for each optical property. See VPL documentation for details.\nsource\n# VPL.RayTracing.Phong — Type.\nPhong(τ::Number, ρd::Number, ρsmax::Number, n::Number)\nPhong(τ::Tuple, ρd::Tuple, ρsmax::Tuple, n::Number)\nCreate a Phong material object from the values of transmittance (τ) diffuse reflectance (ρd), maximum Phong specular reflectance (ρsmax) and n is the specular exponent that controls the “Phong reflectance lobe”. When more than one wavelength is being simulated, a tuple of values should be passed for each optical property. See VPL documentation for further details.\nsource"
  },
  {
    "objectID": "api/Render.html#scenes-for-rendering",
    "href": "api/Render.html#scenes-for-rendering",
    "title": "Virtual Plant Laboratory",
    "section": "Scenes for rendering",
    "text": "Scenes for rendering\n# VPL.Render.GLScene — Type.\nGLScene(mesh, colors)\nCreate a 3D scene for rendering from a Mesh object (m) and colors associated to the different primitives (colors). This method is useful when the user has generated separately the 3D mesh and array with colors, as otherwise other methods of GLScene() will be more useful.\nsource\n# VPL.Render.add! — Method.\nadd!(; scene, mesh, color)\nManually add a 3D mesh with corresponding colors (mesh and color) to an existing GLScene object (scene).\nsource"
  },
  {
    "objectID": "api/Render.html#rendering-methods",
    "href": "api/Render.html#rendering-methods",
    "title": "Virtual Plant Laboratory",
    "section": "Rendering methods",
    "text": "Rendering methods\n# VPL.Render.GLTurtle — Type.\nGLTurtle()\nCreate a GLTurtle() object that will parse a Graph object and store the colors associated to the different primitives. This type of turtle is automatically created by calls to GLScene() and render() but the user may want to separately construct the geometry and colors and manually combined them into a GLScene object for performance reasons.\nsource\n# VPL.Render.colors — Method.\ncolors(turtle)\nExtract the array of colors stored inside an GLTurtle object\nsource\n# VPL.Render.feedcolor! — Function.\nfeedcolor!(turtle::GLTurtle, color::Colorant)\nGeneral purpose method to feed a color to a GL turtle. This should be used inside user’s defined methods to add any color object that inherits from Colorant from the package Color, for example, by using RGB().\nsource\nfeedcolor!(turtle::GLTurtle, node::Node)\nDefault method for feedcolor!() that does not do anything. Hence, the user can include nodes in a graph withour associated colors (the nodes should not generate geometry either).\nsource\nfeedcolor!(turtle::GLTurtle, g::Graph)\nProcess a Graph object with a GL turtle and collect the colors defined in the graph, in the same order in which the 3D mesh is created by the corresponding feedgeom!() method.\nsource\nfeedcolor!(turtle::GLTurtle, collection::AbstractArray)\nfeedcolor!(turtle::GLTurtle, collection::Tuple)\nFeed a GL turtle an array or tuple of objects (collection) with existing feedcolor!() methods.\nsource\n# VPL.Render.render — Function.\nrender(m::Mesh, color; kwargs...)\nRender a mesh with a given color. This will create a new visualization (see Documentation for details). Keyword arguments are passed to the render(scene::GLScene) method and any unmatched keywords will be passed along to Makie.mesh().\nsource\nrender(scene::GLScene; normals::Bool = false, wireframe::Bool = false, kwargs...)\nRender a GLScene object. This will create a new visualization (see Documentation for details). normals = true will draw arrows in the direction of the normal vector for each triangle in the mesh, wireframe = true will draw the edges of each triangle with black lines. Keyword arguments are passed to Makie.mesh().\nsource\nrender(graph::Graph; normals::Bool = false, wireframe::Bool = false, kwargs...)\nRender the 3D mesh associated to a Graph object. This will create a new visualization (see Documentation for details). normals = true will draw arrows in the direction of the normal vector for each triangle in the mesh, wireframe = true will draw the edges of each triangle with black lines. Keyword arguments are passed to Makie.mesh().\nsource\nrender(graphs::Vector{<:Graph}; normals::Bool = false, wireframe::Bool = false, kwargs...)\nRender the 3D mesh associated to an array of Graph objects. This will create a new visualization (see Documentation for details). normals = true will draw arrows in the direction of the normal vector for each triangle in the mesh, wireframe = true will draw the edges of each triangle with black lines. Keyword arguments are passed to Makie.mesh().\nsource\n# VPL.Render.render! — Function.\nrender!(m::Mesh, color; kwargs...)\nAdd a mesh with a given color the visualization currently active. This will create a new visualization (see Documentation for details). Keyword arguments are passed to the render!(scene::GLScene) method and any unmatched keywords will be passed along to Makie.mesh!().\nsource\n# VPL.Render.export_scene — Method.\nexport_scene(scene, filename; kwargs...)\nExport a screenshot of the current visualization (stored as scene as output of a call to render) as a PNG file store in the path given by filename (including .png extension). Keyword arguments will be passed along to the corresponding save method from Makie (see VPL documentation for details).\nsource"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "The Virtual Plant Laboratory",
    "section": "",
    "text": "The Virtual Plant Laboratory (VPL) is a Julia package that aids in the construction, simulation and visualization of functional-structural plant models (FSPM). VPL is not a standalone solution to all the computational problems relevant to FSPM, but rather it focuses on those algorithms and visualizations that are specific to FSPM and for which there are no good solutions in the Julia package ecosystem. Furthermore, VPL is 100% written in Julia and therefore VPL will work in any platform and with any code editor where Julia works. Finally, VPL does not offer a domain specific language for FSPM but rather it allows building FSP models by creating user-defined data types and methods.\nThere is no standard definition of what an FSPM is, though these models will always involve some combination of plant structure and function, so it is likely that VPL will not be useful with every possible FSPM. Instead, VPL focuses on models that represent indivudual plants as graphs of elements (usually organs) that interact with each other and with the environment. In a typical VPL model, each plant is represented by its own graph which can change dynamically through the iterative application of graph rewriting rules. Based on this goal, what VPL offers mainly are data structures and algorithms that allow\n\nmodelling dynamic graphs that represent plants,\n\nmodelling the interaction between plants and their 3D environment by generating 3D structures from the graphs and simulating capture of different resources (e.g. light) and\nmodelling the interaction among elements within each plant by constructing dynamic networks that represent systems of ordinary differential equations.\n\nIn terms of design, VPL gives priority to performance and simple interfaces as opposed to complex layers of abstraction. This implies that models in VPL may be more verbose and procedural (as opposed to descriptive) than in other FSPM platforms, while being more transparent and easier to follow."
  },
  {
    "objectID": "index.html#installation",
    "href": "index.html#installation",
    "title": "The Virtual Plant Laboratory",
    "section": "Installation",
    "text": "Installation\nVPL requires using Julia version 1.7 or higher. The installation of VPL is as easy as running the following code:\nusing Pkg\nPkg.add(PackageSpec(url = \"https://git.wur.nl/vpl/vpl.git\", rev  = \"master\"))"
  },
  {
    "objectID": "index.html#the-vpl-ecosystem",
    "href": "index.html#the-vpl-ecosystem",
    "title": "The Virtual Plant Laboratory",
    "section": "The VPL ecosystem",
    "text": "The VPL ecosystem\nThe package VPL contains all the basic functionality to build FSPM but, as indicated earlier, the emphasis is on minimal, simple and transparent interfaces. In order to facilitate the construction of advanced FSPM, an ecosystem of packages will be built around VPL that bring higher levels of abstraction and reusable components with which models can be built.\nThe packages currently planned include\n\nEcophys: Algorithms and data structures to simulate ecophysiological processes including photosynthesis, transpiration, leaf energy balance, phenology, respiration, nutrient and water uptake, etc.\nSky: Algorithms to simulate different sky conditions in terms of the intensity of solar radiation and its spatial distribution.\nGCIM: A generic model that allows simulating multiple types of crops with an emphasis on interactions among crops"
  },
  {
    "objectID": "index.html#documentation",
    "href": "index.html#documentation",
    "title": "The Virtual Plant Laboratory",
    "section": "Documentation",
    "text": "Documentation\nDocumentation for VPL is provided in this website in four formats:\n\nUser manual\nTutorials and examples\nAPI\nTechnical notes\n\nNew users are expected to start with the tutorials and consult the user manual to understand better the different concepts used in VPL and get an overview of the different options available. The API documentation describes each individual function and data type, with an emphasis on inputs and outputs and (in addition to this website) it can be accessed from within Julia with ? (see the section Accessing Documentation in the Julia manual). The developer manual is useful for people who want to understand the internal details of VPL and how different algorithms are implemented (i.e. the developer manual should be seen as a supplementary to the source code of VPL)."
  },
  {
    "objectID": "julia_basics/index.html",
    "href": "julia_basics/index.html",
    "title": "Julia basics for VPL",
    "section": "",
    "text": "Key ideas:\n\nTypes and methods\nMutability vs immutability\nType redefinition and modules"
  },
  {
    "objectID": "manual/Graphs/index.html",
    "href": "manual/Graphs/index.html",
    "title": "Dynamic graph creation and manipulation",
    "section": "",
    "text": "A model in VPL is a (discrete) dynamical model that describes the time evolution of one or more entities (i.e. objects of type graph). Each graph (usually assumed to be an individual plant) is characterized by a series of nodes (usually organs) that are represented by nodes in a graph. Each node is defined by its own state, including (if applicable) a description of its geometry, color, optical propertes, etc. The dynamic simulation of a graph consists of the creation and destruction of nodes via graph rewriting rules, and changes to the internal state of its nodes with the help of queries.\nThe 3D structure of a graph is generated by processing its nodes using a Turtle procedural geometry approach (i.e. inspired on Logo’s turtle graphs as used in L-systems) and following the topology of the graph. This 3D structure may be used for visualization using a 3D renderer or for simulating spatial processes.\nVPL does not provide a domain-specific language to implement rules and queries. Rather, they are defined by functions which are stored in objects of types Rule and Query, respectively. Similarly, the nodes of a graph can be of any user-defined type, as long as the user defines the necessary methods to support specific functionality (e.g. the feedgeom! method to generate geometry).\nVPL is designed around data types and methods. Building a model in VPL typically requires:\n\nDefining types for the different classes of nodes of a graph\nCreating rules and queries based on these types\nCreating graphs by combining rules and the initial states of the graphs\nCreating additional elements in the scene (e.g. soil)\n\nA simulation in VPL consists of executing rules iteratively and, within each iteration:\n\nUse queries to select subset of nodes and modify their states.\nModify graph-level variables directly.\nUse algorithms in VPL to simulate interactions among nodes or between nodes and their environment.\n\nIn addition, VPL allows visualizing the results of a simulation by: * 3D rendering of the generated scenes * Network graph representing the nodes in the graph\nVPL is designed to facilitate modular model development, such as using different types of graphs in the same simulation, alternative visualizations of the same scene by mapping internal states of nodes to colors, or including multiple ray tracers in the same simulation. Users may also create their own data types that include graphs as fields or to nest graphs within other graphs."
  },
  {
    "objectID": "manual/Graphs/index.html#graph-construction-algebra",
    "href": "manual/Graphs/index.html#graph-construction-algebra",
    "title": "Dynamic graph creation and manipulation",
    "section": "Graph-construction algebra",
    "text": "Graph-construction algebra\nWhen initializing a graph and when specifying a graph rewriting rule it is necessary to indicate the topological relationship between the nodes being added to a graph (i.e. effectively we build graphs by appending sub-graphs). In order to facilitate the description of these relationships, a simple algebra is defined for all objects that inherit from Node.\nThe + operator indicates a linear parent-child dependency between the operands. For example, M() + L() indicates that the object generated by L() is a child of M(). A branching point is introduced by enclosing the children of a node within () and separating the different branches with “,”. For example, (M(1) + (L(2), L(3)) + M(4) + L(5)) creates a tree that starts with M(1), has 3 children (L(2), L(3) and M(4)) and M(4) has a child L(5).\nA graph always keep tracks of two special nodes: the root and the insertion point. The root is the node that has no parent. When you use a graph rewriting rule (see below) to replace a node a with a graph that has a root node b, the result is that node a is replaced by node b and will inherit all the children and parent from node a (plus the children that b already had in the replacement graph).\nAn insertion point is the node of a graph where new nodes will be connected to when using the + operator. Branches do not modify the insertion point of an existing graph, but linear addition of nodes will always update the insertion point to the last node. Thus, these two expressions produce the same tree structure but with different insertion points: M(1) + (L(2), L(3)) + M(4) + L(5) and M(1) + (L(2), L(3), M(4) + L(5)). In the first case, the insertion point becomes the node L(5) but in the second case it remains at M(1). Keeping track of the insertion point of a graph is important when building a graph in several steps."
  },
  {
    "objectID": "manual/Graphs/index.html#matching-relationships-among-nodes",
    "href": "manual/Graphs/index.html#matching-relationships-among-nodes",
    "title": "Dynamic graph creation and manipulation",
    "section": "Matching relationships among nodes",
    "text": "Matching relationships among nodes\nSometimes the lhs function needs to check the relationships between nodes inside a graph (e.g. match all leaves that belong to a particular branch of a graph). In order achieve that, one can use the functions hasParent() and hasChildren() to check for inmediate connections (i.e. effectively to check whether the node is a root or a leaf in the graph) whereas hasAncestor() and hasDescendant() allow traversing the graph and finding any connected node that matches a specific query. If we need to extract the contents of the node, we may use the corresponding functions parent(), children(), ancestor() and descendant(). Note that children() will return all the children nodes as a tuple, but the rest of functions only return one node at a time. All these functions take a Context object as input and return either true or false (for the functions that start with has) or a Context or tuple of Context objects for the functions that extract the actual connected node. These methods may also be used inside the rhs function of rules. However, to avoid code repetition (and for performance reasons), it is recommended to capture the Context objects of connected in the lhs function and pass them to the rhs as described below (see below)."
  },
  {
    "objectID": "manual/Graphs/index.html#capturing-the-context-of-a-node",
    "href": "manual/Graphs/index.html#capturing-the-context-of-a-node",
    "title": "Dynamic graph creation and manipulation",
    "section": "Capturing the context of a node",
    "text": "Capturing the context of a node\nIn some scenarios, knowing the relationship between nodes in the graph is not sufficient, because data stored inside those related nodes is required in the rhs function of a rule. In those cases, an extra argument to the constructor for a Rule is required (captures = true) to indicate that this rule will pass additional data from the lhs to the rhs function. Then, the lhs function should return a tuple, where the first element is still true or false (to indicate whether the rule matches a node) and the second element is a tuple of Context objects associated to the nodes being matched. If no match occurs, it is sufficient to return (false, ()), where () indicates an empty tuple. The rhs function should then be a function that takes as first argument the Context object of the node being replaced, and an additional argument for every Context object being captured on the lhs function and passed to the rhs function."
  },
  {
    "objectID": "manual/Graphs/index.html#execution-of-rules",
    "href": "manual/Graphs/index.html#execution-of-rules",
    "title": "Dynamic graph creation and manipulation",
    "section": "Execution of rules",
    "text": "Execution of rules\nRules are executed in the same order in which they are added to the graph object. Then, the lhs part of each rule is tested against all nodes of the specified type in the same order in which they were added to the graph. Similarly, the rhs part of a rule will be applied to those nodes that matched the lhs part, in the same order as in the matching.\n\nThe lhs part of all the rules are executed first and VPL will check that each node is not matched by more than rule. In case there is more than one match, an error will be generated. After all the lhs pars are executed, then the rhs parts are executed on the matched nodes. Although generating an error may seem restrictive, the reasoning for this approach is as follows:\n\nGraph rewriting is, conceptually, a parallel operation, so two rules cannot replace the same node as that would mean the result depends on the order in which the rules are executed.\nNew nodes will be generated by graph rewriting rules that could be matched by the lhs of other graph rewriting rules. To guarantee that all rules rewrite the same graph, all nodes that need to be replaced are identified before any rhs function is executed.\n\nIn essence, you need to program your model such that it does not rely on any specific order of execution of the graph rewriting rules."
  },
  {
    "objectID": "manual/RayTracer/index.html",
    "href": "manual/RayTracer/index.html",
    "title": "Ray tracing distribution of irradiance",
    "section": "",
    "text": "Monte Carlo Ray Tracer where rays are tracer from the sources towards the scene that is representd by triangular 3D meshes. The ray tracer has the following features:\n\nA Russian roulette is used for scattering such that an unbiased estimate is obtained while using a finite number of scattering events per ray\nDifferent acceleration structures may be used (kd-trees, bounday volume hierarchies and no acceleration)\nDifferent optical materials may be chosen for each element in the scene (Lambertian, Phong, LambertianPhong, Black body, Sensor) which will stored the absorbed power across the different simulated wavelengths.\nA SideSwitcher on top of an optical material allows to keep a separate accounting fo rays that hit on either side of a surface (e.g., different sides of a leaf)\nDifferent types of sources of irradiance (differing in their geometry of emission) are available, including area, line, point sources, directional sources that cover the entire scene and the possibility to turn any 3D mesh into a radiance source.\nThe payload of a ray may include multiple wavelengths and the optical properties may be vary per wavelength.\nThe package Sky is provided to facilitate constructing collections of sources of radiance that approximate the angular distribution of sky radiance, including the different CIE standard sky models.\nThe ray tracer can optionally make use of Julia’s multithreading capabilities to spread the computation across multiple cores within the same machine.\nThe ray tracer will establish a direct connection to the user’s defined objects that contain the optical materials, such that the absorbed power can be accessed easily by the user from within graph queries and rules.\nA grid cloner is provided to minimize border effects with as little overhead as possible.\n\n\n\n\nThe source object contains the power of each ray. This is equivalent to the radiance emitted (measured at source or at some distance from it), times the area where the radiance is measured and divided by the number of rays emitted by the light source that cross that area of measurement. Hence, when we run the ray tracer we should get back the correct irradiance on the measurement area.\nIn the case of directional light sources, the user should just use the Sky package which performs all necessary calculations for direct and diffuse solar radiation and generate the sources themselves.\nFor other types of sources, the user should provided the total power emitted by the source, but helper functions will be provided to calculate this value from different types of measurements and source geometries.\nSources are separate from the scene itself. This allows separating the construction of 3D mesh with optical properties from the different types of sources. The reasoning for this is as follows: (i) the 3D mesh may be built incrementally, especially when elements not include in the graphs are needed (typical examples are the soil surface or structural elements in the scene), (ii) different sources may be used for different simulations in the same scene (e.g., different times of the day, different solar wavelengths, thermal radiation)\n\n\n\nThis should be implemented inside the trace!() function as that is where the new rays are generated. It should somehow make use of the gbox? Look for a previous implementation of the grid cloner approach."
  },
  {
    "objectID": "manual/Visualization/index.html",
    "href": "manual/Visualization/index.html",
    "title": "Backends for visualization",
    "section": "",
    "text": "VPL has two forms of visualization that are specific to a model: (i) a network representation of the graph via draw() and (ii) a 3D rendering of a graph or scene via render(). Both forms of visualization rely on the Makie visualization ecosystem built into Julia. Makie allows for different backends that are relevant in different context of code execution. The backends are specified with the argument backend to either of the visualization methods:\n\nbackend = \"native\": A native, desktop-based backend that requires an OpenGL enabled graphics card (based on GLMakie). This is the default backend used by VPL. It provides interactive 2D (for draw()) or 3D (for render()) visualization.\nbackend = \"web\": A web-based backend that requires a WebGL enabled web browser (based on WGLMakie). It provides interactive 2D (for draw()) or 3D (for render()) visualization.\nbackend = \"vector\": A vector graphics version of the visualization (based on CairoMakie. Different vector engines can be specified via the file argument including file = \"pdf\" (default) and file = \"svg\". It does not provide interactive visualization and it is meant for static documents (or for exporting pdf or svg versions of the visualization). This backend only works with draw(), not render()\n\nDepending on the context where the code is being executed and the backend being used, different forms of visualization will be obtained with different scenarios listed below (see section on Visualization). It is also possible to export static versions of any visualization in a wide range of formats (see section on Export visualization)."
  },
  {
    "objectID": "manual/Visualization/index.html#terminal",
    "href": "manual/Visualization/index.html#terminal",
    "title": "Backends for visualization",
    "section": "Terminal",
    "text": "Terminal\nThis means the code is ran from within the Julia REPL inside a terminal or command prompt (i.e., no IDE or notebook environment):\n\nUsing the native backend will trigger an external window (entitled Makie) where an interactive OpenGL visualization will be rendered. The interactivity provided allows zooming and moving the camera around the visualization.\nUsing the web backend will open a browser tab (unless there are some OS settings preventing, in which case a local IP address will be printed to the REPL and the user will have to manually input it into the browser) which an intetactive WebGL version will be rendered. The behaviour will be analogous to the natibe backend but note that this backend is still experimental (at the time of writing this documentation) so one should expect the ocasional bug.\nThe vector backend will not display any visual output in this context. One can still export the resulting figure (see section on Export visualization)."
  },
  {
    "objectID": "manual/Visualization/index.html#live-interactive-notebook",
    "href": "manual/Visualization/index.html#live-interactive-notebook",
    "title": "Backends for visualization",
    "section": "Live interactive notebook",
    "text": "Live interactive notebook\nThis means the code is running withn a Jupyter or Pluto notebook and they an active kernel or Julia session running in the background. Note that a notebook that is stored online will not be live unless it is hosted by a server that can run notebooks such as Binder or Google colab.\n\nThe native backend will have the same behaviour as in the terminal by default. If one wants an inline visualization (i.e., for the visualization output to show next to the code cell) one has to pass the argument inline = true. This will create a static image of the 2D or 3D with the initial camera settings (not interactive).\nThe web backend will generate the visualization output next to the code cell and it will be interactive as long as the kernel or background Julia session keeps running.\nThe vector backend will display the static output next to the code cell (but only if it is using the svg engine, which is the default)."
  },
  {
    "objectID": "manual/Visualization/index.html#visual-studio-code",
    "href": "manual/Visualization/index.html#visual-studio-code",
    "title": "Backends for visualization",
    "section": "Visual Studio Code",
    "text": "Visual Studio Code\nIDEs that support Julia such as Visual Studio Code will generally have a plot pane where visualization output is stored. This can generally be turn off (in which case the behaviour of the IDE will be the same as running from a terminal). VPL has been tested with Visual Studio Code and the Julia extension and, if the plot pane is active, the behaviour will be equivalent to a live interative notebook:\n\nThe native backend will trigger an external window by default unless we specify inline = true, in which case a static version of the output will show up in the plot pane.\nThe web backend will generate the visualization output in the plot pane and it will be interactive.\nThe vector backend will generate the static visualization output in the plot pane."
  },
  {
    "objectID": "manual/Visualization/index.html#document-generation",
    "href": "manual/Visualization/index.html#document-generation",
    "title": "Backends for visualization",
    "section": "Document generation",
    "text": "Document generation\nThis category includes a file that is processed by Quarto, Documenter, Weave or Literate. In all of these cases the final output will remain static while the visualization output should be generated inline (i.e., next to the code chunk). The following behavior has been observed with Quarto (other document generation methods have not been fully tested with VPL but are expected to behave similarly):\n\nFor the native backend, a static snapshot of the visualization will always be inlined (even when inline = false). The result would be as in the inline visualization of interactive notebooks.\nThe web backend will not generate any visualization in the final document as this backend always requires interactivity.\nThe vector backend will display the static ouput as in interactive notebooks."
  },
  {
    "objectID": "manual/Visualization/index.html#on-a-headless-server",
    "href": "manual/Visualization/index.html#on-a-headless-server",
    "title": "Backends for visualization",
    "section": "On a headless server",
    "text": "On a headless server\nIt will be possible to use the visualization tools even when running VPL in a headless system (e.g., a high performance computing cluster). The folliowing is based on the documentation on Makie, it has not been tested with VPL:\n\nThe native backend will require X11 forwarding to render on the local machine or use VirtualGL technology.\nThe web backend will work if a Javascript serve is setup to serve the HTML content from the remote system (see here for details).\nThe vector backend will generate the images correctly but the user will have to export them to pdf or svg files."
  },
  {
    "objectID": "manual/viz_backends/index.html",
    "href": "manual/viz_backends/index.html",
    "title": "Backends for visualization",
    "section": "",
    "text": "VPL has two forms of visualization that are specific to a model: (i) a network representation of the graph via draw() and (ii) a 3D rendering of a graph or scene via render(). Both forms of visualization rely on the Makie visualization ecosystem built into Julia. Makie allows for different backends that are relevant in different context of code execution. The backends are specified with the argument backend to either of the visualization methods:\n\nbackend = \"native\": A native, desktop-based backend that requires an OpenGL enabled graphics card (based on GLMakie). This is the default backend used by VPL. It provides interactive 2D (for draw()) or 3D (for render()) visualization.\nbackend = \"web\": A web-based backend that requires a WebGL enabled web browser (based on WGLMakie). It provides interactive 2D (for draw()) or 3D (for render()) visualization.\nbackend = \"vector\": A vector graphics version of the visualization (based on CairoMakie. Different vector engines can be specified via the file argument including file = \"pdf\" (default) and file = \"svg\". It does not provide interactive visualization and it is meant for static documents (or for exporting pdf or svg versions of the visualization).\n\nDepending on the context where the code is being executed and the backend being used, different forms of visualization will be obtained with different scenarios listed below (see section on Visualization). It is also possible to export static versions of any visualization in a wide range of formats (see section on Export visualization)."
  },
  {
    "objectID": "manual/viz_backends/index.html#terminal",
    "href": "manual/viz_backends/index.html#terminal",
    "title": "Backends for visualization",
    "section": "Terminal",
    "text": "Terminal\nThis means the code is ran from within the Julia REPL inside a terminal or command prompt (i.e., no IDE or notebook environment):\n\nUsing the native backend will trigger an external window (entitled Makie) where an interactive OpenGL visualization will be rendered. The interactivity provided allows zooming and moving the camera around the visualization.\nUsing the web backend will open a browser tab (unless there are some OS settings preventing, in which case a local IP address will be printed to the REPL and the user will have to manually input it into the browser) which an intetactive WebGL version will be rendered. The behaviour will be analogous to the natibe backend but note that this backend is still experimental (at the time of writing this documentation) so one should expect the ocasional bug.\nThe vector backend will not display any visual output in this context. One can still export the resulting figure (see section on Export visualization)."
  },
  {
    "objectID": "manual/viz_backends/index.html#live-interactive-notebook",
    "href": "manual/viz_backends/index.html#live-interactive-notebook",
    "title": "Backends for visualization",
    "section": "Live interactive notebook",
    "text": "Live interactive notebook\nThis means the code is running withn a Jupyter or Pluto notebook and they an active kernel or Julia session running in the background. Note that a notebook that is stored online will not be live unless it is hosted by a server that can run notebooks such as Binder or Google colab.\n\nThe native backend will have the same behaviour as in the terminal by default. If one wants an inline visualization (i.e., for the visualization output to show next to the code cell) one has to pass the argument inline = true. This will create a static image of the 2D or 3D with the initial camera settings (not interactive).\nThe web backend will generate the visualization output next to the code cell and it will be interactive as long as the kernel or background Julia session keeps running.\nThe vector backend will display the static output next to the code cell (but only if it is using the svg engine, which is the default)."
  },
  {
    "objectID": "manual/viz_backends/index.html#visual-studio-code",
    "href": "manual/viz_backends/index.html#visual-studio-code",
    "title": "Backends for visualization",
    "section": "Visual Studio Code",
    "text": "Visual Studio Code\nIDEs that support Julia such as Visual Studio Code will generally have a plot pane where visualization output is stored. This can generally be turn off (in which case the behaviour of the IDE will be the same as running from a terminal). VPL has been tested with Visual Studio Code and the Julia extension and, if the plot pane is active, the behaviour will be equivalent to a live interative notebook:\n\nThe native backend will trigger an external window by default unless we specify inline = true, in which case a static version of the output will show up in the plot pane.\nThe web backend will generate the visualization output in the plot pane and it will be interactive.\nThe vector backend will generate the static visualization output in the plot pane."
  },
  {
    "objectID": "manual/viz_backends/index.html#document-generation",
    "href": "manual/viz_backends/index.html#document-generation",
    "title": "Backends for visualization",
    "section": "Document generation",
    "text": "Document generation\nThis category includes a file that is processed by Quarto, Documenter, Weave or Literate. In all of these cases the final output will remain static while the visualization output should be generated inline (i.e., next to the code chunk). The following behavior has been observed with Quarto (other document generation methods have not been fully tested with VPL but are expected to behave similarly):\n\nFor the native backend you will have to use inline = true as otherwise the final document will not have any visualizations included in it. The result would be as in the inline visualization of interactive notebooks.\nThe web backend will not generate any visualization in the final document as this backend always requires interactivity.\nThe vector backend will display the static ouput as in interactive notebooks."
  },
  {
    "objectID": "manual/viz_backends/index.html#on-a-headless-server",
    "href": "manual/viz_backends/index.html#on-a-headless-server",
    "title": "Backends for visualization",
    "section": "On a headless server",
    "text": "On a headless server\nIt will be possible to use the visualization tools even when running VPL in a headless system (e.g., a high performance computing cluster). The folliowing is based on the documentation on Makie, it has not been tested with VPL:\n\nThe native backend will require X11 forwarding to render on the local machine or use VirtualGL technology.\nThe web backend will work if a Javascript serve is setup to serve the HTML content from the remote system (see here for details).\nThe vector backend will generate the images correctly but the user will have to export them to pdf or svg files."
  },
  {
    "objectID": "manual/VPL.html",
    "href": "manual/VPL.html",
    "title": "Dynamic graph creation and manipulation",
    "section": "",
    "text": "A model in VPL is a (discrete) dynamical model that describes the time evolution of one or more entities (i.e. objects of type graph). Each graph (usually assumed to be an individual plant) is characterized by a series of nodes (usually organs) that are represented by nodes in a graph. Each node is defined by its own state, including (if applicable) a description of its geometry, color, optical propertes, etc. The dynamic simulation of a graph consists of the creation and destruction of nodes via graph rewriting rules, and changes to the internal state of its nodes with the help of queries.\nThe 3D structure of a graph is generated by processing its nodes using a Turtle procedural geometry approach (i.e. inspired on Logo’s turtle graphs as used in L-systems) and following the topology of the graph. This 3D structure may be used for visualization using a 3D renderer or for simulating spatial processes.\nVPL does not provide a domain-specific language to implement rules and queries. Rather, they are defined by functions which are stored in objects of types Rule and Query, respectively. Similarly, the nodes of a graph can be of any user-defined type, as long as the user defines the necessary methods to support specific functionality (e.g. the feedgeom! method to generate geometry).\nVPL is designed around data types and methods. Building a model in VPL typically requires:\n\nDefining types for the different classes of nodes of a graph\nCreating rules and queries based on these types\nCreating graphs by combining rules and the initial states of the graphs\nCreating additional elements in the scene (e.g. soil)\n\nA simulation in VPL consists of executing rules iteratively and, within each iteration:\n\nUse queries to select subset of nodes and modify their states.\nModify graph-level variables directly.\nUse algorithms in VPL to simulate interactions among nodes or between nodes and their environment.\n\nIn addition, VPL allows visualizing the results of a simulation by: * 3D rendering of the generated scenes * Network graph representing the nodes in the graph\nVPL is designed to facilitate modular model development, such as using different types of graphs in the same simulation, alternative visualizations of the same scene by mapping internal states of nodes to colors, or including multiple ray tracers in the same simulation. Users may also create their own data types that include graphs as fields or to nest graphs within other graphs."
  },
  {
    "objectID": "manual/VPL.html#graph-construction-algebra",
    "href": "manual/VPL.html#graph-construction-algebra",
    "title": "Dynamic graph creation and manipulation",
    "section": "Graph-construction algebra",
    "text": "Graph-construction algebra\nWhen initializing a graph and when specifying a graph rewriting rule it is necessary to indicate the topological relationship between the nodes being added to a graph (i.e. effectively we build graphs by appending sub-graphs). In order to facilitate the description of these relationships, a simple algebra is defined for all objects that inherit from Node.\nThe + operator indicates a linear parent-child dependency between the operands. For example, M() + L() indicates that the object generated by L() is a child of M(). A branching point is introduced by enclosing the children of a node within () and separating the different branches with “,”. For example, (M(1) + (L(2), L(3)) + M(4) + L(5)) creates a tree that starts with M(1), has 3 children (L(2), L(3) and M(4)) and M(4) has a child L(5).\nA graph always keep tracks of two special nodes: the root and the insertion point. The root is the node that has no parent. When you use a graph rewriting rule (see below) to replace a node a with a graph that has a root node b, the result is that node a is replaced by node b and will inherit all the children and parent from node a (plus the children that b already had in the replacement graph).\nAn insertion point is the node of a graph where new nodes will be connected to when using the + operator. Branches do not modify the insertion point of an existing graph, but linear addition of nodes will always update the insertion point to the last node. Thus, these two expressions produce the same tree structure but with different insertion points: M(1) + (L(2), L(3)) + M(4) + L(5) and M(1) + (L(2), L(3), M(4) + L(5)). In the first case, the insertion point becomes the node L(5) but in the second case it remains at M(1). Keeping track of the insertion point of a graph is important when building a graph in several steps."
  },
  {
    "objectID": "manual/VPL.html#matching-relationships-among-nodes",
    "href": "manual/VPL.html#matching-relationships-among-nodes",
    "title": "Dynamic graph creation and manipulation",
    "section": "Matching relationships among nodes",
    "text": "Matching relationships among nodes\nSometimes the lhs function needs to check the relationships between nodes inside a graph (e.g. match all leaves that belong to a particular branch of a graph). In order achieve that, one can use the functions hasParent() and hasChildren() to check for inmediate connections (i.e. effectively to check whether the node is a root or a leaf in the graph) whereas hasAncestor() and hasDescendant() allow traversing the graph and finding any connected node that matches a specific query. If we need to extract the contents of the node, we may use the corresponding functions parent(), children(), ancestor() and descendant(). Note that children() will return all the children nodes as a tuple, but the rest of functions only return one node at a time. All these functions take a Context object as input and return either true or false (for the functions that start with has) or a Context or tuple of Context objects for the functions that extract the actual connected node. These methods may also be used inside the rhs function of rules. However, to avoid code repetition (and for performance reasons), it is recommended to capture the Context objects of connected in the lhs function and pass them to the rhs as described below (see below)."
  },
  {
    "objectID": "manual/VPL.html#capturing-the-context-of-a-node",
    "href": "manual/VPL.html#capturing-the-context-of-a-node",
    "title": "Dynamic graph creation and manipulation",
    "section": "Capturing the context of a node",
    "text": "Capturing the context of a node\nIn some scenarios, knowing the relationship between nodes in the graph is not sufficient, because data stored inside those related nodes is required in the rhs function of a rule. In those cases, an extra argument to the constructor for a Rule is required (captures = true) to indicate that this rule will pass additional data from the lhs to the rhs function. Then, the lhs function should return a tuple, where the first element is still true or false (to indicate whether the rule matches a node) and the second element is a tuple of Context objects associated to the nodes being matched. If no match occurs, it is sufficient to return (false, ()), where () indicates an empty tuple. The rhs function should then be a function that takes as first argument the Context object of the node being replaced, and an additional argument for every Context object being captured on the lhs function and passed to the rhs function."
  },
  {
    "objectID": "manual/VPL.html#execution-of-rules",
    "href": "manual/VPL.html#execution-of-rules",
    "title": "Dynamic graph creation and manipulation",
    "section": "Execution of rules",
    "text": "Execution of rules\nRules are executed in the same order in which they are added to the graph object. Then, the lhs part of each rule is tested against all nodes of the specified type in the same order in which they were added to the graph. Similarly, the rhs part of a rule will be applied to those nodes that matched the lhs part, in the same order as in the matching.\n\nThe lhs part of all the rules are executed first and VPL will check that each node is not matched by more than rule. In case there is more than one match, an error will be generated. After all the lhs pars are executed, then the rhs parts are executed on the matched nodes. Although generating an error may seem restrictive, the reasoning for this approach is as follows:\n\nGraph rewriting is, conceptually, a parallel operation, so two rules cannot replace the same node as that would mean the result depends on the order in which the rules are executed.\nNew nodes will be generated by graph rewriting rules that could be matched by the lhs of other graph rewriting rules. To guarantee that all rules rewrite the same graph, all nodes that need to be replaced are identified before any rhs function is executed.\n\nIn essence, you need to program your model such that it does not rely on any specific order of execution of the graph rewriting rules."
  },
  {
    "objectID": "tutorials/algae/index.html",
    "href": "tutorials/algae/index.html",
    "title": "Algae growth",
    "section": "",
    "text": "The model described here is based on the non-branching model of algae growth proposed by Lindermayer as one of the first L-systems.\nFirst, we need to load the VPL metapackage, which will automatically load all the packages in the VPL ecosystem.\nusing VPL \nThe rewriting rules of the L-system are as follows:\naxiom: A\nrule 1: A \\(\\rightarrow\\) AB\nrule 2: B \\(\\rightarrow\\) A\nIn VPL, this L-system would be implemented as a graph where the nodes can be of type A or B and inherit from the abstract type Node. As indicated in the Julia Basics section, it is advised to include type definitions in a module to avoid having to restart the Julia session whenever we want to redefine them. Because each module is an independent namespace, we need to import Node from the VPL package inside the module:\nmodule algae\n    import VPL: Node\n    struct A <: Node end\n    struct B <: Node end\nend\nimport .algae\nNote that in this very example we do not need to store any data or state inside the nodes, so types A and B do not require fields.\nThe axiom is simply defined as an instance of type of A:\n\naxiom = algae.A()\n\nMain.algae.A()\n\n\nThe rewriting rules are implemented in VPL as objects of type Rule. In VPL, a rewriting rule substitutes a node in a graph with a new node or subgraph and is therefore composed of two parts:\n\nA condition that is tested against each node in a graph to choose which nodes to rewrite.\n\nA subgraph that will replace each node selected by the condition above.\n\nIn VPL, the condition is split into two components:\n\nThe type of node to be selected (in this example that would be A or B).\n\nA function that is applied to each node in the graph (of the specified type) to indicate whether the node should be selected or not. This function is optional (the default is to select every node of the specified type).\n\nThe replacement subgraph is specified by a function that takes as input the node selected and returns a subgraph defined as a combination of node objects. Subgraphs (which can also be used as axioms) are created by linearly combining objects that inherit from Node. The operation + implies a linear relationship between two nodes and [] indicates branching.\nThe implementation of the two rules of algae growth model in VPL is as follows:\n\nrule1 = Rule(algae.A, rhs = x -> algae.A() + algae.B())\nrule2 = Rule(algae.B, rhs = x -> algae.A())\n\nRule replacing nodes of type Main.algae.B without context capturing.\n\n\nNote that in each case, the argument rhs is being assigned an anonymous (aka lambda) function. This is a function without a name that is defined directly in the assigment to the argument. That is, the Julia expression x -> A() + B() is equivalent to the following function definition:\n\nfunction rule_1(x)\n    algae.A() + algae.B()\nend\n\nrule_1 (generic function with 1 method)\n\n\nFor simple rules (especially if the right hand side is just a line of code) it is easier to just define the right hand side of the rule with an anonymous function rather than creating a standalone function with a meaningful name. However, standalone functions are easier to debug as you can call them directly from the REPL.\nWith the axiom and rules we can now create a Graph object that represents the algae organism. The first argument is the axiom and the second is a tuple with all the rewriting rules:\n\norganism = Graph(axiom, rules = (rule1, rule2))\n\nDynamic graph with 1 nodes of types Main.algae.A and 2 rewriting rules.\n\n\nIf we apply the rewriting rules iteratively, the graph will grow, in this case representing the growth of the algae organism. The rewriting rules are applied on the graph with the function rewrite!():\nrewrite!(organism)\nSince there was only one node of type A, the only rule that was applied was rule1, so the graph should now have two nodes of types A and B, respectively. We can confirm this by drawing the graph. We do this with the function draw() which will always generate the same representation of the graph, but different options are available depending on the context where the code is executed. By default, draw() will create a new window where an interactive version of the graph will be drawn and one can zoom and pan with the mouse (in this online document a static version is shown, see Backends for details):\ndraw(organism)\n\n\n\n\n\nNotice that each node in the network representation is labelled with the type of node (A or B in this case) and a number in parenthesis. This number is a unique identifier associated to each node and it is useful for debugging purposes (this will be explained in more advanced examples).\nApplying multiple iterations of rewriting can be achieved with a simple loop:\nfor i in 1:4\n    rewrite!(organism)\nend\nANd we can verify that the graph grew as expected:\ndraw(organism)\n\n\n\n\n\nThe network is rather boring as the system is growing linearly (no branching) but it already illustrates how graphs can grow rapidly in just a few iterations. Remember that the interactive visualization allows adjusting the zoom, which is handy when graphs become large."
  },
  {
    "objectID": "tutorials/binary_tree/index.html",
    "href": "tutorials/binary_tree/index.html",
    "title": "Binary tree",
    "section": "",
    "text": "The model requires three types of nodes:\nMeristem: These are the nodes responsible for growth of new organs in our binary tree. They contain no data or geometry (i.e. they are a point in the 3D structure).\nInternode: The structural elements that make the binary tree, which is a simple tree made of sticks.\nTreeNode: What is left after a meristem produces a new organ. They contain no data or geometry (so also a point) but are required to keep the branching structure of the tree. Note that we cannot call this data type Node as that is a type already defined by VPL.\nIn a similar fashion to the previous example, internodes are represented by prisms, but unlike before, the length of the prism will change in time, emulating the growth of the tree. For that reason, we need to make the type mutable.\nAlso, in order to simulate growth of the 3D binary tree, we need to define a parameter describing the relative rate at which each internode elongate in each iteration of the simulation. Graphs in VPL can store an object of any user-defined type that will me made accessible to graph rewriting rules and queries. Such object is useful to store parameters (in which case we make them immutable) or state variables that cannot be associated to any specific organ (in which case we would make the object mutable). For this example, we define a data type treeparams that holds the relative growth rate (or growth factor) of the internodes of a tree.\n\nusing VPL\n\nmodule btree\n    import VPL\n    # Meristem\n    struct Meristem <: VPL.Node end\n    # Node\n    struct Node <: VPL.Node end\n    # Internode\n    mutable struct Internode <: VPL.Node\n        length::Float64\n    end\n    # Graph-level variables\n    struct treeparams\n        growth::Float64\n    end\nend\n\nMain.btree\n\n\nAs always, the 3D structure and the color of each type of node are implemented with the feedgeom! and feedcolor! methods. In this case, only the internodes have a 3D representation, so these methods are defined for this type only.\nfunction VPL.feedgeom!(turtle::MTurtle, i::btree.Internode)\n    HollowCube!(turtle, l = i.length, h = i.length/10, w = i.length/10, move = true)\n    return nothing\nend\nfunction VPL.feedcolor!(turtle::GLTurtle, i::btree.Internode)\n    feedcolor!(turtle, RGB(0,1,0))\n    return nothing\nend\nThe growth rule of our binary tree is simple: meristems are replaced a by tree node and two branches that split at specific angles. Each branch is then composed of an internode and ends in a meristem. The two branches are implemented by enclosing with square brackets and separating by commas (like when you create an array of numbers in Julia). Since a binary tree is actually a 2D structure but we want to have it 3D, we add an extra rotation, such that the new branches growing from the apical meristems are not aligned with the preceding internodes. The key is to imagine the turtle in your head and keep track of the different rotations as it moves through the rule. A concept to keep in mind there is that the position and orientation of the turtle is always the same at the beginning of each branch (i.e. essentially, at each branching point, the turtle splits into two clones that move along the tree independently).\n\nrule = Rule(btree.Meristem, rhs = mer -> btree.Node() + (RU(-60.0) + btree.Internode(0.1) + RH(90.0) + btree.Meristem(), \n                                                   RU(60.0)  + btree.Internode(0.1) + RH(90.0) + btree.Meristem()))\n\nRule replacing nodes of type Main.btree.Meristem without context capturing.\n\n\nA binary tree initializes as a meristem, so the axiom can be constructed simply as:\n\naxiom = btree.Internode(0.1) + btree.Meristem()\n\nVPL.Core.StaticGraph(Dict{Int64, Any}(2 => VPL.Core.GraphNode{Main.btree.Meristem}(Main.btree.Meristem(), Set{Int64}(), 1, 2), 1 => VPL.Core.GraphNode{Main.btree.Internode}(Main.btree.Internode(0.1), Set([2]), missing, 1)), Dict{DataType, Set{Int64}}(Main.btree.Internode => Set([1]), Main.btree.Meristem => Set([2])), 1, 2)\n\n\nAnd the object for the tree can be constructed as before, by passing the axiom and the graph rewriting rules, but in this case also with the object with growth-related parameters.\n\ntree = Graph(axiom, Tuple(rule), btree.treeparams(0.5))\n\nDynamic graph with 2 nodes of types Main.btree.Internode,Main.btree.Meristem and 1 rewriting rules.\nDynamic graph variables stored in struct of type Main.btree.treeparams\n\n\nNote that so far we have not included any code to simulate growth of the internodes. The reason is that, as elongation of internotes does not change the topology of the graph (it simply changes the data stored in certain nodes), this process does not need to be implemented with graph rewriting rules. Instead, we will use a combination of a query (to identify which nodes need to be altered) and direct modification of these nodes. A Query object is a like a Rule but without a right-hand side. In this case, we just want to identify those nodes of type Internode, so we do not need to specify a left-hand side either. Instead, we simply create the query as:\n\ngetInternode = Query(btree.Internode)\n\nQuery object for nodes of type Main.btree.Internode\n\n\nIf we apply the query to a graph using the apply function, we will get an array of all the nodes that match the query, allow for direct manipulation of their contents. To help organize the code, we will create a function that simulates growth by multiplying the length argument of all internodes in a tree by the growth parameter defined in the above:\n\nfunction elongate!(tree, query)\n    for x in apply(tree, query)\n        x.length = x.length*(1.0 + vars(tree).growth)\n    end\nend\n\nelongate! (generic function with 1 method)\n\n\nNote that we use vars on the Graph object to extract the object that was stored inside of it. Also, as this function will modify the graph which is passed as input, we append an ! to the name (this not a special syntax of the language, its just a convention in the Julia community, which is ). Also, in this case, the query object is kept separate from the graph. We could have also store inside the graph like we did for the parameter grow. We could also have packaged the graph and the query into another type representing an individual tree. This is entirely up to the user and indicates that a model can be implemented in many differences ways with VPL.\nSimulating the growth a tree is a matter of elongating the internodes and applying the rules to create new internodes:\n\nfunction growth!(tree, query)\n    elongate!(tree, query)\n    rewrite!(tree)\nend\n\ngrowth! (generic function with 1 method)\n\n\nand a simulation for n steps is achieved with a simple loop:\n\nfunction simulate(tree, query, nsteps)\n    new_tree = deepcopy(tree)\n    for i in 1:nsteps\n        growth!(new_tree, query)\n    end\n    return new_tree\nend\n\nsimulate (generic function with 1 method)\n\n\nNotice that the simulate function creates a copy of the object to avoid overwriting it. If we run the simulation for a couple of steps\n\nnewtree = simulate(tree, getInternode, 2)\n\nDynamic graph with 26 nodes of types Main.btree.Node,Main.btree.Internode,Main.btree.Meristem,VPL.Geom.RH{Float64},VPL.Geom.RU{Float64} and 1 rewriting rules.\nDynamic graph variables stored in struct of type Main.btree.treeparams\n\n\nThe binary tree after two iterations has two branches, as expected:\n\nrender(newtree)\n\n\n\n\nNotice how the lengths of the prisms representing internodes decreases as the branching order increases, as the internodes are younger (i.e. were generated fewer generations ago). Further steps will generate a structure that is more tree-like.\n\nnewtree = simulate(newtree, getInternode, 10)\nrender(newtree)"
  },
  {
    "objectID": "tutorials/random_binary_forest/index.html",
    "href": "tutorials/random_binary_forest/index.html",
    "title": "Random binary tree",
    "section": "",
    "text": "In this example we extend the binary tree example into a random binary forest, where each tree is described by a separate graph object and parameters driving the growth of these trees vary across individuals following a predefined distribution.\nThe data types, rendering methods and growth rules are the same as in the binary tree example:\nThe main difference with respect to the binary tree is that the growth parameter will differ across individuals. Also, the starting point of the turtle will differ per individual. To achieve this we need to:\nThe code for elongating the internodes to simulate growth remains the same as for the binary tree example\nLet’s simulate a forest of 10 x 10 binary trees with a distance between (and within) rows of 2 meters. First we generate the original positions of the trees. For the position we just need to pass a Vec object with the x, y, and z coordinates of the location of each tree. The code below will generate a matrix with the coordinates:\nWe now simulate the values of the growth parameter, by sampling values for a normal distribution (in practice you would determine this distribution from experiments). We can implement a function that returns random values with the desired characteristics but take into account that randn implements the standard Normal distribution (so mean = 0 and standard deviation = 1) so we need to scale it\nYou may also use the Distributions Julia package (you will need to install it first) that allows to construct different distributions and sample from them. For now, let’s work with this ad-hoc function but before we use it to generate the growth parameters of the different trees, let’s visualize it using the Plots package (as before, you need to install it first if you have not done so already):\nSo our trees will have, on average, a relative growth rate of 0.5 (like in the binary tree example) but each individual tree can have any value, mostly between 0.2 and 0.8. Let’s generate the growth parameters for the 100 trees in our simulation:\nNow we can create our random forest of binary trees by calling the create_tree function we defined earlier with the correct origins and growth parameter\nThe object forest contains an array of binary trees. Each tree is a different Graph, with its own nodes, rewriting rules and variables. This avoids having to create a large graphs to include all the plants in a simulation. Below we will run a simulation, first using a sequential approach (i.e. using one core) and then using multiple cores in our computers (please check https://docs.julialang.org/en/v1/manual/multi-threading/ if the different cores are not being used as you may need to change some settings in your computer)."
  },
  {
    "objectID": "tutorials/random_binary_forest/index.html#sequential-simulation",
    "href": "tutorials/random_binary_forest/index.html#sequential-simulation",
    "title": "Random binary tree",
    "section": "Sequential simulation",
    "text": "Sequential simulation\nWe can simulate the growth of each tree by applying the method simulate to each tree, creating a new version of the forest (the code below is an array comprehension)\nnewforest = [simulate(tree, getInternode, 2) for tree in forest];\nAnd we can render the forest with the function render as in the binary tree example but passing the whole forest at once\n\nrender(newforest)\n\n\n\n\nIf we iterate 4 more iterations we will start seeing the different individuals diverging in size due to the differences in growth rates\n\nnewforest = [simulate(tree, getInternode, 4) for tree in newforest];\nrender(newforest)"
  },
  {
    "objectID": "tutorials/random_binary_forest/index.html#multithreaded-simulation",
    "href": "tutorials/random_binary_forest/index.html#multithreaded-simulation",
    "title": "Random binary tree",
    "section": "Multithreaded simulation",
    "text": "Multithreaded simulation\nIn the previous section, the simulation of growth was done sequentially, one tree after another (since the growth of a tree only depends on its own parameters). However, this can also be executed in multiple threads. In this case we use an explicit loop and execute the iterations of the loop in multiple threads using the macro @threads. Note that the rendering function can also be ran in parallel (i.e. the geometry will be generated separately for each plant and the merge together):\n\nusing Base.Threads\nnewforest = deepcopy(forest)\n@threads for i in 1:length(forest)\n    newforest[i] = simulate(forest[i], getInternode, 6)\nend\nrender(newforest, parallel = true)\n\n\n\n\nAn alternative way to perform the simulation is to have an outer loop for each timestep and an internal loop over the different trees. Although this approach is not required for this simple model, most FSP models will probably need such a scheme as growth of each individual plant will depend on competition for resources with neighbouring plants. In this case, this approach would look as follows:\n\nnewforest = deepcopy(forest)\nfor step in 1:6\n    @threads for i in 1:length(newforest)\n        newforest[i] = simulate(newforest[i], getInternode, 1)\n    end\nend\nrender(newforest, parallel = true)"
  },
  {
    "objectID": "tutorials/relational_queries/index.html",
    "href": "tutorials/relational_queries/index.html",
    "title": "Relational queries",
    "section": "",
    "text": "In this example we illustrate how to test relationships among nodes inside queries. Relational queries allow to establish relationships between nodes in the graph, which generally requires a intimiate knowledge of the graph. For this reason, relational queries are inheretly complex as graphs can become complex and there may be solutions that do not require relational queries in many instances. Nevertheless, they are integral part of VPL and can sometimes be useful. As they can be hard to grasp, this tutorial will illustrate with a relatively simple graph a series of relational queries with increasing complexity with the aim that users will get a better understanding of relational queries. For this purpose, an abstract graph with several branching levels will be used, so that we can focus on the relations among the nodes without being distracted by case-specific details.\nThe graph will be composed of two types of nodes: the inner nodes (A and C) and the leaf nodes (B). Each leaf node will be identified uniquely with an index and the objective is to write queries that can identify a specific subset of the leaf nodes, without using the data stored in the nodes themselves. That is, the queries should select the right nodes based on their relationships to the rest of nodes in the graph. Note that C nodes contain a single value that may be positive or negative, whereas A nodes contain no data.\nAs usual, we start with defining the types of nodes in the graph\nWe generate the graph directly, rather than with rewriting rules. The graph has a motif that is repeated three times (with a small variation), so we can create the graph in a piecewise manner. Note how we can use the function sum to add nodes to the graph (i.e. sum(A() for i in 1:3) is equivalent to A() + A() + A())\nBy default, VPL will use as node label the type of node and the internal ID generated by VPL itself. This ID is useful if we want to extract a particular node from the graph, but it is not controlled by the user. However, the user can specialized the function node_label() to specify exactly how to label the nodes of a particular type. In this case, we want to just print A or C for nodes of type A and C, whereas for nodes of type B we want to use the ID field that was stored inside the node during the graph generation.\nTo clarify, the id argument of the function node_label() refers to the internal id generated by VPL (used by the default method for node_label(), whereas the the first argument is the data stored inside a node (in the case of B nodes, there is a field called ID that will not be modified by VPL as that is user-provided data).\nThe goal of this exercise is then to write queries that retrieve specific B nodes (without using the data stored in the node in the query, that is, we have to identify nodes based on their topological connections to other nodes)."
  },
  {
    "objectID": "tutorials/relational_queries/index.html#all-nodes-of-type-b",
    "href": "tutorials/relational_queries/index.html#all-nodes-of-type-b",
    "title": "Relational queries",
    "section": "All nodes of type B",
    "text": "All nodes of type B\nFirst, we create the query object. In this case, there is no special condition as we want to retrieve all the nodes of type B\n\nQ1 = Query(Q.B)\n\nQuery object for nodes of type Main.Queries.B\n\n\nApplying the query to the graph returns an array with all the B nodes\n\nA1 = apply(graph, Q1)\n\n13-element Vector{Main.Queries.B}:\n Main.Queries.B(7)\n Main.Queries.B(8)\n Main.Queries.B(3)\n Main.Queries.B(10)\n Main.Queries.B(5)\n Main.Queries.B(6)\n Main.Queries.B(2)\n Main.Queries.B(12)\n Main.Queries.B(1)\n Main.Queries.B(11)\n Main.Queries.B(13)\n Main.Queries.B(9)\n Main.Queries.B(4)\n\n\nFor the remainder of this tutorial, the code will be hidden by default to allow users to try on their own."
  },
  {
    "objectID": "tutorials/relational_queries/index.html#node-containing-value-13",
    "href": "tutorials/relational_queries/index.html#node-containing-value-13",
    "title": "Relational queries",
    "section": "Node containing value 13",
    "text": "Node containing value 13\nSince the B node 13 is the leaf node of the main branch of the graph (e.g. this could be the apical meristem of the main stem of a plant), there are no rotations between the root node of the graph and this node. Therefore, the only condition require to single out this node is that it has no ancestor node of type C.\nChecking whether a node has an ancestor that meets a certain condition can be achieved with the function hasAncestor(). Similarly to the condition of the Query object, the hasAncestor() function also has a condition, in this case applied to the parent node of the node being tested, and moving upwards in the graph recursively (until reaching the root node). Note that, in order to access the object stored inside the node, we need to use the data() function, and then we can test if that object is of type C. The B node 13 is the only node for which hasAncestor() should return false:\n\n\n\nShow the code\nfunction Q2_fun(n)\n    check, steps = hasAncestor(n, x -> data(x) isa Q.C)\n    !check\nend\n\n\nQ2_fun (generic function with 1 method)\n\n\nAs before, we just need to apply the Query object to the graph:\n\n\nShow the code\nQ2 = Query(Q.B, Q2_fun)\nA2 = apply(graph, Q2)\n\n\n1-element Vector{Main.Queries.B}:\n Main.Queries.B(13)"
  },
  {
    "objectID": "tutorials/relational_queries/index.html#nodes-containing-values-1-2-and-3",
    "href": "tutorials/relational_queries/index.html#nodes-containing-values-1-2-and-3",
    "title": "Relational queries",
    "section": "Nodes containing values 1, 2 and 3",
    "text": "Nodes containing values 1, 2 and 3\nThese three nodes belong to one of the branch motifs repeated through the graph. Thus, we need to identify the specific motif they belong to and chose all the B nodes inside that motif. The motif is defined by an A node that has a C child with a negative val and parent node C with positive val. This A node should then be 2 nodes away from the root node to separate it from upper repetitions of the motif. Therefore, we need to test for two conditions, first find those nodes inside a branch motif, then retrieve the root of the branch motif (i.e., the A node described in the above) and then check the distance of that node from the root:\n\n\nShow the code\nfunction branch_motif(p)\n    data(p) isa Q.A && \n    hasDescendent(p, x -> data(x) isa Q.C && data(x).val < 0.0) &&\n    hasAncestor(p, x -> data(x) isa Q.C && data(x).val > 0.0)[1]\nend\n\nfunction Q3_fun(n, nsteps)\n    # Condition 1\n    check, steps = hasAncestor(n, branch_motif)\n    !check && return false\n    # Condition 2\n    p = parent(n, steps)\n    check, steps = hasAncestor(p, isRoot)\n    steps != nsteps && return false\n    return true\nend\n\n\nQ3_fun (generic function with 1 method)\n\n\nAnd applying the query to the object results in the required nodes:\n\n\nShow the code\nQ3 = Query(Q.B, n -> Q3_fun(n, 2))\nA3 = apply(graph, Q3)\n\n\n3-element Vector{Main.Queries.B}:\n Main.Queries.B(3)\n Main.Queries.B(2)\n Main.Queries.B(1)"
  },
  {
    "objectID": "tutorials/relational_queries/index.html#node-containing-value-4",
    "href": "tutorials/relational_queries/index.html#node-containing-value-4",
    "title": "Relational queries",
    "section": "Node containing value 4",
    "text": "Node containing value 4\nThe node B with value 4 can be singled-out because there is no branching point between the root node and this node. This means that no ancestor node should have more than one children node except the root node. Remember that hasAncestor() returns two values, but we are only interested in the first value. You do not need to assign the returned object from a Julia function, you can just index directly the element to be selected from the returned tuple:\n\n\nShow the code\nfunction Q4_fun(n)\n    !hasAncestor(n, x -> !isRoot(x) && length(children(x)) > 1)[1]\nend\n\n\nQ4_fun (generic function with 1 method)\n\n\nAnd applying the query to the object results in the required node:\n\n\nShow the code\nQ4 = Query(Q.B, Q4_fun)\nA4 = apply(graph, Q4)\n\n\n1-element Vector{Main.Queries.B}:\n Main.Queries.B(4)"
  },
  {
    "objectID": "tutorials/relational_queries/index.html#node-containing-value-3",
    "href": "tutorials/relational_queries/index.html#node-containing-value-3",
    "title": "Relational queries",
    "section": "Node containing value 3",
    "text": "Node containing value 3\nThis node is the only B node that is four steps from the root node, which we can retrieve from the second argument returned by hasAncestor():\n\n\nShow the code\nfunction Q5_fun(n)\n    check, steps = hasAncestor(n, isRoot)\n    steps == 4\nend\n\nQ5 = Query(Q.B, Q5_fun)\nA5 = apply(graph, Q5)\n\n\n1-element Vector{Main.Queries.B}:\n Main.Queries.B(3)"
  },
  {
    "objectID": "tutorials/relational_queries/index.html#node-containing-value-7",
    "href": "tutorials/relational_queries/index.html#node-containing-value-7",
    "title": "Relational queries",
    "section": "Node containing value 7",
    "text": "Node containing value 7\nNode B 7 belongs to the second lateral branch motif and the second parent node is of type A. Note that we can reuse the Q3_fun from before in the condition required for this node:\n\n\nShow the code\nfunction Q6_fun(n, nA)\n    check = Q3_fun(n, nA)\n    !check && return false\n    p2 = parent(n,2)\n    data(p2) isa Q.A\nend\n\nQ6 = Query(Q.B, n -> Q6_fun(n, 3))\nA6 = apply(graph, Q6)\n\n\n1-element Vector{Main.Queries.B}:\n Main.Queries.B(7)"
  },
  {
    "objectID": "tutorials/relational_queries/index.html#nodes-containing-values-11-and-13",
    "href": "tutorials/relational_queries/index.html#nodes-containing-values-11-and-13",
    "title": "Relational queries",
    "section": "Nodes containing values 11 and 13",
    "text": "Nodes containing values 11 and 13\nThe B nodes 11 and 13 actually have different relationships to the rest of the graph, so we just need to define two different condition functions and combine them. The condition for the B node 11 is similar to the B node 7, whereas the condition for node 13 was already constructed before, so we just need to combined them with an OR operator:\n\n\nShow the code\nQ7 = Query(Q.B, n -> Q6_fun(n, 4) || Q2_fun(n))\nA7 = apply(graph, Q7)\n\n\n2-element Vector{Main.Queries.B}:\n Main.Queries.B(11)\n Main.Queries.B(13)"
  },
  {
    "objectID": "tutorials/relational_queries/index.html#nodes-containing-values-1-5-and-9",
    "href": "tutorials/relational_queries/index.html#nodes-containing-values-1-5-and-9",
    "title": "Relational queries",
    "section": "Nodes containing values 1, 5 and 9",
    "text": "Nodes containing values 1, 5 and 9\nThese nodes play the same role in the three lateral branch motifs. They are the only B nodes preceded by the sequence A C+ A. We just need to check the sequence og types of objects for the the first three parents of each B node:\n\n\nShow the code\nfunction Q8_fun(n)\n    p1 = parent(n)\n    p2 = parent(n, 2)\n    p3 = parent(n, 3)\n    data(p1) isa Q.A && data(p2) isa Q.C && data(p2).val > 0.0 && data(p3) isa Q.A\nend\n\nQ8 = Query(Q.B, Q8_fun)\nA8 = apply(graph, Q8)\n\n\n3-element Vector{Main.Queries.B}:\n Main.Queries.B(5)\n Main.Queries.B(1)\n Main.Queries.B(9)"
  },
  {
    "objectID": "tutorials/relational_queries/index.html#nodes-contaning-values-2-6-and-10",
    "href": "tutorials/relational_queries/index.html#nodes-contaning-values-2-6-and-10",
    "title": "Relational queries",
    "section": "Nodes contaning values 2, 6 and 10",
    "text": "Nodes contaning values 2, 6 and 10\nThis exercise is similar to the previous one, but the C node has a negative val. The problem is that node 12 would also match the pattern A C- A. We can differentiate between this node and the rest by checking for a fourth ancestor node of class C:\n\n\nShow the code\nfunction Q9_fun(n)\n    p1 = parent(n)\n    p2 = parent(n, 2)\n    p3 = parent(n, 3)\n    p4 = parent(n, 4)\n    data(p1) isa Q.A && data(p2) isa Q.C && data(p2).val < 0.0 && \n       data(p3) isa Q.A && data(p4) isa Q.C\nend\n\nQ9 = Query(Q.B, Q9_fun)\nA9 = apply(graph, Q9)\n\n\n3-element Vector{Main.Queries.B}:\n Main.Queries.B(10)\n Main.Queries.B(6)\n Main.Queries.B(2)"
  },
  {
    "objectID": "tutorials/relational_queries/index.html#nodes-containg-values-6-7-and-8",
    "href": "tutorials/relational_queries/index.html#nodes-containg-values-6-7-and-8",
    "title": "Relational queries",
    "section": "Nodes containg values 6, 7 and 8",
    "text": "Nodes containg values 6, 7 and 8\nWe already came up with a condition to extract node 7. We can also modify the previous condition so that it only node 6. Node 8 can be identified by checking for the third parent node being of type C and being 5 nodes from the root of the graph.\nAs always, we can reusing previous conditions since they are just regular Julia functions:\n\n\nShow the code\nfunction Q10_fun(n)\n    Q6_fun(n, 3) && return true # Check node 7\n    Q9_fun(n) && hasAncestor(n, isRoot)[2] == 6 && return true # Check node 6\n    hasAncestor(n, isRoot)[2] == 5 && data(parent(n, 3)) isa Q.C && return true # Check node 8 (and not 4!)\nend\n\nQ10 = Query(Q.B, Q10_fun)\nA10 = apply(graph, Q10)\n\n\n3-element Vector{Main.Queries.B}:\n Main.Queries.B(7)\n Main.Queries.B(8)\n Main.Queries.B(6)"
  },
  {
    "objectID": "tutorials/relational_queries/index.html#nodes-containig-values-3-7-11-and-12",
    "href": "tutorials/relational_queries/index.html#nodes-containig-values-3-7-11-and-12",
    "title": "Relational queries",
    "section": "Nodes containig values 3, 7, 11 and 12",
    "text": "Nodes containig values 3, 7, 11 and 12\nWe already have conditions to select nodes 3, 7 and 11 so we just need a new condition for node 12 (similar to the condition for 8).\n\n\nShow the code\nfunction Q11_fun(n)\n    Q5_fun(n) && return true # 3\n    Q6_fun(n, 3) && return true # 7\n    Q6_fun(n, 4) && return true # 11\n    hasAncestor(n, isRoot)[2] == 5 && data(parent(n, 2)) isa Q.C && \n        data(parent(n, 4)) isa Q.A && return true # 12\nend\n\nQ11 = Query(Q.B, Q11_fun)\nA11 = apply(graph, Q11)\n\n\n4-element Vector{Main.Queries.B}:\n Main.Queries.B(7)\n Main.Queries.B(3)\n Main.Queries.B(12)\n Main.Queries.B(11)"
  },
  {
    "objectID": "tutorials/relational_queries/index.html#nodes-containing-values-7-and-12",
    "href": "tutorials/relational_queries/index.html#nodes-containing-values-7-and-12",
    "title": "Relational queries",
    "section": "Nodes containing values 7 and 12",
    "text": "Nodes containing values 7 and 12\nWe just need to combine the conditions for the nodes 7 and 12\n\n\nShow the code\nfunction Q12_fun(n)\n    Q6_fun(n, 3) && return true # 7\n    hasAncestor(n, isRoot)[2] == 5 && data(parent(n, 2)) isa Q.C && \n        data(parent(n, 4)) isa Q.A && return true # 12\nend\n\nQ12 = Query(Q.B, Q12_fun)\nA12 = apply(graph, Q12)\n\n\n2-element Vector{Main.Queries.B}:\n Main.Queries.B(7)\n Main.Queries.B(12)"
  },
  {
    "objectID": "tutorials/snowflakes/index.html",
    "href": "tutorials/snowflakes/index.html",
    "title": "The Koch snowflake",
    "section": "",
    "text": "First four iterations fo Koch snowflake fractal\n\n\nIn order to implement the construction process of a Koch snowflake in VPL we need to understand how a 3D structure can be generated from a graph of nodes. VPL uses a procedural approach to generate of structure based on the concept of turtle graphics.\nThe idea behind this approach is to imagine a turtle located in space with a particular position and orientation. The turtle then starts consuming the different nodes in the graph (following its topological structure) and generates 3D structures as defined by the user for each type of node. The consumption of a node may also include instructions to move and/or rotate the turtle, which allows to alter the relative position of the different 3D structures described by a graph.\nThe construction process of the Koch snowflake in VPL could then be represented by the following axiom and rewriting rule:\naxiom: E(L) + RU(120) + E(L) + RU(120) + E(L) rule: E(L) → E(L/3) + RU(-60) + E(L/3) + RU(120) + E(L/3) + RU(-60) + E(L/3)\nWhere E represent and edge of a given length (given in parenthesis) and RU represents a rotation of the turtle around the upward axis, with angle of rotation given in parenthesis in hexadecimal degrees. The rule can be visualized as follows:\n\n\n\nKoch construction rule\n\n\nNote that VPL already provides several classes for common turtle movements and rotations, so our implementation of the Koch snowflake only needs to define a class to implement the edges of the snowflake. This can be achieved as follows:\nusing VPL\nmodule sn\n    import VPL\n    struct E <: VPL.Node\n        length::Float64\n    end\nend\nimport .sn\nNote that nodes of type E need to keep track of the length as illustrated in the above. The axiom is straightforward:\n\nconst L = 1.0\naxiom = sn.E(L) + VPL.RU(120.0) + sn.E(L) + VPL.RU(120.0) + sn.E(L)\n\nVPL.Core.StaticGraph(Dict{Int64, Any}(5 => VPL.Core.GraphNode{Main.sn.E}(Main.sn.E(1.0), Set{Int64}(), 4, 5), 4 => VPL.Core.GraphNode{VPL.Geom.RU{Float64}}(VPL.Geom.RU{Float64}(120.0), Set([5]), 3, 4), 2 => VPL.Core.GraphNode{VPL.Geom.RU{Float64}}(VPL.Geom.RU{Float64}(120.0), Set([3]), 1, 2), 3 => VPL.Core.GraphNode{Main.sn.E}(Main.sn.E(1.0), Set([4]), 2, 3), 1 => VPL.Core.GraphNode{Main.sn.E}(Main.sn.E(1.0), Set([2]), missing, 1)), Dict{DataType, Set{Int64}}(Main.sn.E => Set([5, 3, 1]), VPL.Geom.RU{Float64} => Set([4, 2])), 1, 5)\n\n\nThe rule is also straightforward to implement as all the nodes of type E will be replaced in each iteration. However, we need to ensure that the length of the new edges is a calculated from the length of the edge being replaced. In order to extract the data stored in the node being replaced we can simply use the function data. In this case, the replacement function is defined and then added to the rule. This can make the code more readable but helps debugging and testing the replacement function.\n\nfunction Kochsnowflake(x)\n    L = data(x).length\n    sn.E(L/3) + RU(-60.0) + sn.E(L/3) + RU(120.0) + sn.E(L/3) + RU(-60.0) + sn.E(L/3)\n end\n rule = Rule(sn.E, rhs = Kochsnowflake)\n\nRule replacing nodes of type Main.sn.E without context capturing.\n\n\nThe model is then created by constructing the graph\n\nKoch = Graph(axiom, rules = Tuple(rule))\n\nDynamic graph with 5 nodes of types Main.sn.E,VPL.Geom.RU{Float64} and 1 rewriting rules.\n\n\nIn order to be able to generate a 3D structure we need to define a method for the function VPL.feedgeom! (notice the need to prefix it with VPL. as we are going to define a method for this function). The method needs to two take two arguments, the first one is always an object of type MTurtle and the second is an object of the type for which the method is defined (in this case, E).\nThe body of the method should generate the 3D structures using the geometry primitives provided by VPL and feed them to the turtle that is being passed to the method as first argument. In this case, we are going to represent the edges of the Koch snowflakes with cylinders, which can be generated with the HollowCylinder! function from VPL. Note that the feedgeom! should return nothing, the turtle will be modified in place (hence the use of ! at the end of the function as customary in the VPL community):\nfunction VPL.feedgeom!(turtle::MTurtle, e::sn.E)\n    HollowCylinder!(turtle, l = e.length, w = e.length/10, h = e.length/10, move = true)\n    return nothing\nend\nNote that the argument move = true indicates that the turtle should move forward as the cylinder is generated a distance equal to the length of the cylinder.\nWith the feedgeom! method defined we can already generate the 3D structure, but we cannot render it yet as we also need to define the color with which to render it. This is achieved by defining the VPL.feedcolor! method that takes a GLTurtle as argument (notice the different data types, MTurtle to collect triangular meshes, GLTurtle to collect colors for rendering). In this case, we just feed a basic RGB color defined by the proportion of red, green and blue. To make the figures more appealing, we can assign random values to each channel of the color to generate random colors.\nfunction VPL.feedcolor!(turtle::GLTurtle, e::sn.E)\n    feedcolor!(turtle, RGB(rand(), rand(), rand()))\n    return nothing\nend\nAfter defining these two methods, we can now call the function render on the graph to generate a 3D interactive image of the Koch snowflake in the current state\n\nrender(Koch, axes = false)\n\n\n\n\nThis renders the initial triangle of the construction procedure of the Koch snowflake. Let’s execute the rules once to verify that we get the 2nd iteration (check the figure at the beginning of this document):\n\nrewrite!(Koch)\nrender(Koch, axes = false)\n\n\n\n\nAnd two more times\n\nfor i in 1:3\n    rewrite!(Koch)\nend\nrender(Koch, axes = false)\n\n\n\n\n\nOther snowflake fractals\nTo demonstrate the power of this approach, let’s create an alternative snowflake. We will simply invert the rotations of the turtle in the rewriting rule\n\nfunction Kochsnowflake2(x)\n   L = data(x).length\n   sn.E(L/3) + RU(60.0) + sn.E(L/3) + RU(-120.0) + sn.E(L/3) + RU(60.0) + sn.E(L/3)\nend\nrule2 = Rule(sn.E, rhs = Kochsnowflake2)\nKoch2 = Graph(axiom, rules = Tuple(rule2))\n\nDynamic graph with 5 nodes of types Main.sn.E,VPL.Geom.RU{Float64} and 1 rewriting rules.\n\n\nThe axiom is the same, but now the edges added by the rule will generate the edges towards the inside of the initial triangle. Let’s execute the first three iterations and render the results\n\n# First iteration\nrewrite!(Koch2)\nrender(Koch2, axes = false)\n# Second iteration\nrewrite!(Koch2)\nrender(Koch2, axes = false)\n# Third iteration\nrewrite!(Koch2)\nrender(Koch2, axes = false)\n\n\n\n\nThis is know as Koch antisnowflake. We could also easily generate a Cesàro fractal by also changing the axiom:\n\naxiomCesaro = sn.E(L) + RU(90.0) + sn.E(L) + RU(90.0) + sn.E(L) + RU(90.0) + sn.E(L)\nCesaro = Graph(axiomCesaro, rules = (rule2,))\nrender(Cesaro, axes = false)\n\n\n\n\nAnd, as before, let’s go through the first three iterations\n\n# First iteration\nrewrite!(Cesaro)\nrender(Cesaro, axes = false)\n# Second iteration\nrewrite!(Cesaro)\nrender(Cesaro, axes = false)\n# Third iteration\nrewrite!(Cesaro)\nrender(Cesaro, axes = false)"
  }
]