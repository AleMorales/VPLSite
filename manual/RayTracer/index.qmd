---
title: "Ray tracing distribution of irradiance"
author: 
    - name: "Alejandro Morales Sierra"
      affiliation: "Centre for Crop Systems Analysis - Wageningen University"
date: last-modified
execute: 
    enabled: false
---

# Ray tracing

## Overview

<!-- Finish the overview -->

Basics of ray tracing

Russian roulette

RTSettings()

Raytracer()

trace()!

## Radiation sources

<!-- Finish the radiation sources section -->


Because of the way directional sources are implemented (i.e., as rays emitted 
from upper face of the scene bounding box), it is recommended that a grid cloner
is used as otherwise there will parts of the scene that will recieve no rays.

## Materials

Several types of materials are available for ray tracing, which all inherit from
the `Material` abstract type. The materials play two roles: (i) they define the
optical properties of the surface (i.e., reflectance and transmittance) for
the different wavelengths being simulated, and (ii) store the radiant power 
absorbed by the surface. If the radiant power of a surface is needed, it is 
important that the material object is stored in a data structure that the user
can have access to (e.g., within a node in a graph) as the raytracer will simply
modify in-place (without creating a copy) the material object when a ray is absorbed.
The radiant power in a material can be retrieved by applying `power()` to the object.

Materials are added to the scene at ther same time as the geometry either via 
`feed()` or `add!()`. It is possible to add one material per mesh (in which case
all triangles within that mesh will share the same material object) or one material
per triangle. In either case, VPL will take care of creating the corresponding
association between the material and the triangles. 

VPL will not check that the number of wavelengths in the material matches the 
equivalent number in the radiation source or that the same ordering is used. 
This is entirely up to the user.

The following material types are available in VPL:

   - `Black`: A material that absorbs all the rays that hit it (equivalent to no
reflectance or transmittance). It is not a realistic material but it is useful
for debugging purposes or for special uses of a ray tracer (e.g., to compute 
ground cover).

   - `Sensor`: A material that registers the rays that hit and their radian power
but it does not alter the radiant power or the direction of the rays themselves. 
This is useful for measuring the distribution of irradiance within canopy without
disturbing the system. Note that a `Sensor` will not add to the scattering counter
either so there is no need to modify the settings of the Russian roulette.

   - `Lambertian`: A material that describes a perfect diffuser with user-defined
reflectance and transmittance per wavelength.

   - `Phong`: A modified Phong material that implements the equations by 
[Lafortune & Willems (1994)](https://www.cs.princeton.edu/courses/archive/fall03/cs526/papers/lafortune94.pdf).
Reflectance is modelled as a combination of a diffuse and a specular component per
wavelength.

## Acceleration of ray tracing

In order to accelerate the tracing of rays within the 3D scene, a [bounding
volume hierarchy](https://en.wikipedia.org/wiki/Bounding_interval_hierarchy) may be used by setting `acceleration = BVH` in the call to
`RayTracer()`. This will create a series of nested [axis-aligned bounding boxes](https://en.wikipedia.org/wiki/Bounding_volume)
organized as a binary tree. The purpose of this structure is to reduce the
number of triangles that need to be tested against each ray (i.e., if a ray
does not intersect a particular box, it will not intersect any of the triangles
inside of it). This does add some additional cost due to the need to test the
intersection of rays against the bounding boxes, but ideally this is much less
than the cost of testing against all the excluded triangles.

The tree is constructed by recursively splitting
each box into two halves and allocating the different triangles in the mesh
to the corresponding boxes. Two rules are available for splitting the boxes, 
which must also be specified in the call to `RayTracer()`: 

- `rule = AvgSplit(N, L)`: It splits each node along the longest axis at the
average coordinate of the triangles in the node. The splitting is repeated
until the number of triangles in a node is lessor equal than `N` or the total
number of recursive splits (i.e., the depth of the binary tree) reaches `L`.

- `rule = SAH{K}(N, L)`: It splits each node using the [Surface Area Heuristic](https://medium.com/@bromanz/how-to-create-awesome-accelerators-the-surface-area-heuristic-e14b5dec6160) 
that defines the expected computation of ray tracing a splitted node versus not
doing it. This method computes the cost of splitting each box along each of its 
three axes at different positions given by the value `K`. When `K = 1` the split
occurs at the median of the triangles in the box. For `K > 1` the splits occur at
different quantiles of the triangles in the box. The splitting is repeated
until the number of triangles in a node is lessor equal than `N` or the total
number of recursive splits reaches `L` or the cost of splitting a node exceeds
the cost of not splitting it.

For debugging purposes (or for very small scenes), the user may also specify 
`acceleration = Naive` which will basically not implement any acceleration 
structured and all rays will be tested against all triangles.

The acceleration structure is created from a `Scene` object via the `accelerate()`
function, and allows specifying the `acceleration` and `rule` arguments. This will
also be responsible of translating the triangular mesh into the data structure
used by the ray tracer (triangles in [barycentric coordinates](https://en.wikipedia.org/wiki/Barycentric_coordinate_system)) as well as fitting
a grid cloner to the scene (see below).

## Grid cloner for edge effects

The grid cloner is used to minimize border effects when tracing rays from the 
sources towards the scene. The grid cloner is a form of [geometric *instancing*](https://en.wikipedia.org/wiki/Geometry_instancing)
where the same scene is repeated multiple times along the X, Y or Z direction. In
practice, to avoid excessive memory usage, the scene is not actually replicated
but rather the rays positions are modified to account to emulate the effect of
the scene being repeated.

In order a grid cloner structure on top of a scene, the user needs to specify
the number of duplications to perform in each direction (`nx`, `ny` and `nz`) as well as the
offsets between the different copies (`dx`, `dy` and `dz`). The
grid cloner is created from a `Scene` object via the `accelerate()` function, but
the settings to control the grid cloner must be set when creating the 
`RTSettings` object.

By default, the grid cloner is enabled in the X and Y directions
by replicating the scene three times in each direction (this means creating a grid of
7 x 7 = 49 copies of the scene including the original). The offsets between 
the copies are set by default
to width of the scene in the X and Y directions such that there is no overlapping.
The grid cloner is disabled in the Z direction by default.

Note that whereas a grid cloner will not increase significantly the memory used
by the ray tracer, it will increase ray tracing times as fewer rays will be able
to leave the scene. On the other hand, a small (or no) grid cloner will create
an edge effect such that only plants in the center of the scene will be able to
capture the behaviour within a large canopy. 

The actual number of copies to use
will depend on plant dimension and solar angles, so a general recommendation is 
not possible. Regarding the offsets, these would be related to the sowing/planting
pattern in the case of plant production systems on a regular grid and in many case
this would mean that the copies overlap (and this would be correct) so the defaults
should be overriden in most cases. Using a grid cloner should not be substitute
for using a sufficient number of plants in the scene in order to capture the
plant-to-plant variability, but simply to avoid edge effects.
